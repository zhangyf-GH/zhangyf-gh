<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开博</title>
    <url>/2019/%E5%BC%80%E5%8D%9A/</url>
    <content><![CDATA[<p>记录生活<br>感悟人生</p>
]]></content>
  </entry>
  <entry>
    <title>LF will be replaced by CRLF</title>
    <url>/2020/git/LF-will-be-replaced-by-CRLF/</url>
    <content><![CDATA[<p>本文主要写了在 Hexo 博客中 出现 LF will be replaced by CRLF 的原因以及它的解决方式。</p>
<h5 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h5><ol>
<li>windows中的换行符为 CRLF，而在Linux下的换行符为LF，所以在执行add时出现提示 </li>
<li>CRLF和LF是两种不同的换行格式，git工作区默认为CRLF来作为换行符，<br> 所以当我们项目文件里有用的地方使用LF作为换行符，这个时候我们再继续git add<br> 或者git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符 </li>
</ol>
<h5 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h5><ol>
<li>这个只是一个警告，我们直接忽略就好。</li>
<li>在hexo目下的.deploy_git目录下打开git bash 执行git config –global core.autocrlf false //禁用自动转换 </li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitPages搭建博客</title>
    <url>/2021/hexo/Hexo-GitPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>假设：邮箱：<a href="mailto:aaa@163.com" target="_blank" rel="noopener">aaa@163.com</a>  </p>
<p>​            名字: aaa</p>
<p>1.到官网下载git安装包后安装</p>
<p>2.在Windows系统安装git后，配置SSH key </p>
<p>用git bash执行如下命令： windows中在C:\Users\zhangyf.ssh目录</p>
<p><code>$ cd ~/. ssh #检查本机已存在的ssh密钥</code></p>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<p><code>ssh-keygen -t rsa -C &quot;aaa@163.com&quot;</code></p>
<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image002.png" alt="img"></p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<p>3.测试是否成功</p>
<p>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> # 注意邮箱地址不用改</p>
<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p>
<p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<p><code>git config --global user.email &quot;aaa@163.com&quot;</code></p>
<p><code>git config --global user.name &quot;aaa&quot;</code></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>在node.js官网下载安装包安装即可</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image004.jpg" alt="img"></p>
<p>然后在文件夹中右击打开git命令框(我第一次直接在桌面右击，所以命令行无效果)</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image006.jpg" alt="img"></p>
<p>在git命令框中安装hexo命令行工具 ，执行 <code>npm install -g hexo-cli</code> </p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image008.jpg" alt="img"></p>
<p> 初始化 ，执行<code>hexo init zyfblog</code> 加上zyfblog，则全部文件都在zyfblog下</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image010.jpg" alt="img"></p>
<p>执行<code>cd zyfblog</code> 进入zyfblog目录</p>
<p>启动服务，依次执行</p>
<p><code>(npm install --&gt;hexo server)</code></p>
<p>浏览器输入<a href="http://localhost:4000,按理来说应该会出现本地访问页面" target="_blank" rel="noopener">http://localhost:4000,按理来说应该会出现本地访问页面</a></p>
<h2 id="部署到GItPages"><a href="#部署到GItPages" class="headerlink" title="部署到GItPages"></a>部署到GItPages</h2><h3 id="在github上面创建项目"><a href="#在github上面创建项目" class="headerlink" title="在github上面创建项目"></a>在github上面创建项目</h3><p>假设:Owner为: zhangyfzone </p>
<p>​         <strong>Repository name必须为: zhangyfzone.github.io</strong></p>
<p>​         申请的域名：minmax.site</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/image-20210330094423950.png" alt="image-20210330094423950"></p>
<h3 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h3><p>如果没有域名，则只能通过GitPages默认链接访问<a href="https://zhangyfzone.github.io/" target="_blank" rel="noopener">https://zhangyfzone.github.io/</a></p>
<p>如果有域名，可将域名解析到zhangyfzone.github.io，这样比较简洁。</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image016.png" alt="img"></p>
<h3 id="hexo-CNAME设置"><a href="#hexo-CNAME设置" class="headerlink" title="hexo CNAME设置"></a>hexo CNAME设置</h3><p> Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀)</p>
<p>创建方式：右键新建txt文本-&gt;输入你购买的域名minmax.site&gt;保存关闭</p>
<p>然后快捷键F2或者右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image018.jpg" alt="img"></p>
<p>内容如下所示</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image019.png" alt="img"></p>
<h3 id="github上绑定域名"><a href="#github上绑定域名" class="headerlink" title="github上绑定域名"></a>github上绑定域名</h3><p>在设置中的custom domain填入域名minmax.site 保存</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image021.png" alt="img"></p>
<h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image023.jpg" alt="img"></p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image024.png" alt="img"></p>
<p>配置github项目连接(</p>
<p>deploy: </p>
<p>type: git </p>
<p>repos: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:zhangyfzone/zhangyfzone.github.io.git</p>
<p>branch: master):</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image026.jpg" alt="img"></p>
<h3 id="使用git发布"><a href="#使用git发布" class="headerlink" title="使用git发布"></a>使用git发布</h3><p>执行 <code>npm install hexo-deployer-git --save</code></p>
<p>基本的流程到这里快要结束了</p>
<p>信件一篇博文  <code>hexo new post &#39;第一篇博文&#39;</code>  可在source/post文件夹下面看到，可以编辑内容。</p>
<p>最后执行:<code>(hexo clean --&gt;hexo generate --&gt;hexo deploy)</code></p>
<p><code>hexo generate --&gt;hexo deploy</code> 可简写为 <code>hexo g -d</code></p>
<p>你就可以通过域名看到你的博客了</p>
<p>记住，每次修改配置信息或者其他必须要执行上面的步骤，才可以使得配置信息生效。</p>
<p> 常用命令：</p>
<p><code>hexo new &#39;博文&#39;</code>  默认创建post</p>
<p><code>hexo server</code></p>
<p><code>hexo g -d</code></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署到VPS</title>
    <url>/2021/hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>网上流传的武功秘籍分为两种：</p>
<ul>
<li>将 Hexo 项目上传到 VPS 上面后执行 <code>hexo server</code>，之后配置 Nginx 反向代理，让域名指向 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>。</li>
<li>将 Hexo 在本地通过 <code>hexo generate</code> 生成静态文件，在通过 <code>hexo deploy</code> 部署到 VPS 上面，使用 Nginx 直接做 Web 服务器。</li>
</ul>
<p>相比第二种方式，第一种每次写博客与更新博客时候的操作会很繁琐。所以我们使用第二种方式进行部署，这样既可以将静态文件 deploy 到 VPS 上，也可以上传到 Github 上用作备份，操作性和安全性上都要胜于前者。</p>
<p>而对于第二种方式而言，常用的又有 <code>git hook</code> 和 <code>rsync</code> 两种自动部署解决方案。</p>
<p>本文主要介绍 <code>git hook</code> 部署过程，过程为：</p>
<p>我们在本地编辑文本，然后使用 Git 远程部署到 VPS 的 Git 仓库。<code>hexo d</code> 命令实际上只 deploy 了本地的 public 文件夹，Git Hooks 实际上就是当 Git 仓库收到最新的 push 时，将 Git 仓库接受到的内容复制到 VPS 上的网站目录内。相当于完成了手动将 public 文件夹复制到 VPS 的网站根目录里。</p>
<p>在vps上搭建hexo博客需要下面这些工具：</p>
<ol>
<li>Nginx: 用于博客展示</li>
<li>SSH：用于Git 推送</li>
<li>Git: 用于将生成的静态文件推送到vps上</li>
</ol>
<p>本文服务器环境为CentOS 7.6</p>
<p>之前本地已经搭建好Hexo博客，之前是提交到Github进行更新</p>
<h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>查看C:\Users\用户名\.ssh 下是否存在私钥文件<code>id_rsa</code>和公钥文件<code>id_rsa.pub</code></p>
<p>如果没有，则需要通过<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code> 生成</p>
<h2 id="VPS端配置"><a href="#VPS端配置" class="headerlink" title="VPS端配置"></a>VPS端配置</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>ssh连接到VPS后，执行如下指令进行Git的安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update &amp;&amp; upgrade -y</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install git-core</span><br></pre></td></tr></table></figure>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx -y</span><br><span class="line">service nginx start  #启动nginx</span><br></pre></td></tr></table></figure>
<p>如果开启了防火墙，还要在防火墙上开启响应端口，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">启动： systemctl start firewalld</span><br><span class="line">关闭： systemctl stop firewalld</span><br><span class="line">查看状态： systemctl status firewalld </span><br><span class="line">开机禁用 ： systemctl disable firewalld</span><br><span class="line">开机启用 ： systemctl enable firewalld</span><br></pre></td></tr></table></figure>
<p>安装完Nginx后，最好设置Nginx为开机自启动，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h3 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h3><ol>
<li>新建git用户，在终端输入如下指令以新建账户，专门用于提交git</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">adduser git #创建新用户，名为git</span><br></pre></td></tr></table></figure>
<p>接下来修改git账户的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>在<code>root ALL=(ALL) ALL</code>下面新建一段字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git ALL=(ALL) install</span><br></pre></td></tr></table></figure>
<p>接着保存退出，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 440 /etc/sudoers</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建git仓库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git                 # 操作转到git用户</span><br><span class="line">cd                     # 定位到Home目录</span><br><span class="line">mkdir .ssh &amp;&amp; cd .ssh  # 创建.ssh文件夹并进入</span><br><span class="line">vi authorized_keys     # 创建密钥文件</span><br></pre></td></tr></table></figure>
<p>此时，将本地<code>id_rsa.pub</code>文件内的内容粘贴到新建的<code>authorized_keys</code>文件中。接下来执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">mkdir hexo.git &amp;&amp; cd hexo.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<p>此时，在本地终端中输入<code>ssh git@VPS_ip</code>查看收否能连接，如果提示要密码，则需要在VPS内设置一下git用户的密码，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd git</span><br></pre></td></tr></table></figure>
<p>接着设置git用户的密码，并在本地终端中重新连接，输入密码，应该就可以连接了。</p>
<p>如果部署时还是需要密码，则是authorized_keys 文件权限设置有问题，请查看博客里的另一篇文章 <a href="http://www.minmax.site/2021/03/25/authorized-keys不生效解决办法/" target="_blank" rel="noopener">authorized_keys不生效解决办法</a></p>
<ol start="3">
<li>接下来要创建网站的目录，并赋予权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">cd /var/www</span><br><span class="line">mkdir hexo</span><br><span class="line">chown git:git -R /var/www/hexo</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置Git Hooks</li>
</ol>
<p>【注意】这一步在git用户下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">cd /home/git/hexo.git/hooks</span><br><span class="line">vi post-receive</span><br></pre></td></tr></table></figure>
<p>输入如下内容后保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">GIT_REPO=/home/git/hexo.git       #git仓库路径</span><br><span class="line">TMP_GIT_CLONE=/tmp/hexo</span><br><span class="line">PUBLIC_WWW=/var/www/hexo          #hexo网站目录</span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;/*</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>
<p>接着赋予权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
<h3 id="Nginx相关配置"><a href="#Nginx相关配置" class="headerlink" title="Nginx相关配置"></a>Nginx相关配置</h3><p>【注意】本操作在root用户下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">vim /etc/nginx/conf.d/hexo.conf</span><br></pre></td></tr></table></figure>
<p>插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80 ;</span><br><span class="line">    root /var/www/hexo; //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">    server_name example.com www.example.com;   //这里输入你的域名或IP地址</span><br><span class="line">    access_log  /var/log/nginx/hexo_access.log;</span><br><span class="line">    error_log   /var/log/nginx/hexo_error.log;</span><br><span class="line">    location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">            root /var/www/hexo;</span><br><span class="line">            access_log   off;</span><br><span class="line">            expires      1d;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">        root /var/www/hexo;</span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      10m;</span><br><span class="line">    &#125;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/hexo;      //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">        if (-f $request_filename) &#123;</span><br><span class="line">            rewrite ^/(.*)$  /$1 break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<h2 id="本地Hexo配置修改"><a href="#本地Hexo配置修改" class="headerlink" title="本地Hexo配置修改"></a>本地Hexo配置修改</h2><p>在本地<code>hexo</code>博客文件下，编辑配置文件<code>\_config.yml</code>，修改<code>deploy</code>选项，可同时发布到github和vps</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:zhangyfzone/zhangyfzone.github.io.git  #gitHub上用作备份</span><br><span class="line">    branch: master</span><br><span class="line">  - type: git</span><br><span class="line">    repo: ssh://git@VPSIP:端口号/~/hexo.git   #部署到VPS上</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>保存修改后，便可以使用<code>hexo g</code>,<code>hexo d</code>等指令进行博客更新了。</p>
<h2 id="gitHub配置更改"><a href="#gitHub配置更改" class="headerlink" title="gitHub配置更改"></a>gitHub配置更改</h2><p>如果之前部署到github上时设置了域名，则再setting里把custom domain 之前设置的域名清除。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>CollectionUtils工具类</title>
    <url>/2020/java/CollectionUtils%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>这篇讲的CollectionUtils工具类是在<code>apache下</code>的, 而不是springframework下的CollectionUtils。</p>
<p>个人觉得CollectionUtils在真实项目中,可以使你的代码更加简洁和安全。</p>
<p>所以需要倒入相关jar包,目前从maven找到最新jar包如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="API常用方法"><a href="#API常用方法" class="headerlink" title="API常用方法"></a>API常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、除非元素为null，否则向集合添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.addIgnoreNull(personList,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b, Comparator&lt;? <span class="keyword">super</span> O&gt; c)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、返回该个集合中是否含有至少有一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.containsAny(Collection&lt;?&gt; coll1, T... coll2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&lt;&gt;()）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.emptyIfNull(Collection&lt;T&gt; collection)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6、空安全检查指定的集合是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、 空安全检查指定的集合是否为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isNotEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8、反转给定数组的顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.reverseArray(Object[] array);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 9、差集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.subtract(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10、并集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.union(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 11、交集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.intersection(Collection a, Collection b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *12、 交集的补集（析取）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.disjunction(Collection a, Collection b)</span><br></pre></td></tr></table></figure>
<h2 id="非对象集合交、并、差处理"><a href="#非对象集合交、并、差处理" class="headerlink" title="非对象集合交、并、差处理"></a>非对象集合交、并、差处理</h2><p>对于集合取交集、并集的处理其实有很多种方式,这里就介绍3种</p>
<ul>
<li>第一种 是CollectionUtils工具类</li>
<li>第二种 是List自带方法</li>
<li>第三种 是JDK1.8 stream 新特性</li>
</ul>
<h3 id="CollectionUtils工具类"><a href="#CollectionUtils工具类" class="headerlink" title="CollectionUtils工具类"></a>CollectionUtils工具类</h3><p>下面对于基本数据(包扩String)类型中的集合进行demo示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">       String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">       List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">       List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1、并集 union</span></span><br><span class="line">       System.out.println(CollectionUtils.union(listA, listB));</span><br><span class="line">       <span class="comment">//输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、交集 intersection</span></span><br><span class="line">       System.out.println(CollectionUtils.intersection(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//3、交集的补集（析取）disjunction</span></span><br><span class="line">       System.out.println(CollectionUtils.disjunction(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4、差集（扣除）</span></span><br><span class="line">       System.out.println(CollectionUtils.subtract(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="List自带方法"><a href="#List自带方法" class="headerlink" title="List自带方法"></a>List自带方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、交集</span></span><br><span class="line">    List&lt;String&gt;  jiaoList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    jiaoList.retainAll(listB);</span><br><span class="line">    System.out.println(jiaoList);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、差集</span></span><br><span class="line">    List&lt;String&gt;  chaList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    chaList.removeAll(listB);</span><br><span class="line">    System.out.println(chaList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、并集 (先做差集再做添加所有）</span></span><br><span class="line">    List&lt;String&gt;  bingList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    bingList.removeAll(listB); <span class="comment">// bingList为 [1, 2]</span></span><br><span class="line">    bingList.addAll(listB);  <span class="comment">//添加[3,4,5,6]</span></span><br><span class="line">    System.out.println(bingList);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>注意</code> : <strong>intersection和retainAll的差别</strong></p>
<p>要注意的是它们的返回类型是不一样的,<code>intersection</code>返回的是一个新的List集合，而<code>retainAll</code>返回是Bollean类型那就说明retainAll方法是对原有集合进行处理再返回原有集合,会改变原有集合中的内容。</p>
<p><code>个人观点</code>：1、从性能角度来考虑的话,List自带会高点,因为它不用再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使用就不适合用retainAll。</p>
<p><code>注意</code>: Arrays.asList将数组转集合不能进行add和remove操作。</p>
<p><code>原因</code>：调用Arrays.asList()生产的List的add、remove方法时报异常，这是由<strong>Arrays.asList() 返回的市Arrays的内部类ArrayList， 而不是java.util.ArrayList</strong>。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重新了这些方法而Arrays的内部类ArrayList没有重新，所以会抛出异常。</p>
<p>所以正确做法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">arrList.add(<span class="string">"6"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="JDK1-8-stream-新特性"><a href="#JDK1-8-stream-新特性" class="headerlink" title="JDK1.8 stream 新特性"></a>JDK1.8 stream 新特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    List&lt;String&gt; intersection = listA.stream().filter(item -&gt; listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(intersection);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 差集 (list1 - list2)</span></span><br><span class="line">    List&lt;String&gt; reduceList = listA.stream().filter(item -&gt; !listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(reduceList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并集 （新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。</span></span><br><span class="line">    List&lt;String&gt; listAll = listA.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = listB.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(listAll);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重并集 </span></span><br><span class="line">    List&lt;String&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    list.addAll(listB);</span><br><span class="line">    List&lt;String&gt; listAllDistinct = list.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(listAllDistinct);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>总结</code> ： 这三种我还是<code>最喜欢第一种方式</code>，因为第二种还需要确定该集合是否被多次调用。第三种可读性不高。</p>
<h2 id="对象集合交、并、差处理"><a href="#对象集合交、并、差处理" class="headerlink" title="对象集合交、并、差处理"></a>对象集合交、并、差处理</h2><p>因为对象的equels比较是比较两个对象的内存地址，所以除非是同一对象，否则equel返回永远是false。</p>
<p>但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法。</p>
<p><code>说明</code> :String为什么可以使用equels方法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode方法，比较的是值。</p>
<h3 id="Person对象"><a href="#Person对象" class="headerlink" title="Person对象"></a>Person对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么重写equals方法一定要重写hashCode方法下面也会讲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = name + age;</span><br><span class="line">        <span class="keyword">return</span> result.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法 根据name和age都相同那么对象就默认相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Person u = (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里根据name和age都相同那么就默认相同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; personList = Lists.newArrayList();</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    personList.add(person1);</span><br><span class="line">    personList.add(person2);</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; person1List = Lists.newArrayList();</span><br><span class="line">    Person person3 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    Person person4 = <span class="keyword">new</span> Person(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    person1List.add(person3);</span><br><span class="line">    person1List.add(person4);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.subtract(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.union(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='中中', age=4&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.intersection(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='中中', age=4&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、交集的补集（析取）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.disjunction(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它两种方式就不在测了，因为都一样。</p>
<h2 id="为什么重写equels方法一定要重写hashCode方法"><a href="#为什么重写equels方法一定要重写hashCode方法" class="headerlink" title="为什么重写equels方法一定要重写hashCode方法"></a>为什么重写equels方法一定要重写hashCode方法</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>其实上面的Person类我可以只重写equels方法而不写hashCode方法,一样能达到上面的效果。但为什么还是建议写上呢？官方的说法是:<code>对象的equals方法被重写，那么对象的hashCode()也尽量重写</code>。</p>
<p>重写equals()方法就必须重写hashCode()方法的原因，从源头Object类讲起就更好理解了。</p>
<p>先来看Object关于hashCode()和equals()的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line">      </span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">         return (this == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>光从代码中我们可以知道，<code>hashCode()方法是一个本地native方法</code>，返回的是对象引用中存储的对象的内存地址。而equals方法是利用==来比较的也是对象的内存地址。从上边我们可以看出，hashCode方法和equals方法是一致的。还有最关键的一点，我们来看Object类中关于hashCode()方法的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。    </span><br><span class="line">2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。    </span><br><span class="line">3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。</span><br><span class="line">   但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</span><br></pre></td></tr></table></figure>
<p><code>整理</code> : hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode可以不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。</p>
<p>假设两个对象，重写了其equals方法，其相等条件是某属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。</p>
<h3 id="HashSet和Map集合类型"><a href="#HashSet和Map集合类型" class="headerlink" title="HashSet和Map集合类型"></a>HashSet和Map集合类型</h3><p>重写equals()方法就必须重写hashCode()方法主要是针对HashSet和Map集合类型,而对于List集合倒没什么影响。</p>
<p><code>原因</code>： 在向HashSet集合中存入一个元素时，HashSet会调用该对象（存入对象）的hashCode()方法来得到该对象的hashCode()值，然后<code>根据该hashCode值决定该对象在HashSet中存储的位置</code>。简单的说：<code>HashSet集合判断两个元素相等的标准是：两个对象通过equals()方法比较相等，并且两个对象的HashCode()方法返回值也相等</code>。如果两个元素通过equals()方法比较返回true，但是它们的hashCode()方法返回值不同，HashSet会把它们存储在不同的位置，依然可以添加成功。</p>
<p><code>这就是问题所在</code>：就是如果你只重写equals()方法，而不重写hashCode(),如果equals()为true,而它们的hashCode()方法返回值肯定不一样，因为它们都不是同一对象所以内存地址肯定不一样，所以它还是添加成功了，那么其实你写的equals()方法根本没啥软用。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>1、People类</strong></p>
<p>重写equals方法,但并没有hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        People u = (People) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;People&gt; hashSet = Sets.newHashSet();</span><br><span class="line">    People people1 = <span class="keyword">new</span> People(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    People people2 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people3 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people4 = <span class="keyword">new</span> People(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    hashSet.add(people1);</span><br><span class="line">    hashSet.add(people2);</span><br><span class="line">    hashSet.add(people3);</span><br><span class="line">    hashSet.add(people4);</span><br><span class="line"></span><br><span class="line">    System.out.println(hashSet);</span><br><span class="line">    <span class="comment">//输出:[People&#123;name='小小', age=3&#125;, People&#123;name='中中', age=4&#125;, People&#123;name='大大', age=5&#125;, People&#123;name='中中', age=4&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显,我重写了equals方法,那么people2和people3的equals应该相同，所以不能放入HashSet,但它们的hashCode()方法返回不同，所以导致同样能放入HashSet。</p>
<p><code>重点</code>：对于Set集合必须要同时重写这两个方法，要不然Set的特性就被破坏了。</p>
<p>转载自：<a href="https://www.cnblogs.com/qdhxhz/p/10787130.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/10787130.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>authorized_keys不生效解决办法</title>
    <url>/2021/hexo/authorized-keys%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>​        在Linux中部署git服务器时，window客户端 执行ssh-keygen在目录<code>C:\Users\zhangyf \.ssh</code> 生成 id_rsa和id_rsa.pub。</p>
<p>将id_rsa.pub内容上传到Linux的/home/git/.ssh/authorized_keys 时， <code>service sshd restart</code> 命令重启了SSH服务， </p>
<p>在windows 打开cmd执行ssh git@VPSIP  -p 28094 需要输入密码。</p>
<p>解决方案：</p>
<p>linux 目录结构为 /home/git/.ssh/authorized_keys  用户和组都为git</p>
<p>/home/git目录必须是 755权限 即drwxr-xr-x  </p>
<p>/home/git/.ssh目录必须是700权限(也就是drwx——)</p>
<p>/home/git/.ssh/authorized_keys 文件必须是600权限(也就是-rw——-)或者644</p>
<p>缺一不可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo本地图片不显示</title>
    <url>/2020/hexo/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li><p>修改文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
</li>
<li><p>修改之后，再使用<code>hexo new post &quot;hexo本地图片不显示&quot;</code>时，目录的样子是</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">├── 01.jpg</span><br><span class="line">├── 02.jpg</span><br><span class="line">└── 03.jpg</span><br><span class="line">...</span><br><span class="line">hexo本地图片不显示.md</span><br></pre></td></tr></table></figure>
<h3 id="安装插件hexo-asset-image"><a href="#安装插件hexo-asset-image" class="headerlink" title="安装插件hexo-asset-image"></a>安装插件hexo-asset-image</h3><ul>
<li>GitHub地址 <a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a></li>
<li>npm安装 (需要提前安装Node.js)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p><img src="/2020/hexo/hexo本地图片不显示/1.png" alt="图片描述"><br><strong>注意</strong> 不要使用<code>npm install hexo-asset-image --save</code>这个命令安装,<strong>版本号不对</strong><br><img src="/2020/hexo/hexo本地图片不显示/2.png" alt="图片描述"></p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h4 id="0-0-5版本"><a href="#0-0-5版本" class="headerlink" title="0.0.5版本"></a>0.0.5版本</h4><p><img src="/2020/hexo/hexo本地图片不显示/3.png" alt="图片描述"></p>
<h4 id="1-0-0版本"><a href="#1-0-0版本" class="headerlink" title="1.0.0版本"></a>1.0.0版本</h4><p><img src="/2020/hexo/hexo本地图片不显示/4.png" alt="图片描述"></p>
<h3 id="在md中书写格式（相对路径）"><a href="#在md中书写格式（相对路径）" class="headerlink" title="在md中书写格式（相对路径）"></a>在md中书写格式（相对路径）</h3><p>在md使用如下形式引用图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 这里要使用<code>&quot;/&quot;</code></p>
<h3 id="md文件名称和图片存放文件夹名称不同时"><a href="#md文件名称和图片存放文件夹名称不同时" class="headerlink" title="md文件名称和图片存放文件夹名称不同时"></a>md文件名称和图片存放文件夹名称不同时</h3><p><strong>注意</strong> <code>重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</code></p>
<p><img src="/2020/hexo/hexo本地图片不显示/5.png" alt="图片描述"></p>
<ul>
<li><code>文件和文件夹以url中的名称保持一致</code></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>检查<code>_config.yml</code> 文件的<code>post_asset_folder:</code>选项是否为<code>true</code></li>
<li>检查创建文件之后的目录结构</li>
<li>检查<code>hexo-asset-image</code>插件的版本</li>
<li>检查路径引用图片的路径使用<code>/</code></li>
<li>检查md文件的文件名称和图片存放文件夹名称是否相同</li>
</ul>
<p>转载于：<a href="https://blog.csdn.net/Strong997/article/details/97767929" target="_blank" rel="noopener">https://blog.csdn.net/Strong997/article/details/97767929</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程</title>
    <url>/2021/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%9B%E5%BB%BAThread%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ThreadDemo threadDemo=<span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line">        threadDemo.start();<span class="comment">//调用Thread类的start方法启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ThreadDemo ThreadDemo=<span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="comment">//调用Thread的构造方法public Thread(Runnable target)创建Thread类，将Runable实现类传入，</span></span><br><span class="line">        <span class="comment">//然后调用Thread类的start方法启动线程，Runable的实现类是没有start方法的。</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ThreadDemo).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ThreadDemo threadDemo=<span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1=ser.submit(threadDemo);</span><br><span class="line">        <span class="comment">//获取结构</span></span><br><span class="line">        <span class="keyword">boolean</span> rs1=r1.get();</span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程测试"><a href="#多线程测试" class="headerlink" title="多线程测试"></a>多线程测试</h3><p>新建100个线程进行进行模拟多用户操作，获取单号。</p>
<h4 id="使用lambda创建线程测试"><a href="#使用lambda创建线程测试" class="headerlink" title="使用lambda创建线程测试"></a>使用lambda创建线程测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">HdGetBillNo hdGetBillNo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBillNoService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String billNo=	hdGetBillNo.nextUserBillNo(<span class="string">"MATIN"</span>,<span class="string">"00"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">" "</span>+HdDateUtils.dateToStr(<span class="keyword">new</span> Date(),<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) +<span class="string">"线程获取单号为"</span>+billNo);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用线程类创建线程测试"><a href="#使用线程类创建线程测试" class="headerlink" title="使用线程类创建线程测试"></a>使用线程类创建线程测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">HdGetBillNo hdGetBillNo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String billNo=	hdGetBillNo.nextUserBillNo(<span class="string">"MATIN"</span>,<span class="string">"00"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+ <span class="string">" "</span>+HdDateUtils.dateToStr(<span class="keyword">new</span> Date(),<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) +<span class="string">"线程获取单号为"</span>+billNo);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBillNoService</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程线程</title>
    <url>/2021/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><p>java能真正开启一个线程吗？不能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用本地方法，底层为C++，操作硬件开启一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h3><p>并发：多个线程操作一个资源，CPU一个核心，模拟多核心。</p>
<p>并行：多个线程同时执行，CPU多核心。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取计算机CPU核心数</span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure></p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//新生</span><br><span class="line">NEW,</span><br><span class="line"></span><br><span class="line">//运行</span><br><span class="line">RUNNABLE,</span><br><span class="line"></span><br><span class="line">//阻塞</span><br><span class="line">BLOCKED,</span><br><span class="line"></span><br><span class="line">//等待，死死的等</span><br><span class="line">WAITING,</span><br><span class="line"></span><br><span class="line">//超时等待</span><br><span class="line">TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">//终止</span><br><span class="line">TERMINATED;</span><br></pre></td></tr></table></figure>
<h3 id="wait-sleep"><a href="#wait-sleep" class="headerlink" title="wait/sleep"></a>wait/sleep</h3><p><strong>1.来自不同的类</strong></p>
<p>wait =&gt; Object   </p>
<p>sleep =&gt; Thread</p>
<p><strong>2.关于所得释放</strong></p>
<p>wait会释放锁</p>
<p>sleep睡觉，不会释放锁</p>
<p><strong>3.使用范围是不同的</strong></p>
<p>wait必须在同步代码块中</p>
<p>sleep可以在任何地方</p>
<p><strong>4.是否需要捕获异常</strong></p>
<p>wait不需要捕获异常</p>
<p>sleep必须捕获异常</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/2021/java/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p>
<p>什么是泛型？为什么要使用泛型？</p>
<blockquote>
<p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<h1 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h1><p>一个被举了无数次的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，程序的运行结果会以崩溃结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String1</span><br></pre></td></tr></table></figure>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错123</span></span><br></pre></td></tr></table></figure>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>泛型只在编译阶段有效。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<code>D/泛型测试: 类型相同</code>。</p>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个最普通的泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericString.getKey());<span class="number">12345678</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is <span class="number">123456</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is key_vlaue12</span><br></pre></td></tr></table></figure>
<p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<p>看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());</span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is false1234</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li><ol>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
</ol>
</li>
<li><ol>
<li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&gt;      &#125; <span class="number">12</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p>
<blockquote>
<p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p>
</blockquote>
<p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h3><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h3><p>再看一个泛型方法和可变参数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p>
<p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p>
<blockquote>
<p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法</p>
</blockquote>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？无界通配符</h3><p>先从一个小例子看起，我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>但是老板的想法确实这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="comment">// 不会报错</span></span><br><span class="line">    countLegs( dogs );</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 countLegs1 时，就会报错。所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 <code>&lt;?&gt;</code>），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上界：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2)&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    //.....</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</span><br><span class="line">    for (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">    new Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line">// Dog 是 Animal 的子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//指定集合元素只能是T类型</span><br><span class="line">List&lt;T&gt; list =new ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">//集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</span><br><span class="line">List&lt;?&gt; list =new ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line">// 不可以</span><br><span class="line">?car = operate();</span><br></pre></td></tr></table></figure>
<p>简单总结下：</p>
<blockquote>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
</blockquote>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过 T 来 确保 泛型参数的一致性</span><br><span class="line">public &lt;T extends Number&gt; void</span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure>
<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure>
<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiLimit</span> <span class="keyword">implements</span> <span class="title">MultiLimitInterfaceA</span>,<span class="title">MultiLimitInterfaceB</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 使用 &amp; 符号设定多重边界</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends MultiLimitInterfaceA &amp; MultiLimitInterfaceB&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MultiLimitInterfaceA</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MulitLimitInterfaceB</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>
<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>
<h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt; T &gt; 和 Class&lt; ? &gt; 区别"></a>Class&lt; T &gt; 和 Class&lt; ? &gt; 区别</h2><p>前面介绍了 ？和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？</p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射的方式生成  multiLimit </span><br><span class="line">// 对象，这里比较明显的是，我们需要使用强制类型转换</span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Ttest3&#123;</span><br><span class="line">	public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws Exception&#123;</span><br><span class="line">		return clazz.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		A a = createInstance(A.class);</span><br><span class="line">		B b = createInstance(B.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line">class B&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">public Class&lt;?&gt; clazz;</span><br><span class="line">// 不可以，因为 T 需要指定类型</span><br><span class="line">public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个<code>Class&lt;?&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3&lt;T&gt; &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    // 不会报错</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2020/java/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="对称性加密算法"><a href="#对称性加密算法" class="headerlink" title="对称性加密算法"></a>对称性加密算法</h2><p><img src="/2020/java/加密算法/1.jpg" alt="加密流程图"></p>
<p>对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。</p>
<p>对称加密算法的优点是：算法公开、计算量小、加密速度快、加密效率高。用途：对称加密算法用来对敏感数据等信息进行加密</p>
<p>对称加密算法的缺点是：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p><strong>DES</strong>：全称为Data Encryption Standard数据加密标准，速度较快，适用于加密大量数据的场合。</p>
<p><strong>3DES</strong>（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>
<p><strong>AES</strong>：全称为Advanced Encryption Standard高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES 适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。</p>
<h2 id="非对称性算法"><a href="#非对称性算法" class="headerlink" title="非对称性算法"></a>非对称性算法</h2><p><img src="/2020/java/加密算法/2.jpg" alt="img"></p>
<p><strong>既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</strong></p>
<p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密与有点是：安全性更好；对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p>
<p>非对称加密的缺点是：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p><strong>RSA</strong>：全称为Digital Signature Algorithm，是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p>
<p><strong>DSA</strong>：全称为Digital Encryption Standard，是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到。</p>
<p><strong>ECC</strong>：全称为Elliptic Curves Cryptography,，也叫椭圆加密算法，是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p>
<blockquote>
<p>ECC和RSA相比，在许多方面都有对绝对的优势，主要体现在以下方面：</p>
<ol>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。</li>
<li>计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。</li>
<li>存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。</li>
</ol>
</blockquote>
<h2 id="散列算法（签名算法）"><a href="#散列算法（签名算法）" class="headerlink" title="散列算法（签名算法）"></a>散列算法（签名算法）</h2><p><img src="/2020/java/加密算法/sl.png" alt="img"></p>
<p>散列算法，又称哈希函数，是一种单向加密算法。在信息安全技术中，经常需要验证消息的完整性，散列(Hash)函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的”散列”或”消息摘要”(Message digest)。散列算法不算加密算法，因为其结果是不可逆的，既然是不可逆的，那么当然不是用来加密的，而是签名。</p>
<p>用途：主要用于验证，防止信息被修。具体用途如：文件校验、数字签名、鉴权协议</p>
<p><strong>MD5</strong>：MD5是一种不可逆的加密算法，目前是最牢靠的加密算法之一，尚没有能够逆运算的程序被开发出来，它对应任何字符串都可以加密成一段唯一的固定长度的代码。</p>
<p><strong>SHA1</strong>：全称为Secure Hash Algorithm，即安全哈希算法，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。有SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法，其中SHA-1已经不安全。而SHA-1基于MD5，MD5又基于MD4。</p>
<p><strong>HMAC</strong>：全称为Hash Message Authentication Code，即散列消息鉴别码，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。一般的，消息鉴别码用于验证传输于两个共 同享有一个密钥的单位之间的消息。HMAC 可以与任何迭代散列函数捆绑使用。MD5 和 SHA-1 就是这种散列函数。HMAC 还可以使用一个用于计算和确认消息鉴别值的密钥。</p>
<p><strong>建议：</strong> AES采用128为即可，RSA建议采用1024位的数字，ECC建议采用160位。RSA加密字符长度有限制，一般采用AES+RSA方式组合使用。</p>
<h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>Base64 加密算法是最常见的用于传递 8bit <strong>字节码的编码方式之一</strong></p>
<p>计算机任何数据都是按 ascii 码存储的，而 ascii 码的 128～256 之间的值是不可见字符，由于不同设备对字符处理方式有不同，可能会导致错误，不利于传输，所以把数据作为一个 Base64 编码，统统变成可见字符，出错可能性就降低了</p>
<p>Base64 是取 6 个比特为一组，计算它的 ascii 值，得到一个可见字符，在解码时按 6 个比特进行解码并读取，如 01010101101 等比特流，取 010110 计算它的 ascii 码，转化为可见字符，因此 Base64 <strong>还具备了数据压缩能力</strong></p>
<p>其实不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种可逆的编码方式。编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(26 + 26 + 10 + 1 + 1 = 64，其实是65个字符，“=”是填充字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节(3<em>8 = 4</em>6 = 24)，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。原文的字节最后不够3个的地方用0来补足，转换时Base64编码用=号来代替。这就是为什么有些Base64编码会以一个或两个等号结束的原因，中间是不可能出现等号的，但等号最多只有两个。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。)<br>Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”， 对应GB2312格式的Base64编码是”yc/N+A==”。<br>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。<br>为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“<em>”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。<br>另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。<br>此外还有一些变种，它们将“+/”改为“</em>-”或“.<em>”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“</em>:”（用于XML中的Name）。</p>
<h2 id="AES-RSA组合应用"><a href="#AES-RSA组合应用" class="headerlink" title="AES+RSA组合应用"></a>AES+RSA组合应用</h2><p>RSA与AES加密算法所产生的密钥数不一样，它们是如何进行加密的呢？</p>
<p>接收方生成RSA密钥对，将其中的RSA公钥传递给发送方(接收方与发送方建立连接是需要认证的，SSL/TLS协议可以确保RSA公钥的安全完整)，然后用RSA公钥对AES密钥进行加密，加密后的结果传递给接收方，接收方用RSA私钥解密后，得到AES密钥，最后使用AES密钥解密，从而达到安全互通数据的目的。(如下图所示)</p>
<p><img src="/2020/java/加密算法/3.png" alt="3"></p>
<p><img src="/2020/java/加密算法/4.jpg" alt="img"></p>
<h2 id="项目应用总结"><a href="#项目应用总结" class="headerlink" title="项目应用总结"></a>项目应用总结</h2><ol>
<li>加密算法是可逆的，用来对敏感数据进行保护。散列算法(签名算法、哈希算法)是不可逆的，主要用于身份验证。</li>
<li>对称加密算法使用同一个密匙加密和解密，速度快，适合给大量数据加密。对称加密客户端和服务端使用同一个密匙，存在被抓包破解的风险。</li>
<li>非对称加密算法使用公钥加密，私钥解密，私钥签名，公钥验签。安全性比对称加密高，但速度较慢。非对称加密使用两个密匙，服务端和客户端密匙不一样，私钥放在服务端，黑客一般是拿不到的，安全性高。</li>
<li>Base64不是安全领域下的加解密算法，只是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，特别适合在http，mime协议下的网络快速传输数据。UTF-8和GBK中文的Base64编码结果是不同的。采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到，但这种方式很初级，很简单。Base64可以对图片文件进行编码传输。</li>
<li>大量数据加密建议采用对称加密算法，提高加解密速度；小量的机密数据，可以采用非对称加密算法。在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</li>
<li>MD5标准密钥长度128位（128位是指二进制位。二进制太长，所以一般都改写成16进制，每一位16进制数可以代替4位二进制数，所以128位二进制数写成16进制就变成了128/4=32位。16位加密就是从32位MD5散列中把中间16位提取出来）；sha1标准密钥长度160位(比MD5摘要长32位)，Base64转换后的字符串理论上将要比原来的长1/3。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES 加密方法，是对称的密码算法(加密与解密的密钥一致)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得一个 密钥长度为 128 位的 AES 密钥，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回经 BASE64 处理之后的密钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStrKeyAES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是 128、192、256、越大越安全</span></span><br><span class="line">        keyGen.init(<span class="number">128</span>, secureRandom);</span><br><span class="line">        SecretKey secretKey = keyGen.generateKey();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(secretKey.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将使用 Base64 加密后的字符串类型的 secretKey 转为 SecretKey</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">strKey2SecretKey</span><span class="params">(String strKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteArr = base64_str2ByteArr(strKey);</span><br><span class="line">        SecretKeySpec secretKey = <span class="keyword">new</span> SecretKeySpec(byteArr, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 加密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的密文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 加密 返回Base64编码的字符串密文</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 解密 传入Base64编码的字符串密文，返回解密后的字符串</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] messageByteArr = AESUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(messageByteArr, aesKey);</span><br><span class="line">        String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> descyptAes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待解密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 解密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的明文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA 是非对称的密码算法，密钥分公钥和私钥，公钥用来加密，私钥用于解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">RSAUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对：密钥对中包含公钥和私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含 RSA 公钥与私钥的 keyPair</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是1024、2048 初始化一个密钥对</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">2048</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥 (并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的公钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥(并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的私钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成 PublicKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PublicKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(pubStr);</span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey publicKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成 PrivateKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PrivateKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(priStr);</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);</span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 加密所需的公钥对象 PublicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrypt(<span class="keyword">byte</span>[] content, PublicKey publicKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密并返回Base64编码的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String publicKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">        <span class="keyword">return</span> encryptMsgBase64Str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content    待解密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 解密需要的私钥对象 PrivateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] privateDecrypt(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密,返回字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String privateKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptMsgByteArr = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//用私钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgByteArr, privateKey);</span><br><span class="line">        String decryptmsgStr = <span class="keyword">new</span> String(decryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> decryptmsgStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key = AESUtil.getStrKeyAES();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String sourceFilePath = <span class="string">"E:\\打印\\JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D:\\1583915786661_html_2f4d5dc.png";</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// String destFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        FileEncryptUtil.encryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sourceFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">      <span class="comment">//  String destFilePath = "E://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"E://test//JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String destFilePath="E:\\11.png";</span></span><br><span class="line">        FileEncryptUtil.decryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            System.out.println(<span class="string">"明文数据为："</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">            String aesKeyBase64Str = AESUtil.getStrKeyAES();</span><br><span class="line">            System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptAESBase64Str = AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">            System.out.println(<span class="string">"加密并Base64编码的结果："</span> + encryptAESBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############   网络上传输的内容有Base64编码后的秘钥 和 Base64编码加密后的内容    #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKeyFromNet = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArrFromNet = AESUtil.base64_str2ByteArr(encryptAESBase64Str);</span><br><span class="line">            <span class="comment">//解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(encryptAESByteArrFromNet, aesKeyFromNet);</span><br><span class="line">            String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + descyptAes);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(descyptAes)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=AESUtil.encrypt(message,aesKeyBase64Str);</span><br><span class="line">            System.out.println(miwen);</span><br><span class="line">            String minwen=AESUtil.decrypt(miwen,aesKeyBase64Str);</span><br><span class="line">            System.out.println(minwen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            encryptFile();</span><br><span class="line">            decryptFile();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.err.println(<span class="string">"耗时："</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">            <span class="comment">//生成RSA公钥和私钥，并Base64编码</span></span><br><span class="line">            KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">            String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">            String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">            System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">            PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">            <span class="comment">//用公钥加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">            System.out.println(<span class="string">"公钥加密并Base64编码的结果："</span> + encryptMsgBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############    网络上传输的内容有Base64编码后的公钥 和 Base64编码后的公钥加密的内容     #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">            PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptMsgFromNet = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">            <span class="comment">//用私钥解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] privateDecryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgFromNet, privateKey);</span><br><span class="line">            String privateDecrypmsgtStr = <span class="keyword">new</span> String(privateDecryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + privateDecrypmsgtStr);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(privateDecrypmsgtStr)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=RSAUtil.encrypt(message,publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"密文: "</span> + miwen);</span><br><span class="line">            String mingwen=RSAUtil.decrypt(miwen,privateKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"明文: "</span> + mingwen);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESAndRSATest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试RSA与AES的结合。</span></span><br><span class="line">    <span class="comment">//客户端：AES秘钥加密明文得到密文，然后用从服务器获取的RSA公钥加密AES秘钥，网络传输密文和RSA加密后的AES秘钥到服务器</span></span><br><span class="line">    <span class="comment">//服务端：用RSA私钥解密AES秘钥，解密后的AES秘钥再用来解密密文，得到明文。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKey = RSAUtil.publicEncrypt(aesKeyStr.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容Base64编码</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.base64_byteArr2Str(publicEncryptAESKey);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyStr);</span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.base64_byteArr2Str(encryptAES);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############   网络上传输的内容有Base64编码后的公钥加密AES秘钥的结果 和 Base64编码后的AES秘钥加密实际内容的结果   #################</span></span><br><span class="line">        <span class="comment">//##############   即publicEncryptAESKeyStr和encryptAESStr  ###################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKeyFromNet = RSAUtil.base64_str2ByteArr(publicEncryptAESKeyStr);</span><br><span class="line">        <span class="comment">//用私钥解密,得到aesKey</span></span><br><span class="line">        <span class="keyword">byte</span>[] aesKeyStrBytes = RSAUtil.privateDecrypt(publicEncryptAESKeyFromNet, privateKey);</span><br><span class="line">        <span class="comment">//解密后的aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = <span class="keyword">new</span> String(aesKeyStrBytes,<span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey2 = AESUtil.strKey2SecretKey(aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES2 = AESUtil.base64_str2ByteArr(encryptAESStr);</span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAES = AESUtil.decryptAES(encryptAES2, aesKey2);</span><br><span class="line">        String decryptAESStr=<span class="keyword">new</span> String(decryptAES,<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装方法测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.encrypt(aesKeyStr,publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.encrypt(message, aesKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//用RSA私钥解密,得到aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = RSAUtil.decrypt(publicEncryptAESKeyStr, privateKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        String decryptAESStr = AESUtil.decrypt(encryptAESStr, aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"AES解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//test();</span></span><br><span class="line">            testSimple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>DNF-包管理器</title>
    <url>/2020/Linux/%E9%9B%86%E9%94%A6/DNF-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DNF(Dandified Yum)是新一代的RPM软件包管理器。<br>DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。</p>
<h3 id="安装DNF"><a href="#安装DNF" class="headerlink" title="安装DNF"></a>安装DNF</h3><p>DNF并未默认安装在RHEL或CentOS7系统中，但可以在使用YUM的同时使用DNF。</p>
<ol>
<li>安装epel-release依赖：<code>yum install epel-release</code> 或者 <code>yum install epel-release -y</code></li>
<li>安装DNF包：<code>yum install dnf</code> 或者 <code>yum install dnf -y</code></li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/dnf/dnf.conf</p>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>Add the following settings in [main] section of /etc/dnf/dnf.conf, and save the file.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy=http://&lt;ip address&gt;:&lt;port&gt;</span><br><span class="line">proxy_username=&lt;username&gt;</span><br><span class="line">proxy_password=&lt;password&gt;</span><br></pre></td></tr></table></figure>
<h3 id="DNF命令"><a href="#DNF命令" class="headerlink" title="DNF命令"></a>DNF命令</h3><p>与YUM基本保持一致，少数用法有区别。<br><a href="http://man.linuxde.net/dnf" target="_blank" rel="noopener">常用dnf命令</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##### 版本</span></span><br><span class="line">dnf –version  <span class="comment"># 查看DNF包管理器版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 帮助</span></span><br><span class="line">dnf <span class="built_in">help</span>  <span class="comment"># 查看所有的DNF命令及其用途</span></span><br><span class="line">dnf <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;  <span class="comment"># 获取命令的使用帮助</span></span><br><span class="line">dnf <span class="built_in">history</span>  <span class="comment"># 查看 DNF 命令的执行历史</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 信息查看</span></span><br><span class="line">dnf repolist  <span class="comment"># 查看系统中可用的DNF软件库</span></span><br><span class="line">dnf search &lt;package&gt;  <span class="comment"># 搜索软件库中的RPM包</span></span><br><span class="line"></span><br><span class="line">dnf list installed  <span class="comment"># 列出所有安装的RPM包</span></span><br><span class="line">dnf list available  <span class="comment"># 列出所有可安装的RPM包</span></span><br><span class="line">dnf info &lt;package&gt;  <span class="comment"># 查看软件包详情</span></span><br><span class="line"></span><br><span class="line">dnf provides &lt;file&gt;  <span class="comment"># 查找某一文件的提供者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 软件包操作</span></span><br><span class="line">dnf install &lt;package&gt;  <span class="comment"># 安装软件包及其所需的所有依赖</span></span><br><span class="line">dnf update &lt;package&gt;  <span class="comment"># 升级软件包</span></span><br><span class="line">dnf remove &lt;package&gt;  <span class="comment"># 删除软件包</span></span><br><span class="line">dnf reinstall &lt;package&gt;  <span class="comment"># 重新安装特定软件包</span></span><br><span class="line">dnf distro-sync  <span class="comment"># 更新软件包到最新的稳定发行版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 系统软件包</span></span><br><span class="line">dnf check-update  <span class="comment"># 检查系统所有软件包的更新</span></span><br><span class="line">dnf update  <span class="comment"># 升级所有系统软件包</span></span><br><span class="line">dnf clean all  <span class="comment"># 删除缓存的无用软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 组</span></span><br><span class="line">dnf grouplist</span><br><span class="line">dnf groupinstall <span class="string">'xxx'</span></span><br><span class="line">dnf groupupdate <span class="string">'xxx'</span></span><br><span class="line">dnf groupremove</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>集锦</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>DNF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux打印</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/Linux%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<p>打印包括：</p>
<p>  打印作业</p>
<p>  打印队列</p>
<p>  打印服务  常见打印服务有CUPS和LPRng，现在CUPS（Common UNIX Printing System）是主流，常见的打印机能识别的格式为Postscript 及 Ghostscript。</p>
<p>CUPS 支持的常见的打印机联机分享方式：</p>
<p>  socket</p>
<blockquote>
<p>数据透过 internet socket(端口口)来传送，一般为 port 9100 或 35。如果想要进行数据的传输</p>
<p>与打印，可以透过在浏觅器上面输入： socket://host-printer:9100/ 来进行。不过，这种模式不常用就是了。</p>
</blockquote>
<p>  LPD (Line Pritner Daemon)</p>
<blockquote>
<p>LPD 是较早之前的打印服务，LPRng 就是使用这种方式的联机啦！ LPD 主要是</p>
<p>利用串行端口来达成打印的需求，打印机名称就是 LPT1/LPT2… 等等。 目前还是可以在比较早期的 Linux distributions 看到这种打印方式。</p>
</blockquote>
<p>  IPP (Internet Printing Protocol)</p>
<blockquote>
<p>这是目前比较流行的打印机打印协议， CUPS预设也是支持这种协议啊！当启动 IPP </p>
<p>时，打印机会启动 port 631 ，打印的数据就是透过这个 port 来进行传送的。另外，如果你的</p>
<p>打印机或者 Linux 主机启动了 ipp 之后， 嘿嘿！你可以直接使用浏觅器，输入：</p>
<p>ipp://printer_IP/printername，或者是： http:/printer_IP:631 就能够直接在线处理打印机的设定。</p>
</blockquote>
<p>  SMB (Server Message Block)</p>
<p>​      这家伙就是网络上的芳邻啦！协议使用的是： smb://user:password@host/printer 。</p>
<p> /etc/cups/printers.conf：打印机的设定值，都写在这个档案中；（设定打印机地址等信息） /etc/cups/cupsd.conf：CUPS 的主要配置文件，包括做为服务器之用途的设定。 /etc/cups/ppd/*.ppd：就是各个打印机的驱动程序 (PPD 配置文件)；</p>
<p>>/etc/init.d/cups restart  –启动CUPS服务</p>
<p>>netstat -tlunp | grep 631  –查询是否启动CUPS服务</p>
<h3 id="lpadmin-打印机建立与删除"><a href="#lpadmin-打印机建立与删除" class="headerlink" title="lpadmin 打印机建立与删除"></a><strong>lpadmin 打印机建立与删除</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/853a8341-07ab-4cfe-ac67-b78666530f05.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/1f2d6143-fe7b-439f-b13f-ebc223048d1f.png" alt="img"></p>
<h3 id="lpstatus-查看打印机状态"><a href="#lpstatus-查看打印机状态" class="headerlink" title="lpstatus 查看打印机状态"></a><strong>lpstatus 查看打印机状态</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/12408597-c8d8-4b31-8ac7-b9dc7716465b.png" alt="img"></p>
<h3 id="lp和lpr打印"><a href="#lp和lpr打印" class="headerlink" title="lp和lpr打印"></a><strong>lp和lpr打印</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/b16e1f60-eee6-4671-a225-9bf36857e995.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/1c3ae070-8125-4859-bc66-b59bf829444d.png" alt="img"></p>
<h3 id="打印作业的观察-lpq"><a href="#打印作业的观察-lpq" class="headerlink" title="打印作业的观察 (lpq)"></a><strong>打印作业的观察 (lpq)</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/35ac25c0-0f5f-4d6f-a030-46aa2eefaecd.png" alt="img"></p>
<h3 id="打印作业的删除-lprm"><a href="#打印作业的删除-lprm" class="headerlink" title="打印作业的删除 (lprm)"></a><strong>打印作业的删除 (lprm)</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/2dee6621-92a0-4aba-93c0-769df5ebf984.png" alt="img"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>BASH和SHELL编程</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/BASH%E5%92%8CSHELL%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>查询/etc/shells 获取本系统支持的shell：</p>
<p>/bin/sh  ——&gt;/bin/bash（Linux预设的shell）</p>
<p>/bin/csh ——&gt;/bin/tcsh（整合C Shell ，提供更多的功能）</p>
<p>/bin/ksh ——&gt;/bin/zsh（基于 ksh发展出来的，功能更强大的 shell）</p>
<p><strong>type</strong></p>
<p>type [-ta] 指令名称  （查询指令是外部指令还是内建在bash中的指令，只查询指令，找不到不显示，<strong>相当于which查询</strong>）</p>
<p>   -t  显示指令类别，file外部指令 alias 别名 builtin 内建指令</p>
<p>   -a  会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含alias</p>
<p>>type ls</p>
<p>>type  -t  ls</p>
<p>>type  -a ls</p>
<p><strong>env</strong> 显示环境变量内容</p>
<p><strong>set</strong> 显示bash内置变量</p>
<p>PS1（命令提示字符的设定） [root@www ~]#</p>
<p>man bash 查询各个版本的默认设置，set也显示出来。</p>
<p>PS1 的相关说明，以理解底下的一些符号意义。</p>
<blockquote>
<p>o  \d ：可显示出『星期 月 日』的日期格式，如：”Mon Feb 2”</p>
<p>o  \H ：完整的主机名。举例来说，鸟哥的练习机为『<a href="http://www.vbird.tsai』" target="_blank" rel="noopener">www.vbird.tsai』</a></p>
<p>o  \h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略</p>
<p>o  \t ：显示时间，为 24 小时格式的『HH:MM:SS』</p>
<p>o  \T ：显示时间，为 12 小时格式的『HH:MM:SS』</p>
<p>o  \A ：显示时间，为 24 小时格式的『HH:MM』</p>
<p>o  \@ ：显示时间，为 12 小时格式的『am/pm』样式</p>
<p>o  \u ：目前使用者的账号名称，如『root』； </p>
<p>o  \v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示</p>
<p>o  \w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；</p>
<p>o  \W ：利用 basename 凼数取得工作目录名称，所以仅会列出最后一个目录名。</p>
<p>o  # ：下达的的第几个指令。</p>
<p>o  \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～</p>
</blockquote>
<p>PS1=’[\u@\h \W]\$ ‘</p>
<p>PS1=’[\u@\h \w \A ##]\$ ‘</p>
<p> echo $$  显示PID号码</p>
<p> echo $?  显示上个指令的回传值</p>
<p><strong>export</strong> 变量名称（将自定义变量变为环境变量，子程序也可使用，不加变量名称则全部转换）</p>
<p>>read -p “Please keyin your name:” -t 30 named</p>
<p>>declare -i sum=100+300+50  整数</p>
<p>>declare -a arr  数组</p>
<p>>declare -x sum 转为环境变量</p>
<p>>declare -r  sum 转为只读变量</p>
<p>>var[1]=”small min”</p>
<p>>var[2]=”big min”</p>
<p>>echo “${var[1]},${var[2],$var[3]}”</p>
<p><strong>ulimit</strong></p>
<p>ulimit -a         显示全部限制</p>
<p>ulimit -f 10240    用户只能建立的最大文件为10240kb</p>
<p><strong>PATH删除和替换</strong></p>
<p>echo ${path#/*fforever/bin:}  删除/到fforever/bin:符合条件的最短字符</p>
<p>echo ${path##/*:}           删除/到 : 符合条件的最长字符</p>
<p>echo ${path%:*bin}         从后面开始删除 : 到bin符合条件的最短字符</p>
<p>echo ${path%%:*bin}        从后面开始删除 : 到bin符合条件的最长字符</p>
<p>echo ${path/sbin/SBIN}      将两个/之间的sbin替换为SBIN，最短替</p>
<p>echo ${path//sbin/SBIN}     将三个/之间的sbin替换为SBIN，最长替代</p>
<p><strong>变量测试和内容替换</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/7e18cee8-4f63-46d8-b35b-a61f396487c3.png" alt="img"></p>
<p><strong>alias</strong></p>
<p>alias 显示全部别名</p>
<p>alias lm=’ls -al|more’</p>
<p>alias rm=’rm -i’</p>
<p>unalias lm</p>
<p><strong>history</strong></p>
<p>>history [n]</p>
<p>>history [c]  清除</p>
<p>>history [arw]  -a将新增指令加到histfiles中</p>
<p>​              -r将histfiles指令加到history内存中</p>
<p>​              -w将内存中指令写入histfiles中</p>
<p>>!66        执行第66条指令</p>
<p>>!!         执行上一个指令</p>
<p>>!al        执行以al开头的指令</p>
<p><strong>指令运作的顺序可以这样看：</strong></p>
<p>\1.  手动输入以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</p>
<p>\2.  由 alias 找到该指令来执行；</p>
<p>\3.  由 bash 内建的 (builtin) 指令来执行；</p>
<p>\4.  透过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。</p>
<p>/etc/issue /etc/issue.net(网络登录)  切换到tty命令窗口时的提示信息</p>
<p>man issue或man mingetty查询配置变量</p>
<blockquote>
<p>\d 本地端时间的日期；</p>
<p>\l 显示第几个终端机接口；</p>
<p>\m 显示硬件的等级 (i386/i486/i586/i686…)；</p>
<p>\n 显示主机的网络名称；</p>
<p>\o 显示 domain name；</p>
<p>\r 操作系统的版本 (相当亍 uname -r)</p>
<p>\t 显示本地端时间的时间；</p>
<p>\s 操作系统的名称；</p>
<p>\v 操作系统的版本。</p>
</blockquote>
<p><strong>/etc/motd  登陆后的提示信息</strong></p>
<p><strong>login shell 加载配置</strong></p>
<p>1./etc/profile 整体设定</p>
<p>2.~/.bash_profile &gt;~/.bash_login &gt; ~/.profile  有优先级高的，则加载他之后不再加载后面得。</p>
<p><strong>non-login shell加载配置</strong></p>
<p>~/.bashrc</p>
<p>>source ~/.bashrc  &lt;==底下这两个指令是一样的！</p>
<p>> . ~/.bashrc</p>
<p><strong>数据流重导向</strong></p>
<p>\1.  标准输入  (stdin) ：    代码为 0 ，使用 &lt; 或 &lt;&lt;  </p>
<p>\2.  标准输出  (stdout)：   代码为 1 ，使用 &gt; 或 &gt;&gt; </p>
<p>\3.  标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;  </p>
<p>其中一个符号位<strong>覆盖</strong>，两个符号位<strong>累加</strong></p>
<p>>ls -al / &gt; ~/rootfile</p>
<p>>find /home -name .bashrc  &gt;list_right  2&gt;list_error</p>
<p>>find /home -name .bashrc  2&gt; /dev/null  忽略错误信息</p>
<p>>find /home -name .bashrc  &gt; list  2&gt;&amp;1   正确与错误数据都输入到list </p>
<p>>find /home -name .bashrc  &amp;&gt; list       正确与错误数据都输入到list </p>
<p>>cat &gt; catfile &lt; ~/.bashrc  将.bashrc的内容输入到catfile</p>
<p>>cat &gt; catfile &lt;&lt; “eof”     输入catfile，输入eof时结束</p>
<table>
<thead>
<tr>
<th>cmd1 ; cmd2</th>
<th>不考虑指令相关性的连续指令下达</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd1 &amp;&amp; cmd2</td>
<td>1. 若 cmd1 执行完毕且正确执行($?=0)，则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错误 ($?≠0)，则 cmd2 不执行。</td>
</tr>
<tr>
<td>cmd1 \</td>
<td>\</td>
<td>cmd2</td>
<td>1. 若 cmd1 执行完毕且正确执行($?=0)，则 cmd2 不执行。 2. 若 cmd1 执行完毕且为错误 ($?≠0)，则开始执行 cmd2</td>
</tr>
</tbody>
</table>
<p>指令不执行时，前面指令的执行状态传到后面的指令</p>
<p>cmd1 || amd2 &amp;&amp; cmd3</p>
<p>1成功，2不执行，1成功状态传到3,3执行</p>
<p>1失败，2执行，2成功，3执行</p>
<p>1失败，2执行，2失败，3不执行</p>
<p>> ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</p>
<p>cmd1 &amp;&amp; amd2 || cmd3</p>
<p>1成功，2执行，2成功，3不执行</p>
<p>1成功，2执行，2失败，3执行</p>
<p>1失败，2不执行，1失败状态传到3,3执行</p>
<p>> ls /tmp/vbirding &amp;&amp; echo “exist” || echo “not exist”</p>
<p><strong>撷取指令</strong></p>
<p><strong>cut（对一行中的字段进行分割，</strong>cut 在处理多空格相连的数据时，不大准确<strong>）</strong></p>
<p>>echo $PATH | cut -d ‘:’ -f 3，5    将path变量用“：”分割，取得第3段和第5段</p>
<p>>export | cut  -c  12-             取得第12个字符后的字符串</p>
<p><strong>grep(整篇文章中取得带关键词的那一行)</strong></p>
<p>grep [-cinv] ‘搜寻字符串’ filename</p>
<blockquote>
<p>-c ：计算找到 ‘搜寻字符串’ 的次数</p>
<p>-i ：忽略大小写的不同，所以大小写规为相同</p>
<p>-n ：顺便输出行号</p>
<p>-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容得那一行！</p>
<p>-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；</p>
<p>-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；</p>
<p>–color=auto 可将正确的那个撷取数据列出颜色</p>
</blockquote>
<p>>last|grep ‘root’</p>
<p>> last | grep ‘root’ |cut -d ‘ ‘ -f 1</p>
<p>>dmesg | grep -n -A3 -B2 –color=auto ‘eth’</p>
<p><strong>sort  [-fbMnrtuk] [file or stdin]</strong></p>
<p>​     -f  ：忽略大小写的差异，例如 A 不 a 规为编码相同；</p>
<blockquote>
<p>-b  ：忽略最前面的空格符部分；</p>
<p>-M  ：以月份的名字杢排序，例如 JAN, DEC 等等的排序方法；</p>
<p>-n  ：使用『纯数字』进行排序(默认是以文字型态来排序的)； </p>
<p>-r  ：反向排序；</p>
<p>-u  ：就是 uniq ，相同的中，仅出现一行代表；</p>
<p>-t  ：分隔符，预设是用 [tab] 键来分隔；</p>
<p>-k  ：以那个区间 (field) 来进行排序的意思</p>
</blockquote>
<p>>cat /etc/passwd|sort -t ‘ ‘ -k 3 -n</p>
<p><strong>uniq</strong></p>
<blockquote>
<p>-i  ：忽略大小写字符的不同；<br>-c  ：进行计数</p>
</blockquote>
<p>>last | cut -d ‘ ‘ -f 1 | sort | uniq  都有谁登陆</p>
<p>>last | cut -d ‘ ‘ -f 1 | sort | uniq -c 每个人的登陆次数</p>
<p><strong>wc</strong></p>
<blockquote>
<p>-l  ：仅列出行；<br>-w  ：仅列出多少字(英文单字)；<br>-m  ：多少字符；</p>
</blockquote>
<p>>last | grep [a-zA-Z] | grep -v ‘wtmp’ | wc -l</p>
<p><strong>tee ：双向重导向（将数据保存到文件，同时也在屏幕显示）</strong></p>
<p>  -a 累加</p>
<p>>ls -l /home | tee ~/homefile | more</p>
<p><strong>xargs</strong></p>
<p> 找出 /sbin 底下具有特殊权限的档名，并使用 ls -l 列出详细属性</p>
<p>由于ls不支持管线命令所以</p>
<p>find /sbin -perm +7000 | ls -l  不正确</p>
<p>find /sbin -perm +7000 | xargs ls -l  正确</p>
<p><strong>减号 - 的用途</strong>，前面stdout作为后面的stdin，则前后可用 - 代替</p>
<p>>tar -cvf - /home | tar -xvf -</p>
<p> cp, ls 不支持正则表达式，只能用通配符</p>
<p> vim grep sed awk 支持正则表达式</p>
<p><strong>正则表达式</strong></p>
<p>利用中括号 [] 来搜寻集合字符</p>
<p>>grep -n ‘t[ae]st’ regular_express.txt</p>
<p>>grep -n ‘oo’ regular_express.txt</p>
<p>>grep -n ‘[^g]oo’ regular_express.txt</p>
<p>>grep -n ‘[^a-z]oo’ regular_express.txt  = grep -n ‘[^[:lower:]]oo’ regular_express.txt</p>
<p>> grep -n ‘[0-9]’ regular_express.txt  =  grep -n ‘[[:digit:]]’ regular_express.txt</p>
<p>行首与行尾字符 ^ $</p>
<p>>grep -n ‘^the’ regular_express.txt   –the只出现在行首</p>
<p>>grep -n ‘^[a-z]’ regular_express.txt  =  grep -n ‘^[[:lower:]]’ regular_express.txt  –行首只是小写字母</p>
<p>>grep -n ‘^[^a-zA-Z]’ regular_express.txt  =  grep -n ‘^[^[:alpha:]]’ regular_express.txt  –开头不是字母</p>
<p>>ls -l /etc | grep ‘^l’ | wc -l  –找到链接文件并计数</p>
<p><strong>那个 ^ 符号，在字符集合符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！</strong></p>
<p>>grep -n ‘.$’ regular_express.txt  –行尾结束为小数点’.’</p>
<p>>grep -n ‘^$’ regular_express.txt  –空白行 </p>
<p>>grep -v ‘^$’ /etc/syslog.conf | grep -v ‘^#’  非空白行非以#开头的行</p>
<p>任意一个字符 . 不重复字符 *</p>
<p>. (小数点)：代表『一定有一个任意字符』的意思；</p>
<p>* (星星号)：代表『重复前一个RE字符 0 到无穷多次』的意思，为组合形态， 重复前一个RE字符为0次则为空字符。</p>
<p>>grep -n ‘g..d’ regular_express.txt  –共有四个字符， 起头是 g 而结束是 d  等于通配符中 g??d</p>
<p>>grep -n ‘ooo<em>‘ aaa.txt   –至少两个o以上的字符串，前两个o固定，肯定有，后面“o</em>”为正则表达式，表示0个或任意个o</p>
<p>>grep -n ‘goo*g’ regular_express.txt  – 包含 gog, goog, gooog….的字符</p>
<p>>grep -n ‘g.<em>g’ regular_express.txt  –.</em> 就代表零个或多个任意字符 ，以g开头，以g结尾的字符</p>
<p>>grep -n ‘[0-9][0-9]*’ regular_express.txt  =  grep -n ‘[0-9]’ regular_express.txt –包含数字的行</p>
<p>限定连续 RE 字符范围 {}，\转义</p>
<p>>grep -n ‘o{2}‘  regular_express.txt  –两个 o 的字符串</p>
<p>>grep -n ‘go{2,5}g’ regular_express.txt  –g后接2到5个o</p>
<p>>grep -n ‘go{2,}g’ regular_express.txt = grep -n ‘gooo*g’ regular_express.txt  –g后接两个以上o</p>
<p>正则表达式：<em>代表重复前面字符0到任意次，.代表任意一个字符    ls | grep -n ‘^a.</em>‘      grep支持正则表达式    </p>
<p>通配符：    <em>代表任意字符，？代表任意一个字符              ls -l a</em>  以a开头的文件   ls不支持正则表达式，用通配符</p>
<p><strong>sed  通常处理段落中的行</strong></p>
<p>   -n  安静模式</p>
<p>   -i  直接修改文件，不在屏幕输出</p>
<p>  -e  编辑模式 sed后面两个以上动作时，要加-e,其余可省略</p>
<p>>nl /etc/passwd | sed ‘2,5d’ 删除2-5行</p>
<p>>nl /etc/passwd | sed ‘2a drink tea’ 第二行后添加drink tea</p>
<p>>nl /etc/passwd | sed ‘2i drink tea’ 第二行前添加drink tea</p>
<p>>nl /etc/passwd | sed ‘2,5c  NO 2-5 number’  将2-5行替换成NO 2-5 number</p>
<p>>nl /etc/passwd | sed -n ‘5,7p’ 显示5-7行数据</p>
<p><strong>sed ‘s/要被取代的字符串/新的字符串/g’</strong></p>
<p>>/sbin/ifconfig eth0 | grep ‘inet addr’ |sed ‘s/^.<em>addr://g’ |sed ‘s/Bcast.</em>$//g’  <strong><del>inet addr:</del>192.168.1.100~~ Bcast:192.168.1.255 Mask:255.255.255.0~~</strong></p>
<p>>sed -i ‘s/.$/!/g’ regular_express.txt  直接使用sed对文件修改</p>
<p>>sed -i ‘$a # This is a test’ regular_express.txt  最后一行加入『# This is a test』</p>
<p><strong>awk 处理一行中的字段</strong></p>
<p>awk ‘条件类型 1{动作 1} 条件类型 2{动作 2} …’ filename</p>
<p>>last -n 5 | awk ‘{print $1 “\t” $3}’  –输出第一列第三列，中间[tab]隔开。</p>
<p><strong>$0整行 $1第一列  $2 第二列。。。</strong></p>
<p><strong>NF  每一行拥有的字段总数</strong></p>
<p><strong>NR  目前 awk 所处理的是『第几行』数据</strong></p>
<p><strong>FS  目前的分隔字符，默认是空格键</strong></p>
<p>>last -n 5| awk ‘{print $1 “\t lines: “ NR “\t columes: “ NF}’</p>
<p>>cat /etc/passwd | awk ‘BEGIN {FS=”:”} $3&lt;10 {print $1 “\t” $3}’</p>
<p><strong>diff</strong> 比对文本文件中的行，目录</p>
<p><strong>cmp</strong> 比对字节，二进制文件</p>
<p>获得IP</p>
<p>>ifconfig eth0 | grep ‘inet addr’ | sed ‘s/^.*inet addr://g’ | cut -d ‘’ -f 1</p>
<p>shell scripts执行方式：</p>
<p>以子bash执行：</p>
<p>​       直接指令下达： shell.sh 档案必须要具备可读不可执行 (rx) 的权限，然后： </p>
<blockquote>
<p>绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；<br>相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来执行<br>变量『PATH』功能：将 shell.sh 放在 PATH 指定的目录内例如： ~/bin/，输入文件名shell.sh为当成指令，会自动到PATH内寻找</p>
</blockquote>
<blockquote>
<p>  以 bash 程序来执行：透过『 bash shell.sh 』或『 sh shell.sh 』来执行，  sh为bash的链接文件。</p>
</blockquote>
<p>在父bash中执行：</p>
<p>​     使用 source 来执行指令 source sh02.sh，shell script中局部变量在父bash中也可调用。</p>
<p>script debug</p>
<p>>sh [-nvx] scripts.sh</p>
<blockquote>
<p>-n ：不要执行 script，仅查询语法的问题；<br>-v ：再执行 sccript 前，先将 scripts 的内容输出到屏幕上；<br>-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！</p>
</blockquote>
<hr>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/b5e93964-02d8-431f-83dd-68b1d9c184a6.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/c4c5e72f-6355-43a0-8ab9-688c43ba7a0d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/8850c093-6fd4-4f24-8c4f-32271eb112f9.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/6eb7bc33-740d-4830-95b3-1fac455a4fdb.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/1395e434-47a7-463c-a2c5-88819a45e5de.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/ab5f29c1-f564-4edb-94ee-179c70993ce8.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/5f976daf-a252-41a7-a8db-99ebcaae47be.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/2cb27e66-ee79-4e69-b8a2-22eccac5191d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/c4278aa1-3607-4c2c-8b06-0c8f93f7796d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/c64dc72f-5d79-415d-a59c-7dd9d00c945d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/77f497b8-1ea0-4d22-a8e3-ee683bcf98ea.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/8a62e109-e5db-4572-bb85-572d1b8dc570.png" alt="img"></p>
<p><strong>分割区块</strong></p>
<p>1.新建 </p>
<p>  sp   split  new   上下</p>
<p>  vsp  vsplit  vnew  左右</p>
<p>  close only qall wall wqall</p>
<p>2.切换选框</p>
<p>  ctrl w w   ctrl w跳脱所有按键，在按w键选择</p>
<p>​          t</p>
<p>  crtl w  h j k  l</p>
<p>​          b</p>
<p>3.移动选框  调整位置</p>
<p>  crtl w  HJKL   </p>
<p>  2竖——&gt;2横  ctrl w  J/K    </p>
<p>  2横——&gt;2竖  ctrl w  H/L</p>
<p>4.调整大小</p>
<p>  nsplit     n行的框  </p>
<p>  n ctrl w +  增加n行</p>
<p>  n ctrl w -  减少n行</p>
<p>5.：all 为每个打开一个窗口</p>
<p><strong>DOS 与 Linux 的断行字符转换</strong><br>DOS  ^M$  CRLR</p>
<p>Linux  $     LR</p>
<p>>dos2unix [-kn] file [newfile]</p>
<p>>unix2dos [-kn] file [newfile]</p>
<blockquote>
<p>-k ：保留该档案原本的 mtime 时间格式 (不更新档案上次内容经过修订的时间)<br>-n ：保留原本的旧档，将转换后的内容输出到新档案，如： dos2unix -n old new</p>
</blockquote>
<p>>unix2dos -k man.config</p>
<p>>dos2unix -k -n man.config man.config.linux</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>chsh修改登录shell为zsh</title>
    <url>/2016/Linux/%E9%9B%86%E9%94%A6/chsh%E4%BF%AE%E6%94%B9%E7%99%BB%E5%BD%95shell%E4%B8%BAzsh/</url>
    <content><![CDATA[<p><strong>1 我想知道我机器安装了哪些shell？</strong></p>
<p>两种方法可以查看：</p>
<p>第一种：</p>
<p>[rocrocket@wupengchong ~]$ chsh -l<br>/bin/sh<br>/bin/bash<br>/sbin/nologin<br>/bin/zsh</p>
<p>第二种：</p>
<p>[rocrocket@wupengchong ~]$ cat /etc/shells<br>/bin/sh<br>/bin/bash<br>/sbin/nologin<br>/bin/zsh</p>
<p>其实chsh -l也是来查看这个文件。</p>
<p>2 我想知道我当前正在使用的shell是哪个阿？</p>
<p>[rocrocket@wupengchong ~]$ echo $SHELL<br>/bin/bash</p>
<p>注意SHELL一定要是大写。可以看到，我目前使用的shell是/bin/bash</p>
<p><strong>3 执行了zsh之后，我查看当前shell类型仍然是/bin/bash呢？</strong></p>
<p>请注意，我们虽然执行了zsh，但是所谓“当前的shell”是一个大环境的概念，是针对一个已登录的用户而言的。而我们执行zsh只是启动了一个zsh的解释器程序而已，并没有改变大环境。如果想改变“当前的shell”，那么还是要使用chsh才可以。</p>
<p><strong>4 我想把我的shell改成zsh！</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[rocrocket@wupengchong ~]$ chsh -s /bin/zsh</span><br><span class="line">Changing shell for rocrocket.</span><br><span class="line">Password:</span><br><span class="line">Shell changed.</span><br><span class="line">[rocrocket@wupengchong ~]$</span><br></pre></td></tr></table></figure></p>
<p>使用chsh加选项-s就可以修改登录的shell了！</p>
<p>你会发现你现在执行echo $SHELL后仍然输出为/bin/bash，这是因为你需要重启你的shell才完全投入到zsh怀抱中去。</p>
<p><strong>5 chsh -s到底是修改了哪里？</strong></p>
<p>秘密告诉你吧。chsh -s其实修改的就是/etc/passwd文件里和你的用户名相对应的那一行。现在我来查看下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[rocrocket@wupengchong ~]$ cat /etc/passwd|grep ^rocrocket</span><br><span class="line">rocrocket:x:500:500:rocrocket,China:/rocrocket/PSB/home:/bin/zsh</span><br></pre></td></tr></table></figure></p>
<p>看！你可以发现输出内容的最后部分已经变成了/bin/zsh了！下次你重启的时候，linux就会读取这一命令来启动你的shell了！</p>
<p>好了，我要恢复正常工作，把shell修改会我熟悉的/bin/bash了！</p>
<p>[rocrocket@wupengchong ~]$ chsh -s /bin/bash<br>Changing shell for rocrocket.<br>Password:<br>Shell changed.</p>
<p>over~</p>
<p>来源： <a href="http://roclinux.cn/?p=739" target="_blank" rel="noopener">http://roclinux.cn/?p=739</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>集锦</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议介绍</title>
    <url>/2021/Linux/%E9%9B%86%E9%94%A6/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>网上看到一篇对开原协议讲述的比较通俗易懂的文章，感谢原作者。</p>
<p>世界上的开源许可证（Open Source License）大概有上百种，今天我们来介绍下几种我们常见的开源协议。大致有GPL、BSD、MIT、Mozilla、Apache和LGPL等。</p>
<p><img src="/2021/Linux/集锦/开源协议介绍/0.604344791375343.png" alt="img"></p>
<h3 id="Apache-License"><a href="#Apache-License" class="headerlink" title="Apache License"></a>Apache License</h3><p>Apache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。</p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：</p>
<ul>
<li>需要给代码的用户一份Apache Licence。</li>
<li>如果修改了代码，需要再被修改的文件中说明。</li>
<li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li>
<li>Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</li>
</ul>
<p>使用这个协议的好处是:</p>
<ul>
<li>永久权利 一旦被授权，永久拥有。</li>
<li>全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li>
<li>授权免费 无版税， 前期、后期均无任何费用。</li>
<li>授权无排他性 任何人都可以获得授权</li>
<li>授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码</li>
</ul>
<h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>BSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。</p>
<p>BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL （GNU General Public License） ：GNU通用公共许可协议。</p>
<p><strong>Linux 采用了 GPL</strong>。</p>
<p>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p>
<h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p>
<h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<p>MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<h3 id="MPL-Mozilla-Public-License-1-1"><a href="#MPL-Mozilla-Public-License-1-1" class="headerlink" title="MPL (Mozilla Public License 1.1)"></a>MPL (Mozilla Public License 1.1)</h3><p>MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p>
<h3 id="EPL-Eclipse-Public-License-1-0"><a href="#EPL-Eclipse-Public-License-1-0" class="headerlink" title="EPL (Eclipse Public License 1.0)"></a>EPL (Eclipse Public License 1.0)</h3><p>EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。</p>
<p>使用EPL协议，需要遵守以下规则：</p>
<ul>
<li>当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；</li>
<li>EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；</li>
<li>当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；</li>
<li>4.独立的模块(Separate Module),不需要开源。</li>
</ul>
<h3 id="Creative-Commons-知识共享协议"><a href="#Creative-Commons-知识共享协议" class="headerlink" title="Creative Commons 知识共享协议"></a>Creative Commons 知识共享协议</h3><p>Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介：</p>
<ul>
<li>署名 作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</li>
<li>相同方式共享 作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。</li>
<li>非商业用途 作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。</li>
<li>禁止衍生作品</li>
</ul>
<p>CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。</p>
<p>CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。</p>
<hr>
<h3 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h3><p><img src="/2021/Linux/集锦/开源协议介绍/0.806442015465004.png" alt="img"></p>
<p><img src="/2021/Linux/集锦/开源协议介绍/0.7893948360872438.png" alt="img"></p>
<p><img src="/2021/Linux/集锦/开源协议介绍/0.03694453917716278.png" alt="img"></p>
<p>来源： <a href="https://www.jianshu.com/p/36c1cd4aaeae" target="_blank" rel="noopener">https://www.jianshu.com/p/36c1cd4aaeae</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>集锦</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RAID</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/RAID/</url>
    <content><![CDATA[<p>Quota 磁盘配额，用于多账户中的系统管理员分配各账号资源。</p>
<p><strong>LVM</strong> （Logical Volume Manager） 逻辑卷管理</p>
<p>LVM 的重点在于『可以弹性的调整 filesystem 的容量！』而并非在于效能不数据保全上面。 </p>
<p>RAID（Redundant Arrays of Inexpensive Disks） 独立冗余磁盘阵列   </p>
<h1 id="标准RAID"><a href="#标准RAID" class="headerlink" title="标准RAID"></a>标准RAID</h1><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID-0"></a><strong>RAID-0</strong></h2><p><strong>RAID-0</strong> (等量模式,stripping)：效能最佳，没有备份，100M文件， 2个磁盘写入各50M</p>
<p>RAID 0亦称为带区集。它将两个以上的磁盘串联起来，成为一个大容量的磁盘。在存放数据时，分段后分散存储在这些磁盘中，因为读写时都可以并行处理，所以在所有的级别中，RAID 0的速度是最快的。但是RAID 0既没有冗余功能，也不具备容错能力，如果一个磁盘（物理）损坏，所有数据都会丢失，危险程度与JBOD相当。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/2bbb9dd0-c098-46fb-aeeb-9afd0de7220a.png" alt="RAID 0"></p>
<h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID-1"></a>RAID-1</h2><p><strong>RAID-1</strong> (映像模式, mirror)：完全备份，100M文件，2个磁盘写入各100M，利用率仅为50%。</p>
<p>两组以上的N个磁盘相互作<a href="http://zh.wikipedia.org/wiki/磁碟鏡像" target="_blank" rel="noopener">镜像</a>，在一些多线程操作系统中能有很好的读取速度，理论上读取速度等于硬盘数量的倍数，另外写入速度有微小的降低。只要一个磁盘正常即可维持运作，可靠性最高。RAID 1就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以RAID 1的数据安全性在所有的RAID级别上来说是最好的。但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中磁盘利用率最低的一个级别。如果用两个不同大小的磁盘建RAID 1，可用空间为较小的那个磁盘，较大的磁盘多出来的空间也可以分区成一个区来使用，不会造成浪费。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/8b7e5fc2-ba0d-4a2c-9c7d-dd1eff8df40b.png" alt="RAID 1"></p>
<h2 id="RAID-2"><a href="#RAID-2" class="headerlink" title="RAID 2"></a><strong>RAID 2</strong></h2><p>这是RAID 0的改良版，以<a href="http://zh.wikipedia.org/wiki/汉明码" target="_blank" rel="noopener">汉明码</a>（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID2最少要三台磁盘驱动器方能运作。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/db3a9069-0974-4644-bddb-8a44feccc7be.png" alt="RAID 2"></p>
<h2 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h2><p>采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/6bb794a3-5b0d-47c2-bf38-da668a8c3f0b.png" alt="RAID 3"></p>
<h2 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h2><p>它与RAID 3不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（块交织技术，Block interleaving）</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/2ab89468-1641-4c9d-9470-e97708a2230b.png" alt="RAID 4"></p>
<h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a><strong>RAID 5</strong></h2><p>至少三个磁盘才能组成，每个循环的写入过程中，在每颗磁盘还加入一个同位检查数据 (Parity) ，这个数据会记录其他磁盘的备份数据， 用于当有磁盘损毁时的救援。由于有同位检查码，因此 RAID 5 的总容量会是整体磁盘数量减一颗。 原本的 3 颗磁盘只会剩下 (3-1)=2 颗磁盘的容量。而且当损毁的磁盘数量大于等于两颗时，这整组 RAID 5 的资料就损毁了。 因为 RAID 5 预设仅能支持一颗磁盘的损毁情况。RAID 5读取很快，写入时由于要计算同位检查码 (parity) 的关系，尤其当使用软件磁盘阵列时，同位检查码是通过 CPU 去计算而非与职的磁盘阵列卡， 因此效能方面还需要评估。</p>
<p>RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。RAID 5至少需要三块硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的<a href="http://zh.wikipedia.org/wiki/奇偶校验" target="_blank" rel="noopener">奇偶校验</a>信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。RAID 5可以理解为是RAID 0和RAID 1的折衷方案。RAID 5可以为系统提供数据安全保障，但保障程度要比<a href="http://zh.wikipedia.org/wiki/鏡像" target="_blank" rel="noopener">镜像</a>低而磁盘空间利用率要比镜像高。RAID 5具有和RAID 0相近似的数据读取速度，只是因为多了一个奇偶校验信息，写入数据的速度相对单独写入一块硬盘的速度略慢，若使用“回写缓存”可以让性能改善不少。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较便宜。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/image-20210707223414969.png" alt="image-20210707223414969"></p>
<h2 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h2><p>与RAID 5相比，RAID 6增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。但RAID 6需要分配给奇偶校验信息更大的磁盘空间，相对于RAID 5有更大的“写损失”，因此“写性能”非常差。较差的性能和复杂的实作方式使得RAID 6很少得到实际应用。同一数组中最多容许两个磁盘损坏。更换新磁盘后，数据将会重新算出并写入新的磁盘中。依照设计理论，RAID 6必须具备四个以上的磁盘才能生效。</p>
<p>可使用的容量为硬盘总数减去2的差，乘以最小容量，公式为：</p>
<p>同理，数据保护区域容量则为最小容量乘以2。RAID 6在硬件磁盘阵列卡的功能中，也是最常见的磁盘阵列等级。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/e30a8ade-d986-4deb-a5e4-ad983645a557.png" alt="RAID 6"></p>
<h1 id="混合RAID"><a href="#混合RAID" class="headerlink" title="混合RAID"></a>混合RAID</h1><h3 id="JBOD"><a href="#JBOD" class="headerlink" title="JBOD"></a>JBOD</h3><p> JBOD（ Just a Bunch Of Disks）在分类上，JBOD并不是RAID的等级。由于并没有规范，市场上有两类主流的做法</p>
<ol>
<li>使用单独的链接端口如SATA、USB或1394同时控制多个各别独立的硬盘，使用这种模式通常是较高级的设备，还具备有RAID的功能，不需要依靠JBOD达到合并逻辑扇区的目的。</li>
<li>只是将多个硬盘空间合并成一个大的逻辑硬盘，没有错误备援机制。</li>
</ol>
<p>数据的存放机制是由第一颗硬盘开始依序往后存放，即操作系统看到的是一个大硬盘（由许多小硬盘组成的）。但如果硬盘损毁，则该颗硬盘上的所有数据将无法救回。若第一颗硬盘损坏，通常无法作救援（因为大部分文件系统将磁盘分区表（partition table）‎存在磁盘前端，即第一颗），失去磁盘分区表即失去一切数据，若遭遇磁盘阵列数据或硬盘出错的状况，危险程度较RAID 0更剧。它的好处是不会像RAID，每次访问都要读写全部硬盘。</p>
<h3 id="RAID-10-01"><a href="#RAID-10-01" class="headerlink" title="RAID 10/01"></a>RAID 10/01</h3><p>RAID 0+1，RAID 1+0 ，先4个磁盘中分两组raid0，这两组在raid1，叫raid0+1,如果先组成raid1，再组成raid0，叫raid1+0。</p>
<p>RAID 10是先镜射再分区数据，再将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。</p>
<p>RAID 01则是跟RAID 10的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成RAID 1的最低组合，而将两组硬盘各自视为RAID 0运作。</p>
<p>当RAID 10有一个硬盘受损，其余硬盘会继续运作。RAID 01只要有一个硬盘受损，同组RAID 0的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。如果以六个硬盘建RAID 01，镜射再用三个建RAID 0，那么坏一个硬盘便会有三个硬盘脱机。因此，RAID 10远较RAID 01常用，零售<a href="http://zh.wikipedia.org/wiki/主機板" target="_blank" rel="noopener">主板</a>绝大部份支持RAID 0/1/5/10，但不支持RAID 01。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/4afa441d-a59b-4df3-a2b8-2f1ea339451d.png" alt="RAID 1+0"><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/23ce5c96-7129-460f-b58c-3ed80e073d07.png" alt="RAID 0+1"></p>
<h3 id="RAID-50"><a href="#RAID-50" class="headerlink" title="RAID 50"></a>RAID 50</h3><p>RAID 5与RAID 0的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5彼此构成Stripe访问。由于RAID 50是以RAID 5为基础，而RAID 5至少需要3台硬盘，因此要以多组RAID 5构成RAID 50，至少需要6台硬盘。以RAID 50最小的6台硬盘配置为例，先把6台硬盘分为2组，每组3台构成RAID 5，如此就得到两组RAID 5，然后再把两组RAID 5构成RAID 0。</p>
<p>RAID 50在底层的任一组或多组RAID 5中出现1台硬盘损坏时，仍能维持运作，不过如果任一组RAID 5中出现2台或两台以上硬盘损毁，整组RAID 50就会失效。</p>
<p>RAID 50由于在上层把多组RAID 5构成Stripe，性能比起单纯的RAID 5高，容量利用率比RAID5要低。比如同样9块硬盘，RAID 50则3个RAID 5组成RAID 0，每个RAID 5会浪费一块硬盘，利用率为(1-3/9)，RAID 5则为(1-1/9)。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/99f0884d-f3a2-4368-90e1-9e27d470a7ce.png" alt="img"></p>
<h3 id="RAID-53"><a href="#RAID-53" class="headerlink" title="RAID 53"></a>RAID 53</h3><p>它拥有一个镜射条带数组，硬盘里其中一个条带就是一个是由3组以上的RAID 5组成RAID 3硬盘阵列。</p>
<h3 id="RAID-60"><a href="#RAID-60" class="headerlink" title="RAID 60"></a>RAID 60</h3><p>RAID 6与RAID 0的组合：先作RAID 6，再作RAID 0。换句话说，就是对两组以上的RAID 6作Stripe访问。RAID 6至少需具备4台硬盘，所以RAID 60的最小需求是8台硬盘。由于底层是以RAID 6组成，所以RAID 60可以容许任一组RAID 6中损毁最多2台硬盘，而系统仍能维持运作；不过只要底层任一组RAID 6中损毁3台硬盘，整组RAID 60就会失效，当然这种情况的机率相当低。比起单纯的RAID 6，RAID 60的上层通过结合多组RAID 6构成Stripe访问，因此性能较高。不过使用门槛高，而且容量利用率低是较大的问题。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/92f4b141-e6e9-464a-87de-2ab9d900c88c.jpg" alt="img"><br><strong>Spare Disk：</strong>一颗或多颗没有包含在原本磁盘阵列等级中的磁盘，这颗磁盘平时并不会被磁盘阵列所使用， 当磁盘阵列有任何磁盘损毁时，则这颗 spare disk 会被主动的拉近磁盘阵列中，并将坏掉的那颗硬盘移出磁盘阵列！ 然后立即重建数据系统。</p>
<p>RAID2、3、4较少实际应用，因为RAID5已经涵盖了所需的功能，因此RAID2、3、4大多只在研究领域有实现，而实际应用上则以RAID5为主。</p>
<p>RAID4有应用在某些商用机器上，像是NetApp公司设计的NAS系统就是使用RAID4的设计概念。</p>
<p>10个250G的磁盘组成RAID5，去掉一个Spare Disk剩9颗（9-1）*250=2000G</p>
<p><strong>hardware RAID</strong> 透过磁盘阵列卡来达成数组的目的。 磁盘阵列卡上面有一块专门的芯片在处理 RAID 的任务，因此在效能方面会比较好。在很多任务(例如 RAID 5 的同位检查码计算) 磁盘阵列并不会重复消耗原本系统的 I/O 总线，理论上效能会较佳。此外目前一般的中高阶磁盘阵列卡都支持热拔插， 亦即在不关机的情况下抽换损坏的磁盘，对于系统的复原与数据的可靠性方面非常的好用，但价格昂贵。</p>
<p><strong>Software RAID</strong> 透过软件来仿真数组的任务， 因此会损耗较多的系统资源，比如说 CPU 的运算不 I/O 总线的资源等。分类有二种：  纯软件磁盘阵列（Pure Software RAID）：只需要主板支持即可，不需要任何磁盘阵列卡。若主板损坏，可能难以购买同款主板重建RAID。<br>  硬件辅助磁盘阵列（Hardware-Assisted RAID）：需要一张RAID卡，以及厂商所提供的<a href="http://zh.wikipedia.org/wiki/驅動程式" target="_blank" rel="noopener">驱动程序</a>。这款RAID较易迁移到其他电脑。</p>
<h2 id="磁盘阵列比较表"><a href="#磁盘阵列比较表" class="headerlink" title="磁盘阵列比较表"></a>磁盘阵列比较表</h2><table>
<thead>
<tr>
<th><strong>RAID**</strong>等级**</th>
<th><strong>最少硬盘</strong></th>
<th><strong>最大容错</strong></th>
<th><strong>可用容量</strong></th>
<th><strong>读取性能</strong></th>
<th><strong>写入性能</strong></th>
<th><strong>安全性</strong></th>
<th><strong>目的</strong></th>
<th><strong>应用产业</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>单一硬盘</td>
<td>(参考)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>无</td>
<td></td>
<td></td>
</tr>
<tr>
<td>JBOD</td>
<td>1</td>
<td>0</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td>无（同RAID 0）</td>
<td>增加容量</td>
<td>个人（暂时）存储备份</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
<td>2</td>
<td>n-2</td>
<td>n-2</td>
<td>n-2</td>
<td>安全性较RAID 5高</td>
<td>同RAID 5，但较安全</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>1</td>
<td>n-1</td>
<td>n-1</td>
<td>n-1</td>
<td>高</td>
<td>追求最大容量、最小预算</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>10</td>
<td>4</td>
<td>n/2</td>
<td>n/2</td>
<td>n</td>
<td>n/2</td>
<td>安全性高</td>
<td>综合RAID 0/1优点，理论速度较快</td>
<td>大型数据库、服务器</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>n-1</td>
<td>1</td>
<td>n</td>
<td>1</td>
<td>最高，一个正常即可</td>
<td>追求最大安全性</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>0</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>一个硬盘异常，全部硬盘都会异常</td>
<td>追求最大容量、速度</td>
<td>视频剪接缓存用途</td>
</tr>
</tbody>
</table>
<p>\1. n代表硬盘总数<br>\2. JBOD可接到现有硬盘，直接增加容量</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>X Window System</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/X-Window-System/</url>
    <content><![CDATA[<p>X Client 应用程序会将所想要呈现的画面告知 X Server ，最后由 X server 来将结果透过他所管理的硬件绘制出来</p>
<p>X Server 管理的是显示适配器、屏幕分辨率、鼠标按键对应等等</p>
<p>每部客户端主机都需要安装 X Server，而服务器端则是提供 X Client 软件， 以提供客户端绘图所需要的数据windows客户端 &lt;————服务器————&gt;mac客户端提供X Server管理         提供X Client     提供X Server管理<br>X window system 主要分为 X server 和 X client ，其中 ：X Server 在管理硬件（包括鼠标，键盘，显示器等）和图形绘制。 X Client 则 是应用程序，可提供数据给X Server来绘制图形。<br>每一支 X client 都不知道对方得存在，必须要透过特殊的 X client ，称为 Window Manager 的， 来管理各窗口的重迭、移动、最小化等工作。</p>
<p>startx 获取参数调用xinit启动窗口</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Tarball安装（源代码安装）<br>1.解压到 /usr/local/src<br>2.到软件目录下执行 ./configure 检测平台环境变量，生成Makefile<br>3.执行make命令，编译成目标文件并连接库函数，生成二进制文件 其实是替代了gcc的一步步编译，make自动去找Makefile文件，Makefile文件中写了很多gcc编译的配置。当前目录下生成objs文件夹<br>4.执行make install 将编译后的文件放到安装目录下</p>
<table>
<thead>
<tr>
<th>distribution 代表</th>
<th>软件管理机制</th>
<th>使用命令</th>
<th>在线升级机制(命令)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Red Hat/Fedora</td>
<td>RPM</td>
<td>rpm, rpmbuild</td>
<td>YUM (yum)</td>
</tr>
<tr>
<td>Debian/Ubuntu</td>
<td>DPKG</td>
<td>dpkg</td>
<td>APT (apt-get)</td>
</tr>
</tbody>
</table>
<p>虽然RPM与DPKG有效的解决的软体的安装，移除与查询的需求，但是在Linux上的套件管理还有一个很大的问题必须解决，就是各软体间的相依性(dependency)。 <strong>RPM与DPKG只能做到检查相依性，在安装或移除时告知相依性的不满足，皆下来就需要使用者自行去找出所需的套件来安装。 这样的确是有点不方便，因此产生了前端工具软体- APT及YUM。</strong></p>
<p>安装/更新</p>
<p> -h用#(hash)符显示rpm安装过程  -v详述安装过程<br>rpm -ivh fds.rpm –force –prefix /usr/local<br>rpm -Uvh fds.rpm  后面接的软件，如果原本未安装，则直接安装，原本已安装时，则直接升级；<br>rpm -Fvh fds.rpm  后面接的软件，如果原本未安装，则不安装，原本已安装时，则直接升级；</p>
<p>查询<br>rpm -qa<br>rpm -qlicdR 已安装package<br>rpm -qf 文件名  –查询文件属于哪个软件<br>rpm -qplicdR 未安装package</p>
<p>rpm -qa|grep ^a|wc -l 以a开头的软件个数</p>
<p>验证<br>rpm -Va<br>rpm -V 已安装软件<br>rpm -Vf 文件名</p>
<p>卸载<br>rpm -ev 已安装软件</p>
<p>重建数据库<br>rpm –rebuilddb</p>
<p>SRPM(source RPM)方式<br>rpmbuild –rebuild  aaa.src.rpm 编译打包<br>rpmbuild –recompile aaa.src.rpm 编译打包安装<br>rpmbuild -ba aaa.spec 编译并同时产生RPM与SRPM档案<br>rpmbuild -bb aaa.spec 仅编译成RPM档案</p>
<p>yum线上安装<br>yum search raid<br>yum list pam*  =rpm -qa<br>yum list updates 查询可升级软件<br>yum info raid  =rpm -qi<br>yum provides passwd  =rpm -qf</p>
<p>yum -y install pam-devel –installroot=/path<br>yum update pam 整个系统都升级不加软件名<br>yum remove pam-devel</p>
<p><strong>更改repository地址</strong><br><img src="/2014/Linux/鸟哥的Linux私房菜/Linux软件安装/11394328.png" alt="img"></p>
<p><strong>新建repository地址</strong></p>
<p>>vim /etc/yum.repos.d/drbl.repo</p>
<p> [drbl]</p>
<p> name = this is DRBL site</p>
<p> baseurl=<a href="http://free.nchc.org.tw/drbl-core/i386/RPMS.drbl-stable/" target="_blank" rel="noopener">http://free.nchc.org.tw/drbl-core/i386/RPMS.drbl-stable/</a></p>
<p> enable =1</p>
<p> gpgcheck=0</p>
<p>>yum search drbl</p>
<p>>yum repolist all</p>
<p>yum clean [packages|headers|all] 清除原来的软件列表<br>yum [grouplist|groupinfo|groupinstall|groupremove] 群组软件名</p>
<p>  yum grouplist 显示所有可以安装的群组</p>
<p>  yum grouplist | grep Development</p>
<p>  yum groupinfo “Development tools”</p>
<p>  <strong>yum -y groupinstall “Development tools” 如果报错，先执行 yum clean all</strong></p>
<p>yum -y update  系统升级</p>
<p>安装</p>
<p>dpkg -i pkgfile.deb</p>
<p>在Debian使用alien处理RPM套件</p>
<blockquote>
<p>alien 可处理.deb、.rpm、.slp、.tgz 等档案格式, 进行转档或安装.<br>于Debian安装非Debian套件时,可使用<strong>alien</strong>进行安装.<br>安装alien套件: apt-get install alien</p>
</blockquote>
<ul>
<li>在Debian安装RPM套件: alien -i quota-3.12-7.i386.rpm</li>
<li>制作成deb的套件格式: alien -d quota-3.12-7.i386.rpm</li>
<li>制作成rpm的套件格式: alien -r quota_3.12-6_i386.deb</li>
</ul>
<p>查询</p>
<p>dpkg -l(小写L)        显示所有安装套件</p>
<p>dpkg -l softwarename (小写L,只列出简洁资讯) </p>
<p>dpkg -s softwarename (显示详细资讯)<br>dpkg -p softwarename (显示详细资讯</p>
<p>dpkg -L softwarename  显示套件包含的所有档案</p>
<p>dpkg -S /path/to/file    显示特定档案所属套件名称</p>
<p>dpkg -I pkgfile.deb (大写i) 查询安装软件包资讯</p>
<p>dpkg -c pkgfile.deb   查询安装软件包资讯</p>
<p>卸载</p>
<p>dpkg -r softwarename (会留下套件设定档)<br>dpkg -P softwarename (完全移除)</p>
<p>apt-get线上安装  </p>
<p>  aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。</p>
<p>举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。功能参数差不多。</p>
<p>apt-get install softname</p>
<p>apt-get update             更新软件包索引</p>
<p>apt-get upgrade            软件升级，执行前须执行update</p>
<p>apt-get remove softwarename 移除软体(保留设定档）</p>
<p>apt-get  –purge remove softwarename 移除软体(不保留设定档）</p>
<p><strong>软件包: build-essential 安装方法：sudo apt-get install build-essential</strong></p>
<p> 软件库地址文件/etc/apt/souces.list</p>
<p>apt-cache search softwarename   列出所有sofrwarename的套件</p>
<p>apt-cache show packageName   显示更多描述细节</p>
<p>apt-get clean(autoclean)         删除系统暂存的deb(autoclean只会将比目前系统旧版的套件删除)</p>
<p>apt-get dist-upgrade            转换系统的版本（需在/etc/apt/sources.list指定stable，testing或unstable）</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>例行性工作排程</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="仅执行一次的工作排程"><a href="#仅执行一次的工作排程" class="headerlink" title="仅执行一次的工作排程"></a>仅执行一次的工作排程</h2><p><strong>启动一次工作排程服务的damon程序atd</strong></p>
<p>>/etc/init.d/atd  restart</p>
<p>>chkconfig atd  on 设定开机启动这个服务</p>
<p><strong>at执行流程</strong></p>
<p>我们使用 at 这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了。</p>
<p>\1.  先找寻 /etc/at.allow 这个档案，写在这个档案中的使用者才能使用 at ，没有在这个档案中的使用者则不能使用 at (即使没有写在 at.deny 当中)；</p>
<p>\2.  如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个档案，若写在这个 at.deny 得使用者则不能使用 at ，而没有在这个 at.deny 档案中得使用者，就可以使用 at 咯；</p>
<p>\3.  如果两个档案都不存在，那么只有 root 可以使用 at 这个指令。</p>
<p>at的执行与终端机环境无关，而所有 standard output/standard error output 都会传送到执行者的 mailbox 去啦！所以在终端机当然看不到任何信息。</p>
<p><strong>at [-mldv] TIME</strong></p>
<p><strong>at  -c  工作号码</strong></p>
<p>-m  ：当 at 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。</p>
<p>-l   ：at -l 相当于 atq，列出目前系统上面的所有该用户的 at 排程；</p>
<p>-d  ：at -d 相当于 atrm ，可以取消一个在 at 排程中的工作；</p>
<p>-v  ：可以使用较明显的时间格式栏出 at 排程中的任务栏表；</p>
<p>-c  ：可以列出后面接的该项工作的癿实际指令内容。</p>
<p>TIME：  HH:MM     ex&gt; 04:00  </p>
<p>​        HH:MM YYYY-MM-DD    ex&gt; 04:00 2009-03-17</p>
<p>​       HH:MM[am|pm] [Month] [Date]   ex&gt; 04pm March 17</p>
<p>​        HH:MM[am|pm] + number [minutes|hours|days|weeks]    ex&gt; now + 5 minutes    ex&gt; 04pm + 3 days</p>
<p>[root@www ~]# at 23:00 2009-03-17  设定一次排程任务</p>
<p>at&gt; /bin/sync</p>
<p>at&gt; /bin/sync</p>
<p>at&gt; /sbin/shutdown -h now</p>
<p>at&gt; <eot>  <strong>–输入ctrl +Ｄ出现<eot>，代表结束。</eot></strong></eot></p>
<p>job 5 at 2009-03-17 23:00　<strong>–自动生成</strong></p>
<p>[root@www ~]# at -c 4     –查询4号job的内容</p>
<p>#!/bin/sh   </p>
<p># atrun uid=0 gid=0</p>
<p># mail root 0</p>
<p>umask 22 </p>
<p><strong>atq  –查询所有at任务</strong></p>
<p><strong>atrm [jobnumber]  –删除at任务</strong></p>
<p><strong>batch  –在 CPU 工作负载小于 0.8 癿时候，才进行你所下达的工作任务
</strong></p>
<p>[root@www ~]# batch 23:00 2009-3-17</p>
<p>at&gt; sync</p>
<p>at&gt; sync</p>
<p>at&gt; shutdown -h now</p>
<p>at&gt; <eot></eot></p>
<p>job 6 at 2009-03-17 23:00</p>
<h2 id="循环执行的例行性工作排程"><a href="#循环执行的例行性工作排程" class="headerlink" title="循环执行的例行性工作排程"></a>循环执行的例行性工作排程</h2><p><strong>启动循环执行服务的damon程序crond(cron有的系统叫这个)，一般默认启动</strong></p>
<p>>/etc/init.d/crond restart</p>
<p>  /etc/cron.allow：将可以使用 crontab 得账号写入其中，若不在这个档案内得使用者则不可使用 crontab；优先级高于deny。</p>
<p>  /etc/cron.deny： 将不可以使用 crontab 得账号写入其中，若未记录到这个档案当中的使用者，就可以使用crontab 。</p>
<p>当用户使用 crontab 这个指令来建立工作排程之后，该项工作就会被记录到 /var/spool/cron/ 里面去了，而且是以账号来作为判别。</p>
<p> <strong>crontab [-u username] [-l|-e|-r]</strong> crontab名利为/etc/contab的文本文件，但可执行。</p>
<blockquote>
<p>-u  ：只有 root 才能进行这个任务，亦即帮其他使用者建立/移除 crontab 工作排程；</p>
<p>-e  ：编辑 crontab 的工作内容</p>
<p>-l  ： 查阅 crontab 的工作内容</p>
<p>-r  ：移除所有的crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</p>
</blockquote>
<p>[dmtsai@www ~]$ crontab -e</p>
<p># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</p>
<p> 0  12  <em>  </em>  *  mail dmtsai -s “at 12:00” &lt; /home/dmtsai/.bashrc</p>
<p>#分 时 日 月 周 |&lt;==============指令串========================&gt;|</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/例行性工作排程/2702d4a7-b61d-41ba-ac79-400d3b1b3c0a.png" alt="img"></p>
<p>  <strong>crontab -l  –查询所有</strong></p>
<p>  <strong>crontab -r  –删除所有
</strong></p>
<p> <strong>anacron
</strong></p>
<p>anacron处理非24小时启动的Linux系统的 crontab 的执行！anacron 并不能指定何时执行某项任务， 而是以天 为单位或者是在开机后立刻进行 anacron 的动作，他会去侦测停机期间应该进行但是并没有进行的 crontab任务，并将该任务执行一遍后， anacron 就会自动停止了。</p>
<p>>anacron [-sfn] [job]<br>>anacron -u [job]<br>  -s ：开始一连续的执行各项工作 (job)，会依据时间记录文件的数据判断是否进行；<br>  -f ：强制进行，而不去判断时间记录文件的时间戳；<br>  -n ：立刻进行未进行的仸务，而不延迟 (delay) 等待时间；<br>  -u ：仅更新时间记录文件的时间戳，不迚行仸何工作。<br>  job ：由 /etc/anacrontab 定义的各项工作名称。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>程序管理和SELinux</title>
    <url>/2021/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E5%92%8CSELinux/</url>
    <content><![CDATA[<p>程序 (program)：通常为 binary program ，放置在储存媒体中 (如硬盘、光盘、软盘、磁带等)， 为实体档案的型态存在；</p>
<p>程序 (process)  ：程序被觉发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载内存中， 操作系统并给予这个内存内的单元一个标识符 (PID)，可以说，程序就是一个正在运作中的程序。</p>
<p><strong>fork and exec</strong>：过程调用的流程</p>
<p>(1)系统先以 fork 的方式复制一个与父程序相同的暂存程序，这个程序与父程序唯一的差别就是 PID 不同！ 但是这个暂存程序还会多一个 PPID的参数，PPID 就是父程序的程序标识符！</p>
<p>(2)暂存程序开始以 exec 的方式加载实际要执行的程序，以标来讲，新的程序名称为 qqq ，最终子程序的程序代码就会变成 qqq 了！</p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/7fc10055-b1c9-460b-a341-d3d0375918ff.png" alt="img"></p>
<h2 id="工作管理（Job-Control）"><a href="#工作管理（Job-Control）" class="headerlink" title="工作管理（Job Control）"></a>工作管理（Job Control）</h2><p>进行工作管理的行为中， 其实每个工作都是<strong>目前 bash（单一终端机接口） 的子**</strong>程序**，亦即彼此之间是有相关性的。 我们无法以 job control 的方式由 tty1的环境去管理 tty2 的bash ！</p>
<p><strong>扔背景中执行 &amp;</strong></p>
<p>>tar -zcv -f /tmp/etc.tar.gz  /etc &gt; /tmp/log.txt  2&gt;&amp;1  &amp;</p>
<p>[1] 8429  &lt;== [job number] PID </p>
<p> 放到背景后，[ctrl]+c 也无法停止执行。</p>
<p><strong>将目前工作扔到背景中暂停  [ctrl]-z</strong></p>
<p> <img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/ad650d36-ec41-42af-b5fc-b7f1dfa4d301.jpg" alt="img"></p>
<p><strong>观察目前的背景工作状态  jobs</strong>  </p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/372581b9-3e6d-4b1b-9a58-db3fca54cee7.png" alt="img"></p>
<p><strong>将背景工作拿到前景来处理：fg (foreground)</strong> </p>
<p>fg %jobnumber  –jobnumber 为工作号码(数字)。注意，那个 % 是可有可无的</p>
<p>>fg     –预设取出那个 + 的工作，亦即2。</p>
<p>>fg %1  –取出1号工作。</p>
<p><strong>将背景中的暂停改为背景中的执行：bg（background）</strong></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/6908739e-386d-404d-ae0a-28e41929c6bb.png" alt="img"></p>
<p><strong>管理背景当中的工作： kill</strong>  </p>
<p><strong>kill -l</strong></p>
<p>-l     ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？</p>
<p>signal ：代表给予后面接的那个工作什么样的指示！用 man 7 signal 可知：</p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/f34c3c39-f539-4b36-9c60-f0ba03ae7a3a.jpg" alt="img"></p>
<p><strong>kill -signal  %jobnumber  –signal可以使代号或者名称</strong></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/afeecb68-eec1-4fd4-8357-7ae1b81866a1.jpg" alt="img"></p>
<p>15为默认值，kill 可以帮我们将这个 signal 传送给某个工作 (%jobnumber) 或者是某个 PID (直接输入数字)，管理bash的工作控制时，要加上%。</p>
<p><strong>kill -signal PID</strong></p>
<p>获取syslog程序的PID,并利用kill -1 PID掉。</p>
<p>>ps aux | grep ‘syslog’ | grep -v ‘grep’| awk ‘{print $2}’</p>
<p>>kill -SIGHUP $(ps aux|grep ‘syslog’|grep -v ‘grep’|awk ‘{print $2}’)</p>
<p><strong>killall -signal 指令名称</strong></p>
<p>killall [-iIe] [command name]</p>
<blockquote>
<p>-i  ：interactive 的意思，交互式的，若需要删除时，会出现提示字符给用户；</p>
<p>-e  ：exact 的意思，表示『后面接的 command name 要一致』，但整个完整的指令不能超过 15 个字符。</p>
<p>-I  ：指令名称(可能含参数)忽略大小写。 </p>
</blockquote>
<p>>killall -1 syslogd</p>
<p>>killall -9 httpd</p>
<p>>killall -i -9 bash –要用户确认</p>
<p><strong>nohup –在脱机或注销系统后，还能够将工作继续进行</strong></p>
<p>nohup [指令与参数]   &lt;==在终端机前景中工作nohup [指令与参数] &amp; &lt;==在终端机背景中工作<br><strong>程序管理**</strong>ps ：将某个时间点的程序运作情况取下来**<br>>ps -l   –列出与你的操作环境 (bash) 有关的程序而已， 亦即最上层的父程序会是你自己的 bash 而没有延伸到 init 这支程序。&gt;ps -lA  –列出全部程序情况&gt;ps aux  –列出目前所有的正在内存当中的程序，没有 “-” </p>
<p>>ps axjf  –列出类似程序树的程序显示，没有 “-” </p>
<p><strong>top：动态观察程序的变化</strong></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/fc01de5e-5a7c-48db-b488-ada58b4e14fe.png" alt="img"></p>
<p>>top       –默认五秒刷新一次</p>
<p>>top -d  2   –两秒刷新一次</p>
<p>>top -b -n 2 &gt; /tmp/top.txt  –将 top 的信息进行 2 次，然后将结果输出到 /tmp/top.txt</p>
<p>>echo $$  –获取当前程序PID</p>
<p>4574</p>
<p>>top -p 4574  –只显示当前程序的信息</p>
<p><strong>pstree</strong><br>-A ：各程序树之间的连接以 ASCII 字符来连接；<br>-U ：各程序树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误。<br>-p ：并同时列出每个 process 的 PID；<br>-u ：并同时列出每个 process 的所属账号名称。<br>>ps -A</p>
<p>>ps -Aup  –显示各个程序的拥有者和PID</p>
<p><strong>程序执行优先级</strong></p>
<p>PRI(new) = PRI(old) + nice  PRI值越小优先级越高</p>
<p>  nice 值可调整的范围为 -20 ~ 19 ；  root 可随意调整自己或他人程序的 Nice 值，范围为 -20 ~ 19 ；  一般用户仅可调整自己程序的 Nice 值，范围仅为 0 ~ 19 (避免一般用户抢占系统资源)；  一般使用者仅可将 nice 值越调越高，例如本来 nice 为 5 ，则未来仅能调整到大于 5；<strong>nice ：新执行的指令即给予新的nice 值</strong><br>nice [-n 数字] command<br>>nice -n -5 vi &amp;<br><strong>renice ：已存在程序的 nice 重新调整</strong><br>renice [number] PID<br>>renice 10 18625系统资源的观察<strong>​free ：观察内存使用情况</strong><br>free [-b|-k|-m|-g]  –默认以Kbytes显示，加上-b bytes， -k Kbytes，-m Mbytes，-g Gbytes显示&gt;free -m<br><strong>uname：查阅系统与核心相关信息</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/efee98ef-b3d0-431f-81bc-998c4bc65647.png" alt="img"><br>>uname -a<br><strong>netstat ：追踪网络或插槽文件</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/04ffb359-95e5-4392-b8a0-d2355b15d0e9.png" alt="img"><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/665908ac-9476-4ff5-92ec-a8525150605d.png" alt="img"><br>>netstat -rn =route -n&gt;netstat  –显示网络和本机相关程序的相关性&gt;netstat -tlnp  –找出目前系统上已在监听的网络联机及其 PID&gt;netstat -tulnp  –秀出目前已经启动的网络服务<br><strong>nmap –[**</strong>Network exploration tool and security<strong> </strong>port scanner<strong>**]:侦测别的主机开放的端口</strong><br>nmap [扫瞄类型] [扫瞄参数] [hosts 地址与范围]选项与参数：[扫瞄类型]：主要的扫瞄类型有底下几种：</p>
<blockquote>
<p>-sT：扫瞄 TCP 封包已建立的联机 connect() ！</p>
<p>-sS：扫瞄 TCP 封包带有 SYN 卷标的数据 -sU：以 UDP 的封包格式进行扫瞄</p>
<p>-sP：以 ping 的方式进行扫瞄</p>
<p>-sO：以 IP 的协议 (protocol) 进行主机的扫瞄</p>
</blockquote>
<p>[扫瞄参数]：主要的扫瞄参数有几种：</p>
<blockquote>
<p>-PT：使用 TCP 里头的 ping 的方式来进行扫瞄，可以获知目前有几部计算机存活(较常用)</p>
<p>-PI：使用实际的 ping (带有 ICMP 封包的) 来进行扫瞄</p>
<p>-p ：这个是 port range ，例如 1024-, 80-1023, 30000-60000 等等的使用方式</p>
</blockquote>
<p>[Hosts 地址与范围]：这个有趣多了，有几种类似的类型</p>
<blockquote>
<p>192.168.1.100  ：直接写入 HOST IP 而已，仅检查一部；</p>
<p>192.168.1.0/24 ：为 C Class 的型态，</p>
<p>192.168.<em>.</em>  ：嘿嘿！则变为 B Class 的型态了！扫瞄的范围变广了！</p>
<p>192.168.1.0-50,60-100,103,200 ：这种是变形的主机范围啦！很好用吧！</p>
</blockquote>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/7cd58a0b-b19b-4210-abdb-186d03c25bd2.png" alt="img"></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/ca747a34-fa8e-476d-9c86-aa0dad411822.png" alt="img"><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/24394921.png" alt="img"></p>
<p><strong>vmstat ：侦测系统资源变化</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/174122ca-ef3d-4183-a723-17aed3baa8f9.png" alt="img"><strong>
</strong>&gt;vmstat 1 3&gt;vmstat -d <strong>dmesg ：分析核心开机侦测系统的硬件和系统运行中产生的讯息<br>>dmesg|more&gt;dmesg|grep -i hd
</strong>fuser：藉由档案(或文件系统)找出正在使用该档案的程序<strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/607e1e1e-474a-4500-8310-97655f0947b4.png" alt="img">
</strong>&gt;fuser -uv .&gt;fuser -mvu /proc<br><strong>lsof ：列出被程序所开启的档案文件名</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/f83c4b26-d59c-47e0-afd3-5bd2f6373b86.png" alt="img"><br><strong>&gt;lsof  – 列出目前系统上面所有已经被开启的档案与装置&gt;lsof -u root -a -U   –仅列出关于 root 的所有程序开启的 socket 档案&gt; lsof +d /dev   –列出目前系统上面所有的被启动的周边装置
</strong>pidof ：找出某支正在执行的程序的 PID<br>pidof [-sx] program_name</p>
<blockquote>
<p>-s  ：仅列出一个 PID 而不列出所有得 PID</p>
<p>-x  ：同时列出该 program name 可能的 PPID 那个程序的 PID</p>
</blockquote>
<p>>pidof syslogd</p>
<hr>
<h2 id="SELinux-Security-Enhanced-Linux"><a href="#SELinux-Security-Enhanced-Linux" class="headerlink" title="SELinux(Security Enhanced Linux )"></a><strong>SELinux(</strong>Security Enhanced Linux <strong>)</strong></h2><p>DAC（Discretionary Access Control）自主式访问控制</p>
<p>MAC (Mandatory Access Control) 委任式访问控制  –SELinux</p>
<p>>getenforce  –查看SELinux模式</p>
<p>> sestatus –查看SELinux 的政策 (Policy) </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>chgrp users install.log</p>
<p>chgrp -R users  /etc/usr   -R递归</p>
<p>chown root  install.log</p>
<p>chown root:root  install.log</p>
<p>chown -R users  /etc/usr   -R递归</p>
<p>chmod 755  .bashrc  权限为-rwxr-xr-x  -R与目录配合递归</p>
<p>chmod  u=rwx,go=rx   .bashrc</p>
<p>chmod  a+x  .bashrc   a包括owner group others全部</p>
<p>chmod  a-x  .bashrc </p>
<h3 id="档案与目录"><a href="#档案与目录" class="headerlink" title="档案与目录"></a>档案与目录</h3><p><strong>档案</strong>是实际含有数据的地方，包括一般文本文件、数据库内容文件、二进制可执行文件(binary program)等等。 因此，权限对于档案来说，他的意义是这样的：</p>
<p> r (Read)：  可读取此档案内包含的内容，如读取文本文件的文字内容等；</p>
<p> w (Write)：可以新增、删除或修改此档案里面包含的内容(<strong>但不能删除该档案</strong>)；</p>
<p> x (eXecute)：该档案具有可以被系统执行的权限。</p>
<p>Windows 底下一个档案是否具有执行的能力是藉由『 扩展名 』来判断的， 例如：.exe, .bat, .com 等等，</p>
<p>但是在 Linux 底下，我们的档案是否能被执行，则是藉由是否具有『x』这个权限来决定的！跟档名是没有绝对的关系的！</p>
<p><strong>目录</strong>主要的内容在记录文件名列表，文件名与目录有强烈的关连啦！ r (read contents in directory)：</p>
<blockquote>
<p>表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！</p>
</blockquote>
<p> w (modify contents of directory)：</p>
<blockquote>
<p>这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目录结构列表的权限，也就是底下这些权限：</p>
<p>o  建立新的档案与目录；</p>
<p>o  删除已经存在的档案与目录(不论该档案的权限为何！)</p>
<p>o  将已存在的档案或补录进行更名；</p>
<p>o  搬移该目录内的档案、目录位置。</p>
<p>总之，目录的 w 权限就与该目录底下的文件名异动有关就对了啦！</p>
</blockquote>
<p> x (access directory)：</p>
<blockquote>
<p>目录的 x 代表的是用户能否进入该目录成为工作目录的用途！ 所谓的工作目录(work directory)就是你目前所在的目录啦！</p>
<p>举例来说，当你登入 Linux 时， 你所在的家目录就是你当下的工作目录。而变换目录的指令是『cd』(change directory)啰。</p>
</blockquote>
<p>例题：</p>
<blockquote>
<p>假如有个账号名称为 dmtsai，他的家目录在/home/dmtsai/，dmtsai 对此目录具有[rwx]的权限。 </p>
<p>若在此目彔下有个名为 the_root.data 的档案，该档案的权限如下： </p>
<p>-rwx—— 1 root root 4365 Sep 19 23:20 the_root.data</p>
<p>请问 dmtsai 对此档案的权限为何？可否删除此档案？ </p>
</blockquote>
<p>答：</p>
<blockquote>
<p>由于 dmtsai 对此档案来说是『others』的身份，因此这个档案他无法读、无法编辑也无法执行， 也就是说，他无法变动这个档案的内容就是了。</p>
<p>但是由于这个档案在他的家目录下，他在此目录下具有 rwx 的完整权限，因此对于the_root.data 这个『档名』来说，他是能够『删除』的！ </p>
<p>结果就是，dmtsai 这个用户能够删除 the_root.data 这个档案！</p>
</blockquote>
<p><strong>r=4,w=2,x=1</strong></p>
<p><strong>umask –默认值需要减掉的权限</strong></p>
<p>>umask </p>
<p>0022</p>
<p>>umask -S</p>
<p>u=rwx,g=rx,o=rx</p>
<p>>umask 002  设置umask为002，同组人可读写该文件。</p>
<p>档案默认权限666 -rw-rw-rw-  ; 目录默认权限777 drwxrwxrwx</p>
<p>  建立档案时：(-rw-rw-rw-) - (—–w–w-) ==&gt; -rw-r–r–</p>
<p>  建立目录时：(drwxrwxrwx) - (d—-w–w-) ==&gt; drwxr-xr-x</p>
<p>umask 为 003 ，所以拿掉的权限为 ——–wx，</p>
<p>因此：</p>
<p>档案： (-rw-rw-rw-) - (——–wx) = -rw-rw-r–</p>
<p>目录： (drwxrwxrwx) - (——–wx) = drwxrwxr–</p>
<p>先将umask转换成rwx符号，用符号相减，不能用666-003=663=rw-rw-wx,不对。</p>
<p><strong>档案的隐藏属性 –</strong>在Ext2/Ext3 的文件系统中</p>
<p><strong>chattr</strong></p>
<p> +  ：增加某一个特殊参数，其他原本存在参数则不动。</p>
<p> -  ：移除某一个特殊参数，其他原本存在参数则不动。</p>
<p> =  ：设定一定，且仅有后面接的参数</p>
<p> a  ：当设定 a 之后，这个档案将只能增加数据，而不能删除也不能修改数据，只有 root才能设定这个属性。</p>
<p>  i  ：这个 i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法写入或新增资料！』对于系统安全性有相当大的帮助！只有 root 能设定    此属性。</p>
<p>>chattr +i attrtest</p>
<p>>chattr -i  attrtest</p>
<p><strong>lsattr (显示档案隐藏属性)</strong></p>
<blockquote>
<p>-a ：将隐藏文件的属性也秀出来；</p>
<p>-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；</p>
<p>-R ：连同子目录的数据也一并列出来！</p>
</blockquote>
<p>> chattr +aij attrtest</p>
<p>>lsattr attrtest</p>
<p>—-ia—j— attrtest</p>
<p><strong>档案特殊权限： SUID, SGID, SBIT</strong></p>
<p><strong>Set UID（档案，不能是shell script 和目录）</strong></p>
<p>s 这个标志出现在档案拥有者的 x 权限上时，为Set UID,简称为SUID的特殊权限。</p>
<p>-rw<strong>s</strong>r-xr-x 1 root root 22984 Jan 7 2007 /usr/bin/passwd</p>
<p>SUID作用：</p>
<blockquote>
<p>  SUID 权限仅对二进制程序(binary program)有效；</p>
<p>  执行者对于该程序需要具有 x 的可执行权限；</p>
<p>  本权限仅在执行该程序的过程中有效 (run-time)；</p>
<p>  执行者将具有该程序拥有者 (owner) 的权限。</p>
</blockquote>
<p>一般用户改密码</p>
<ol>
<li><p>/usr/bin/passwd为二进制程序。</p>
</li>
<li><p>vbird具有执行权限</p>
</li>
<li><p>vbird在执行passwd时</p>
</li>
</ol>
<p>4.具有该程序的拥有者root的权限，vbird暂时变成该程序拥有者root，故vbird执行passwd，相当于root执行passwd，passwd会修改/etc/shadow(该程序只能由root读写)的内容来修改用户的密码。</p>
<p><strong>Set GID</strong></p>
<p>s 在群组的 x 时则称为 Set GID，SGID</p>
<p>-rwx–<strong>s</strong>–x 1 root slocate  23856 Mar 15 2007 /usr/bin/locate</p>
<p>-rw-r—–  1 root slocate 3175776 Sep 28 04:02 /var/lib/mlocate/mlocate.db  </p>
<p>对档案来说， SGID 有如下的功能：</p>
<p>  SGID 对二进制程序有用；</p>
<p>  程序执行者对于该程序来说，需具备 x的权限；</p>
<p>  执行者在执行的过程中将会获得该程序群组的支持！变为群组的一员。</p>
<p>vbird对locate这个二进制程序有执行权限，故执行时，获得群组支持，暂时成为slocate一员，能够读取mlocate.db的内容。</p>
<p>对目录设定了 SGID 的权限后，他将具有如下的功能：</p>
<p>  用户若对于此目录具有 r 与x 的权限时，该用户能够进入此目录；</p>
<p>  用户在此目录下的有效群组(effective group)将会变成该目录的群组；</p>
<p>  用途：若用户在此目录下具有 w 的权限(可以新建档案)，则使用者所建立的新档案，该新档案的群组与此目录的群组相同。</p>
<p>auser（群组agroup，project）buser(群组bgroup,project) 在devp目录下（drwxrwx— 2 root project）,目录未加SGID时，auser在devp内新建文件</p>
<p>-rw-rw-r– 1 auser agroup 0 Sep 29 22:46 abcd，此文件buser只能删除不能编辑，加上SGID后，当user新建文件时</p>
<p>-rw-rw-r– 1 auser project  0 Sep 29 22:53 1234  群组变为devp的群组project,由于两人都属于project群组,umask为002，所以两人可以互相修改对方的文件。</p>
<p><strong>Sticky Bit（只对目录有效）</strong></p>
<p>SBIT 对于目录的作用是：</p>
<p> 当用户对于此目录具有 w, x 权限，亦即具有写入的权限时；</p>
<p>  当用户在该目录下建立档案或目录时，仅有自己与 root 才有权力删除该档案</p>
<p>换句话说：当甲这个用户于 A 目录是具有群组或其他人的身份，并且拥有该目录 w 的权限， 这表示『甲用户对该目录内任何人建立的目录活档案均可进行 “删除/更名/搬移” 等动作。』 不过，如果将 A 目录加上了 SBIT 得权限项目时， 则甲只能够针对自己建立的档案或目录进行删除/更名/移动等动作，而无法删除他人的案。</p>
<p> 举例来说，我们的 /tmp 本身的权限是『drwxrwxrw<strong>t</strong>』， 在这样的权限内容下，任何人都可以在/tmp 内新增、修改档案，但仅有该档案/目录建立者与 root 能够删除自己的目录或档案。没有t时，对目录拥有w权限，能删目录下的全部档案，加上t后，自己只能删自己的，不能删别人的。</p>
<p><strong>4 为 SUID 2 为 SGID 1 为 SBIT</strong></p>
<p> >chmod 4755 test</p>
<p>-rwsr-xr-x 1 root root 0 Sep 29 03:06 test  加入SUID</p>
<p>>chmod 6755 test</p>
<p>-rwsr-sr-x 1 root root 0 Sep 29 03:06 test  加入SUID/SGID</p>
<p>>chmod 1755 test</p>
<p>-rwxr-xr-t 1 root root 0 Sep 29 03:06 test  加入SBIT</p>
<p>>chmod 7666</p>
<p>-rwSrwSrwT 1 root root 0 Sep 29 03:06 test  加入空的SUID/SGID</p>
<p>7666,没有执行权限了，只有rw权限，拥有者都不能执行，故没有特殊权限了</p>
<p>>chmod u=rwxs,go=x test -rws–x–x 1 root root 0 Aug 18 23:47 test&gt; chmod g+s,o+t test -rws–s–t 1 root root 0 Aug 18 23:47 test</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>正规档案（regular file） （-）</p>
<p>   文本文档(ASCII)</p>
<p>   二进制文件(binary)</p>
<p>   数据格式文件(data)</p>
<p>目录（directory）（d）<br>链接档（link）（l）<br>设备与装置文件（device）</p>
<p>   区块设备（b）</p>
<p>   字符设备（c）</p>
<p>资料接口文件（sockets）（s）</p>
<p>数据输送文件（FIFO,pipe）（p）</p>
<p>有五个目录不可与根目录放在不同的 partition，分别为/etc, /bin, /lib, /dev, /sbin 五个。</p>
<p>Linux 档名的限制为：单一档案或目录的最大容讲文件名为 255 个字符；包含完整路径名称及目录(/) 之完整档名为 4096 个字符</p>
<p> FHS 订定出来的四种目彔特色为： shareable, unshareable, static, variable 等四类；<br> FHS 所定义的三层主目彔为： /, /var, /usr 三层而已；</p>
<h3 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h3><p>cd(Change Directory)  </p>
<p>​    cd ~  =  cd  进入家目录</p>
<p>​    cd -  进入上一工作目录</p>
<p>pwd(Print Working Directory )</p>
<p>   pwd  -P  ：显示出确实的路径，而非使用链接 (link) 路径。</p>
<p>mkdir</p>
<p>​    mkdir -p test1/test2/test3/test4  连续建立子目录。</p>
<p>​    mkdir -m 711 test2             建立711的test2目录，不挂吧umask。 </p>
<p>rmdir</p>
<p>​    rmdir  /test4  仅能删除空目录</p>
<p>​    </p>
<p> PATH=”$PATH”:/root    将/root加入到PATH中</p>
<p>-————————</p>
<h3 id="档案相关命令"><a href="#档案相关命令" class="headerlink" title="档案相关命令"></a>档案相关命令</h3><p><strong>ls</strong></p>
<p>  -a：显示隐藏文件和 .  ..目录</p>
<p>  -l ：长数据串输出，包括档案的属性和权限</p>
<p>  -d : 仅列出目录本身，而不是列出目录内的癿档案数据</p>
<p>  -h : 将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来；</p>
<p>  -n : 列出 UID  与 GID 而非使用者与群组的名称 </p>
<p>  -i  :  列出 inode 号码。</p>
<p>  ls -al /tmp</p>
<p><strong>cp(copy)</strong></p>
<p>   -a : 相当于-pdr ，复制文件 的权限，子目录，和源文件一样。</p>
<p>   -d  ：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非档案本身；</p>
<p>   -f  ：为强制(force)的意思，若目标档案已经存在且无法开启，则移除后再尝试一次；</p>
<p>   -i  ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</p>
<p>   -l  ：进行硬式连结(hard link)的连结档建立，而非复制档案本身；</p>
<p>   -s  ：复制成为符号链接文件 (symbolic link)，亦即『忚捷方式』档案；</p>
<p>   -p  ：连同档案的属性一起复制过去，而非使用默认属性(备份常用)；</p>
<p>   -r  ：递归持续复制，用于目录复制行为；(常用)</p>
<p>cp -a /var/log/wtmp /tmp/vbird_wtmp</p>
<p>cp -r /etc/ /tmp  -r复制目录单权限改变，可用 -a备份</p>
<p>cp -s bashrc bashrc_slink  建立符号链接文件。</p>
<p>cp -l bashrc bashrc_hlink  建立硬式连接文件。</p>
<p><strong>rm(remove)</strong></p>
<p>   -f 强制。</p>
<p>   -i 交互提示，需要确认。</p>
<p>   -r 递归删除，删除目录。</p>
<p>rmdir  /tmp/etc rmdir只能删除空目录</p>
<p>rm -r /tmp/etc 可以删除</p>
<p><strong>mv(move)</strong></p>
<p>   -f 强制。</p>
<p>   -i 交互提示，需要确认。</p>
<p>mv file1 file2 dir1 将file1 file2 移动到dir1中</p>
<p>mv dir1  dir2 改名</p>
<p>-————————————————————————————</p>
<h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><p><strong>cat(concatenate)</strong></p>
<p>  -A 显示全部特殊符号</p>
<p>  -n 显示行号 </p>
<p>  -b  显示行号，空白行不加</p>
<p>cat  -n /etc/issue</p>
<p><strong>tac  –将内容反序显示，最后一行按第一行显示</strong></p>
<p><strong>nl</strong> </p>
<p><strong>more</strong></p>
<p>   对管线不能向前翻页</p>
<p><strong>less</strong>  </p>
<p>   可以前后翻页</p>
<p><strong>head</strong></p>
<p>   默认显示前10行</p>
<p>head -n  20 /etc/man.config   显示前20行</p>
<p>head -n -100 /etc/man.config 后面的100行不显示</p>
<p><strong>tail</strong> </p>
<p>  默认显示后10行</p>
<p>tail -n  20   /etc/ man.config  显示后面的20行</p>
<p>tail -n +100  /etc/man.config  前面的100行不显示</p>
<p>head -n 20 /etc/man.config|tail -n 10  显示10-20行</p>
<p><strong>od</strong></p>
<p><strong>modification time (mtime)： 档案内容改变时间。默认
</strong></p>
<p><strong>status time (ctime)： 权限或属性被改变时间
</strong></p>
<p><strong>access time (atime)：档案被访问时间</strong></p>
<p>ll bashrc; ll –time=atime bashrc; ll –time=ctime bashrc 显示bashrc的三个时间</p>
<p><strong>touch bbb 建立一个BBB空档案</strong></p>
<p><strong>touch -t  1401010709 bashrc  将bashrc时间改为2014-01-01 07:09  mtime和atime改变，ctime为当前时间。</strong></p>
<p><strong>file 查看文件类型</strong></p>
<p><strong>which 二进制命令  按PATH路径进行搜索 命令</strong></p>
<p>  -a将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到得命令名称</p>
<p><strong>whereis 档案或目录  搜索文件 在文件索引数据库中</strong></p>
<p><strong>locate  文件名</strong></p>
<blockquote>
<p>-i  ：忽略大小写的差异；</p>
<p>-r  ：后面可接正则表示法的显示方式</p>
</blockquote>
<p>搜索 /var/lib/mlocate数据库 可用updatedb指令更新数据。</p>
<p><strong>find（直接查找硬盘）</strong></p>
<p>find /var -mtime -4  4天内更改的文件（含四天本身）</p>
<p>find /var -mtime +4 4天前更改的文件（不含四天本身）</p>
<p>find /var -mtime  4  4天前的那一天更改的文件</p>
<p>find / -mtime 0   24小时内更改的文件</p>
<p>find /etc -newer /etc/passwd</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/文件系统/9608dc1a-b8cf-4deb-bb92-25093864d1b7.png" alt="img"></p>
<p>find /var  -uid n</p>
<p>find /var  -gid n</p>
<p>find /var  -user  vbird       find /var  -nouser</p>
<p>find /var  -group  ugroup    find /var  -nogroup   </p>
<p>find / -name passwd</p>
<p>find / -size  +50k   find / -size  -50c   c为byte</p>
<p>find /var -type s   一般正规档案 (f),装置档案 (b, c), 目录 (d), 连结档 (l), socket (s),及 FIFO (p) 等属性。</p>
<p>find / -perm 4755 根目录下权限等于 -rwsr-xr-x的文件</p>
<p>find / -perm -0744 根目录下权限大于-rwsr-xr-x的文件，即全部囊括-rwsr-xr-x   –最小权限</p>
<p>find / -perm +7000根目录下包含任意—s–s–t的文件，即只要含有 s 或 t 的就列出 –最大权限</p>
<p>find / -perm -7000 根目录下包含—s–s–t所有三个特殊权限的文件</p>
<p>find / -perm +7000 -exec ls -l {} \;</p>
<p>find /etc -size +50k -a ! -user root -type f -exec ls -l {} \   -a=and</p>
<p>find /etc -size +1500k -o -size 0                       -o=or</p>
<p>find /etc -name ‘<em>httpd</em>‘</p>
<p>  superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</p>
<p>  inode：记录档案的属性，一个档案占用一个 inode，同时记录此档案的数据所在的 block 号码；</p>
<p>  block：实际记录档案的内容，若档案太大时，会占用多个 block 。 </p>
<p>linux通过VFS((Virtual Filesystem Switch)进行管理和读取各个 partition 上头的 filesystem。</p>
<p><strong>df  –查询superblock</strong></p>
<p>  -a  ：列出所有的文件系统，包括系统特有的 /proc（内存里程序） 等文件系统；  /dev/shm为内存虚拟的磁盘空间。</p>
<p>  -h  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</p>
<p>  -T  ：连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</p>
<p>  -i  ：不用硬盘容量，而以 inode的数量来显示</p>
<p>>df -ahT</p>
<p>>df -i</p>
<p><strong>du</strong></p>
<p>  -a  ：列出所有的档案与目录容量，因为默认仅统计目录底下的档案量而已。</p>
<p>  -h  ：以人们较易读的容量格式 (G/M) 显示；<br>   -s  ：列出总量而已，而不列出每个各别得目录占用容量；</p>
<p>   -S  ：不包括子目录下得总计，不 -s 有点差别。</p>
<p>>du -ah</p>
<p><strong>ln</strong>   详见P260</p>
<p>hard link :目录a指向数据，新增一个目录b指向a链接的数据。b直接访问数据。</p>
<p>soft  link : 目录a指向数据，新增一个目录b指向a。通过a访问数据。</p>
<p>>ln passwd passwd-hd</p>
<p>>ln -s passwd passwd-so   加s为软连接，不加默认为硬链接</p>
<p>> ls -li passwd*</p>
<p>586361 -rw-r–r– 2 root root 1945 Sep 29 02:21 passwd</p>
<p>586361 -rw-r–r– 2 root root 1945 Sep 29 02:21 passwd-hd</p>
<p>586401 lrwxrwxrwx 1 root root  6 Oct 22 14:18 passwd-so -&gt; passwd</p>
<p><strong>fdisk  （分区命令）</strong></p>
<p>   -l 显示分区表</p>
<p>fdisk 硬盘名（不是分区名）  不加硬盘名时扫描整个系统，显示全部硬盘的信息</p>
<p>>fdisk  /dev/hda</p>
<p>>partprobe  &lt;==强制让核心重新捉一次 partition table</p>
<p><strong>mkfs（</strong>make filesystem<strong>）（格式化命令）</strong></p>
<p>>mkfs -t ext3 /dev/hdc6</p>
<p><strong>mke2fs</strong> 不用，麻烦</p>
<p>>mke2fs -j -L “vbird_logical” -b 2048 -i 8192 /dev/hdc6</p>
<p><strong>mount</strong> 装置文件名 挂载点</p>
<p>mount /dev/hdc6   /mnt/hdc6  将/dev/hdc6挂载到/mnt/hdc6下</p>
<p>mount -l                    显示系统已挂载的文件系统 -l显示label name</p>
<p>mount -o remount,rw,auto /    重新挂载根目录</p>
<p><strong>umount</strong> 装置文件名或挂载点</p>
<p>umount /dev/hdc6 </p>
<p>umount /mnt/hdc6</p>
<p>dumpe2fs -h /dev/hdc6            查询label name</p>
<p>mount -L “vbird_logical” /mnt/hdc6  根据label name 进行挂载</p>
<p><strong>e2label</strong> 更改labelname</p>
<p>dumpe2fs -h /dev/hdc6            查询label name</p>
<p>e2label /dev/hdc6 “my_test”         将label name 改为my_test</p>
<p><strong>在/etc/fstab 中设定挂载文件系统</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>系统安装开关机流程</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%BC%80%E5%85%B3%E6%9C%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>磁盘的第一个扇区主要记录了两个重要的信息，分别是：</p>
<ul>
<li>主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes。</li>
<li>分割表(partition table)：记录整颗硬盘分割的状态，有 64 bytes。</li>
<li>由于分割表就只有 64 bytes 而已，最多只能容纳四笔分割的记录， 这四个分割的记录被称为主分区(Primary)和扩展分区(Extended)。</li>
<li>其实所谓的『分区』叧是针对那个 64 bytes的分割表进行设定而已！</li>
<li>硬盘的分割表仅能写入四组分割信息盘默认</li>
<li>这四组分割信息我们称为主(Primary)和扩展(Extended)分区</li>
<li>分区的最小单位为磁柱(cylinder)</li>
<li>当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分割槽进行数据的处理</li>
<li>主分区和扩展分区最多可以有四笔(硬盘的限制)</li>
<li>扩展分区最多只能有一个(操作系统的限制)</li>
<li>逻辑分区（Logical）是由扩展分区持续切割出来的分割槽；</li>
<li>能够被格式化后，作为数据存取的分割槽为主分区和逻辑分区。扩展分区无法格式化；</li>
<li>逻辑分区数量依操作系统而不同，在 Linux 系统中，IDE 硬盘最多有 59 个逻辑分区(5 号到63 号)， SATA 硬盘则有 11 个逻辑分区(5 号到 15 号)。 </li>
</ul>
<h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a><strong>开机流程</strong></h3><p>BIOS（加载CMOS中存储信息，INT13中断）——&gt;MBR(包含boot loader)——&gt;开机管理程序（boot loader）——&gt;kernal(/boot/vmlinuz)+initrd( Initial RAM Disk /boot/initrd)——&gt;/sbin/init(设置/etc/inittab)</p>
<ol>
<li>grub可以访问磁盘，加载kernal和intrd。</li>
<li>在kernal访问磁盘时，如果是非IDE接口的例如SATA接口，那么kernal没有硬盘驱动，kernal无法识别和访问SATA 磁盘。但是 SATA 的驱动程序在磁盘中的 /lib/modules 内，你根本无法访问磁盘又怎么读取到 /lib/modules/ 内的驱动程序呢。</li>
</ol>
<p>虚拟文件系统 (Initial RAM Disk) 一般使用的档名为 /boot/initrd ，这个档案的特色是，他也能够透过 boot loader 来加载到内存中，然后这个档案会被解压缩并且在内存当中仿真成一个根目录， 且此仿真在内存当中的文件系统能够提供一支可执行的程序，透过该程序来加载开机过程中所最需要的核心模块， 通常这些模块就是 USB, RAID, LVM, SCSI 等文件系统与磁盘接口的驱动程序啦。</p>
<p>一般来说，需要 initrd 的时刻为：</p>
<ul>
<li>根目录所在磁盘为 SATA、USB 或 SCSI 等连接接口；</li>
<li>根目录所在文件系统为 LVM, RAID 等特殊格式；</li>
<li>根目录所在文件系统为非传统 Linux 认识的文件系统时；</li>
<li>其他必须要在核心加载时提供的模块。 </li>
</ul>
<h4 id="init执行流程"><a href="#init执行流程" class="headerlink" title="init执行流程"></a><strong>init执行流程</strong></h4><ol>
<li>先取得 runlevel 亦即默认执行等级的相关等级 (以鸟哥的测试机为例，为 5 号)；</li>
<li>使用 /etc/rc.d/rc.sysinit 进行系统初始化，调用 /etc/sysconfig里面脚本，设定好整个系统环境，准备软件执行的作业环境 (如网络、时区等)。</li>
<li>根据/etc/rc.d/rc，根据运行级别调用/etc/rc.d/rc5.d来启动和停止服务 连接到/etc/rc.d/init.d里面的程序 ，然后调用/etc/rc.d/rc.local ， 启动自定义服务。</li>
<li>设定好 [ctrl]+[alt]+[del] 这组的组合键功能</li>
<li>设定不断电系统的 pf, pr 两种机制；</li>
<li>启动 mingetty 的六个终端机 (tty1 ~ tty6)</li>
<li>最终以 /etc/X11/perfdm -nodaemon 启动图形接口啦！<br>开机管理程序除了可以安装在 MBR 之外， 还可以安装在每个分割槽的启动扇区(boot sector)中，提供以下功能：</li>
<li>提供选单</li>
<li>载入核心档案</li>
<li>转交其他loader</li>
</ol>
<h4 id="GRUB启动的两个阶段"><a href="#GRUB启动的两个阶段" class="headerlink" title="GRUB启动的两个阶段"></a><strong>GRUB启动的两个阶段</strong></h4><p>MBR 是整个硬盘的第一个 sector 内的一个区块，整个大小也才 446 bytes 而已。 我们的 loader 功能这么强，光是程序代码于设定数据不止 446 bytes 。</p>
<p>为了解决这个问题，所以 Linux 将 boot loader 的程序代码执行与设定值加载分成两个阶段 (stage) 来执行：</p>
<ul>
<li>Stage 1：执行 boot loader 主程序：<br>第一阶段为执行 boot loader 的主程序，这个主程序必须要被安装在开机区，亦即是 MBR 或者<br>是 boot sector 。但如前所述，因为 MBR 实在太小了，所以，MBR 或 boot sector 通常仅安<br>装 boot loader 的最小主程序，并没有安装 loader 的相关配置文件；</li>
<li>Stage 2：主程序加载配置文件：<br>第二阶段为透过 boot loader 加载所有配置文件与相关的环境参数档案 (包括文件系统定义与主<br>要配置文件 /boot/menu.lst)， 一般来说，配置文件都在 /boot 底下。<br>重新启动 X Window 的快速按钮</li>
<li>直接注销，然后再重新登入卲可；</li>
<li>在 X 的画面中直接按下[Alt] + [Ctrl] + [Backspace]；</li>
</ul>
<p>X window 与文本模式的切换</p>
<ul>
<li>[Ctrl] + [Alt] + [F1] ~ [F6]  ：文字接口登入 tty1 ~ tty6 终端机；  run level 3</li>
<li>[Ctrl] + [Alt] + [F7]       ：图形接口桌面。                 run level 5</li>
</ul>
<p>etc/issue   显示文本模式登录前的系统提示信息</p>
<p>etc/inittab 显示运行模式</p>
<p>[vbird@www ~]$ date +%Y/%m/%d<br>2009/08/17</p>
<p>[vbird@www ~]$ date +%H:%M</p>
<p>17:04</p>
<p>Ctrl+c  中断当前执行的指令</p>
<p>Ctrl+z  是把当前的程序挂起，暂停执行这个程序。用fg返回执行的指令，当然，配合bg和fg命令进行前后台切换会非常方便。</p>
<p>Ctrl+d  =exit 退出当前用户</p>
<p>[Tab][Tab] 两个tab键显示有多少Linux命令</p>
<h3 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h3><ul>
<li>man date</li>
</ul>
<p>DATE(1)   NULL(4)</p>
<p>man man 可查询指令等级</p>
<p>代号                 代表内容</p>
<p> 1      用户在 shell 环境中可以操作的指令或可执行文件</p>
<p> 2      系统核心可呼叫的凼数或工具等</p>
<p> 3      一些常用的凼数(function)与凼式库(library)，大部分为 C 的凼式库(libc)</p>
<p> 4      装置档案的说明，通常在/dev 下的档案</p>
<p> 5      配置文件或者是某些档案的格式</p>
<p> 6      游戏(games)</p>
<p> 7      惯例与协议等，例如 Linux 文件系统、网络协议、ASCII code 等等的说明</p>
<p> 8      系统管理员可用的管理指令</p>
<p> 9      跟 kernel 有关的文件</p>
<p>指令查找：</p>
<p>man -f man= whatis man 查找指令名为man的或包含man指令 。whatis指令需建立whatis数据库 makewhatis(无空格)</p>
<p>man -k man=apropos man 查找命令的描述信息中含有man的指令。</p>
<ul>
<li>info date</li>
<li>/usr/share/doc</li>
</ul>
<p>nano vim 编辑器</p>
<h3 id="关机步骤"><a href="#关机步骤" class="headerlink" title="关机步骤"></a>关机步骤</h3><ol>
<li>查看状态<br>who 谁在线<br>netstat -a 网络状态<br>ps aux  进程状态</li>
<li>sync  内存回写硬盘</li>
<li>shutdown -h now 立刻关机<br> shutdown -h 20:35 在20:35关机<br> shutdown -h +10  ‘I will shutdown after 10 mins’= shutdown -h 10  ‘I will shutdown after 10 mins<br> shutdown -r now  立刻重启<br> shutdown -k now ‘This system will reboot’ 发出警告<br> reboot   重启<br> halt     关机<br> poweroff 关机<br> init 0    关机<br> init 6    重启</li>
</ol>
<h3 id="RUN-LEVEL"><a href="#RUN-LEVEL" class="headerlink" title="RUN LEVEL"></a>RUN LEVEL</h3><ul>
<li>0 - halt (系统直接关机)</li>
<li>1 - single user mode (单人维护模式，用在系统出问题时的维护)</li>
<li>2 - Multi-user, without NFS (类似底下的 runlevel 3，但无 NFS 服务)</li>
<li>3 - Full multi-user mode (完整含有网络功能的纯文本模式)</li>
<li>4 - unused (系统保留功能)</li>
<li>5 - X11 (与runlevel 3 类似，但加载使用 X Window)</li>
<li>6 - reboot (重新启动)</li>
</ul>
<h3 id="CentOS7-更新"><a href="#CentOS7-更新" class="headerlink" title="CentOS7 更新"></a>CentOS7 更新</h3><p><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7429718.png" alt="img"><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7450031.png" alt="img"><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7469375.png" alt="img"><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7529968.png" alt="img"></p>
<p>更新驱动模块之间的相依性</p>
<p>modep [-A] 不加任何参数时, depmod 会主动的去分析目前核心的模块,并且重新写入/lib/modules/$(uname -r)/modules.dep 当中。</p>
<p>​      若加入 -A 参数时,则depmod会去搜寻比 modules.dep 内还要新的模块,如果真找到新模块,才会更新。</p>
<p>modprobe [-r]驱动名  自动搜寻modules.dep，加载驱动,删除驱动</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>系统服务和日志分析</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>service  系统提供的一些基本服务（不管是系统本身还是网络方面）  </p>
<p>daemon 提供服务的程序</p>
<p>crond程序为daemon，启动后提供 循环型例行性工作排程服务 (service)。</p>
<p>daemon分类</p>
<p>1.<strong>stand_alone</strong>  自行启动而不必透过其他机制的管理，常驻内存中提供服务，响应速度快。常见有WWW 的 daemon (httpd) FTP 的 daemon (vsftpd)</p>
<p>2.<strong>super daemon</strong> 服务的启动方式是藉由一个统一的 daemon 来负责唤起服务，被称为 super daemon 。 早期的 super daemon 是 inetd 这一个，后来则被 xinetd 所取代了。当没有客户端的要求时，各项服务都是未启动的情况，等到有来自客户端的要求时， super daemon 才唤醒相对应的服务。 当客户端的要求结束后，被唤醒的这个服务也会关闭并释放系统资源。具有安全控管的机制，不会一直占用系统资源， 服务的反应时间会比较慢一些。分为multi-threaded (多重线程)和single-threaded (单个线程)处理模式，常见有telnet。</p>
<p><strong>stand alone 启动</strong></p>
<p>启动的脚本放置到 /etc/init.d/ 这个目录中</p>
<p>直接启动<br>>/etc/init.d/atd  [start|stop|status|restart]</p>
<p>service命令启动</p>
<p>>service atd (start|stop|restart|)<br>> service –status-all  –显示所有服务的状态</p>
<p><strong>super daemon 启动</strong></p>
<p>super daemon 的配置文件在 /etc/xinetd.d/* 内<br><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/f41f4be5-475b-46fe-b882-783b16693cdf.png" alt="img"></p>
<p><strong>chkconfig</strong><br>透过 chkconfig 来管理 super daemon 的服务喔！另外， chkconfig 仅是设定开机时预设会启动的服务而已， 所以该服务目前的状态如何是不知道的。<br><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/554fa55a-2a1f-4a49-a890-5a06993d39ce.png" alt="img"></p>
<hr>
<p>系统一般日志保存目录：/var/log/*</p>
<p>日志服务相关daemon:</p>
<blockquote>
<p>  syslogd：主要登录系统与网络等服务的讯息；</p>
<p>  klogd：主要登录核心产生的各项信息；</p>
<p>  logrotate：主要在进行登录文件的轮替功能；</p>
</blockquote>
<p><strong>syslogd ：记录登录文件的服务</strong></p>
<p>启动： /etc/init.d/syslog restart</p>
<p>syslogd配置文件：/etc/syslog.conf   主要设置什么服务在大于什么等级记录日志到什么地方 利用<strong>man 3 syslog</strong>查询相关信息</p>
<p>内容：mail.info    /var/log/maillog_info  mail  服务产生的大于等于 info 等级的讯息，都记录到 # /var/log/maillog_info 档案中的意思。</p>
<p><strong>服务名称</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/81ea47fc-f5dc-462b-9361-74aef330f4e7.png" alt="img"></p>
<p><strong>讯息等级</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/087fc452-0371-4ba2-b13d-d2cec23d2cc3.png" alt="img"></p>
<p><strong>logrotate：日志轮替（将原日志建成一个旧档，新建一个空的档案给日志服务使用）</strong></p>
<p>syslog 利用的是 super daemon 的方式来启动的， 当有需求的时候立刻就会被执行的。</p>
<p>logrotate 却是在规定的时间到了之后才来进行登录档的轮替， 所以logrotate 程序是挂在 cron 底下得。/etc/cron.daily/logrotate</p>
<p>配置文件</p>
<p>/etc/logrotate.conf  主要配置文件，一般通用配置<br>/etc/logrotate.d/    被logrotate.conf调用执行，对特定文件的配置</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/def3861c-45c1-4225-a32f-a92d8bd9516d.png" alt="img"><br>o prerotate：在启动 logrotate 之前进行的指令，例如修改登录文件的属性等动作；<br>o postrotate：在做完 logrotate 之后启动的指令，例如重新启动 (kill -HUP) 某个服务！</p>
<p>o Prerotate 与 postrotate 对于已加上特殊属性的档案处理上面，是相当重要的执行程序！</p>
<p><strong>logrotate [-vf] logfile</strong></p>
<p>-v ：启动显示模式，会显示 logrotate 运作的过程喔！<br>-f ：不论是否符合配置文件的数据，强制每个登录档都进行rotate的动作！<br>>logrotate -v /etc/logrotate.conf</p>
<p>建立自己的日志记录文件</p>
<p>> chattr +a /var/log/admin.log  –只能增加，不能删除和移动，改名等。</p>
<p>>vi /etc/logrotate.d/admin</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#This configuration is from zhangyf 2014/2/12</span><br><span class="line">/var/log/admin.log &#123;</span><br><span class="line">	monthly          &lt;==每个月进行一次</span><br><span class="line">	size=10M         &lt;==档案容量大于 10M 则开始处置</span><br><span class="line">	rotate 5         &lt;==保留五个！</span><br><span class="line">	compress         &lt;==进行压缩工作！</span><br><span class="line">	sharedscripts</span><br><span class="line">	prerotate</span><br><span class="line">	         /usr/bin/chattr -a /var/log/admin.log</span><br><span class="line">	endscript</span><br><span class="line">	sharedscripts</span><br><span class="line">	postrotate</span><br><span class="line">	        /usr/bin/killall -HUP syslogd</span><br><span class="line">	       /usr/bin/chattr +a /var/log/admin.log</span><br><span class="line">	endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络防火墙SSH</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99SSH/</url>
    <content><![CDATA[<p>观察主记路由 route</p>
<p>>route [-n]   n ： 将主机名以 IP 的方式显示</p>
<p>>ifconfig eth0 观察本机的网卡卡号</p>
<p>取得本机的 ARP 表格内的 IP/MAC 对应数据</p>
<p>>arp [-n]     n ： 将主机名以 IP 的方式显示</p>
<p>   /etc/services这个档案则是记录架构在 TCP/IP 上面的总总协议，包括 http, ftp, ssh, telnet 等等服务所定义的 port number ，都是这个档案所规划出来的。如果你想要自定义一个新的协议与 port 的对应，就得要改这个档案了；   /etc/protocols这个档案则是在定义出 IP 封包协议的相关数据，包括 ICMP/TCP/UDP 这方面的封包协议的定义等。<br>ifup eth0 (ifdown eth0)启动或者是关闭某张网络接口。可以透过这个简单的 script 来处理喔！ 这两个 script 会主动到 /etc/sysconfig/network-scripts/ 目录下，  读取适当的配置文件来处理啊！ (例如 ifcfg-eth0)。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/9073b2b7-9c21-4541-a505-1bf85f949743.png" alt="img"></p>
<h2 id="固定IP设置"><a href="#固定IP设置" class="headerlink" title="固定IP设置"></a>固定IP设置</h2><p>\1.   IP/Netmask/Gateway 的设定、启动与观察</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/572e274c-a40c-44a6-8705-a9f8daf2dedd.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/71031518-480c-40fb-b966-5216c40056fc.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/ea13b29f-b3cc-40b1-b632-1b5ec8b88ed4.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/e229784f-e336-48a6-9992-f4799d6f2def.png" alt="img"></p>
<p>\2.   DNS 服务器的 IP 设定与观察</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/1b25a14d-cffd-4142-9002-4f94f209c596.jpg" alt="img"></p>
<p>\3.   主机名的修改、启动与观察（修改完毕之后要顺利启动的话，得要重新启动才可以）</p>
<h2 id><a href="#" class="headerlink" title></a><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/1520c456-79db-458c-87cc-33178ab29bec.jpg" alt="img"></h2><h2 id="DHCP设置"><a href="#DHCP设置" class="headerlink" title="DHCP设置"></a>DHCP设置</h2><p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/5f15a44b-2f4e-4c5d-804b-a6920f72bcf0.jpg" alt="img"></p>
<p><strong>宽带直连</strong></p>
<p><strong>ADSL拨接上网</strong></p>
<p>  安装rp-pppoe</p>
<p>  执行pppoe-setup设置账号密码</p>
<p><strong>WLAN无线网络</strong></p>
<p>1.察看模块与相对应的网卡代号</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/4ccfb7a6-499f-432d-adeb-b1ea97c116b3.jpg" alt="img"></p>
<p>2.利用 iwlist 侦测 AP</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/6a629a0d-cc0c-4d19-9b51-16b704768584.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/b6ce3708-6215-407f-933a-32a4655a12ec.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/aaffeded-8298-41ed-9786-a580316567c8.png" alt="img"></p>
<p>3.设定网络卡配置文件 (ifcfg-ethn)</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/a7eb64e1-2beb-40b8-a412-13c9df45bcb1.png" alt="img"></p>
<p>4.启动与观察无线网卡</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/3355020d-73ff-4b72-be32-9d0f555a0d0e.png" alt="img"></p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p><strong>&gt;ifconfig {interface} {up|down} &lt;== 观察与启动接口</strong></p>
<p><strong>&gt;ifconfig interface {options}    &lt;== 设定与修改接口</strong></p>
<p>选项与参数：</p>
<p>interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等</p>
<p>options  ：可以接的参数，包括如下：</p>
<blockquote>
<p>up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)</p>
<p>mtu  ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)</p>
<p>netmask  ：就是子屏蔽网络；</p>
<p>broadcast：就是广播地址啊！</p>
</blockquote>
<p>>ifconfig   观察所有的网络接口</p>
<p>>ifconfig eth0 192.168.100.100  netmask 255.255.255.128  mtu 800  设定eth0网络卡参数</p>
<p>>ifconfig eth0:0 192.168.50.50   为eth0设定第二个IP</p>
<p>>ifconfig eth0:0 down          关掉 eth0:0 这个界面。那如果想用默认值启动 eth1：『ifconfig eth1 up』即可达成</p>
<h3 id="ifup-ifdown"><a href="#ifup-ifdown" class="headerlink" title="ifup, ifdown"></a>ifup, ifdown</h3><p><strong>&gt;ifup|ifdown {interface}</strong></p>
<p>两支程序其实是 script 而已，他会直接到/etc/sysconfig/network-scripts 目录下搜寻对应的ifcfg-ethX 配置文件。</p>
<p>例如 ifup eth0 时，他会找出 ifcfg-eth0 这个档案的内容，然后来加以设定。</p>
<p>注意：如果以 ifconfig eth0 …. 来设定或者是修改了网络接口后， 那就无法再以ifdown eth0 的方式来关闭了！</p>
<p>因为 ifdown 会分析比对目前的网络参数与ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。</p>
<p><strong>因此，使用 ifconfig 修改完毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔！</strong></p>
<h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p><strong>route [-nee]</strong></p>
<p>-n  ：不要使用通讯协议或主机名，直接使用 IP 或 port number；-ee ：使用更详细的信息来显示<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/1f01ede4-5026-41dd-824d-daaf66bdda51.png" alt="img"><br>Flags：总共有多个旗标，代表的意义如下：o   U (route is up)：该路由是启动的；o   H (target is a host)：目标是一部主机 (IP) 而非网域；o   G (use gateway)：需要透过外部的主机 (gateway) 来转递封包； o   R (reinstate route for dynamic routing)：使用动态路由时，恢复路由信息的旗标；o   D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由o   M (modified from routing daemon or redirect)：路由已经被修改了；o   ! (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！</p>
<p>Metric 距离、跳数。暂无用。</p>
<p>Ref  不用管，恒为0。</p>
<p>Use   该路由被使用的次数，可以粗略估计通向指定网络地址的网络流量。</p>
<p><strong>route add [-net|-host] [网域或主机] netmask [mask] [gw|dev]</strong></p>
<p><strong>route del  [-net|-host] [网域或主机] netmask [mask] [gw|dev]</strong></p>
<p>>route  del  -net 169.254.0.0   netmask 255.255.0.0   dev eth0  删除路由</p>
<p>>route add  -net 192.168.100.0 netmask 255.255.255.0 dev eth0 增加路由</p>
<p>>route add default gw 192.168.1.250  设置默认路由</p>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p><strong>ip [-s] link show &lt;== 单纯的查阅该装置相关的信息，**</strong>-s ：显示出该装置的统计数据(statistics)，例如总接受封包数等<strong>**ip link set [device] [动作与参数]</strong>     set ：可以开始设定项目， device 指的是 eth0, eth1 等等界面代号；</p>
<blockquote>
<p>up|down  ：启动 (up) 或关闭 (down) 某个接口，其他参数使用默认的以太网络；</p>
<p>address  ：如果这个装置可以更改 MAC 的话，用这个参数修改！</p>
<p>name  ：给予这个装置一个特殊的名字；</p>
<p>mtu  ：就是最大传输单元啊！</p>
</blockquote>
<p>>ip link set eth0 up|down</p>
<p>更改网卡名称 mac地址</p>
<p>> ip link set eth0 down &lt;==关闭界面</p>
<p>> ip link set eth0 name vbird &lt;==重新设定</p>
<p>> ip link show &lt;==观察一下</p>
<p>> ip link set vbird name eth0 &lt;==界面改回来</p>
<p>> ip link set eth0 address aa:aa:aa:aa:aa:aa</p>
<p><strong>ip address show &lt;==就是查阅 IP 参数啊！</strong></p>
<p><strong>ip address [add|del] [IP 参数] [dev 装置名] [相关参数]</strong></p>
<p>相关参数：</p>
<blockquote>
<p>broadcast：设定广播地址，如果设定值是 + 表示『让系统自动计算』<br>label  ：亦即是这个装置的别名，例如 eth0:0 就是了！<br>scope  ：这个界面的领域，通常是这几个大类：<br> global ：允许来自所有来源的联机；预设为此。<br>site  ：仅支持 IPv6 ，仅允许本主机的联机；<br>link  ：仅允许本装置自我联机；<br>host  ：仅允许本主机内部的联机；</p>
</blockquote>
<p>>ip  address  add  192.168.50.50/24  broadcast +  dev eth0  label eth0:vbird</p>
<p>>ip  address  del  192.168.50.50/24  dev eth0</p>
<p><strong>ip route show &lt;==单纯的显示出路由的设定而已</strong></p>
<p><strong>ip route [add|del] [IP 或网域] [via gateway] [dev 装置]</strong></p>
<p>>ip route add 192.168.5.0/24  dev  eth0</p>
<p>>ip route add 192.168.10.0/24  via  192.168.5.100  dev  eth0</p>
<p>>ip route add default  via  192.168.1.254  dev  eth0</p>
<p>>ip route del  192.168.10.0/24</p>
<h3 id="dhclient"><a href="#dhclient" class="headerlink" title="dhclient"></a>dhclient</h3><p>>dhclient eth0  可以立刻叫我们的网络卡以 dhcp 协议去尝试取得 IP</p>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p><strong>ping [参数] IP</strong></p>
<p>-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；-n  ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此数值；-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；-W 数值：等待响应对方主机的秒数。-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：</p>
<blockquote>
<p>do  ：代表传送一个 DF (Don’t Fragment) 旗标，让封包不能重新拆包与打包；</p>
<p>dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包</p>
</blockquote>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/430a2387-882e-4aa9-acef-8d0d5683466e.png" alt="img"></p>
<p>如果你的主机与待侦测主机并不在同一个网域内，  那么 TTL 预设使用255 ，如果是同一个网域内，那么 TTL 预设则使用 64 。</p>
<p>找出MTU</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/38db0d85-bb97-4035-a1a1-249c51a29d7d.png" alt="img"></p>
<p>#!/bin/bash</p>
<p>for siteip in $(seq 1 254)</p>
<p>do</p>
<blockquote>
<p>site=”192.168.1.${siteip}”</p>
<p>ping -c1 -W1 ${site} &amp;&gt; /dev/null</p>
<p>if [ “$?” == “0” ]; then </p>
<p>  echo “$site is UP”</p>
<p>else</p>
<p>  echo “$site is DOWN”</p>
<p>fi</p>
</blockquote>
<p>done</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>traceroute [选项与参数] IP选项与参数：-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！-U ：使用 UDP 的 port <a href="tel:33434" target="_blank" rel="noopener">33434</a> 来进行侦测，这是预设的侦测协议；-I ：使用 ICMP 的方式来进行侦测； -T ：使用 TCP 来进行侦测，一般使用 port 80 测试-w ：若对方主机在几秒钟内没有回声就宣告不治…预设是 5 秒-p 埠号：若不想使用 UDP 与 TCP 的预设埠号来侦测，可在此改变埠号。-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了<br>-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个ppp，你可以使用 -i 来选择是 ppp0 还是 ppp1 啦！&gt;traceroute -n  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p>>traceroute -w 1 -n -T  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p><strong>host [-a] hostname [server]</strong> -a ：列出该主机详细的各项主机名设定数据<br>[server] ：可以使用非为 /etc/resolv.conf 的 DNS 服务器 IP 来查询。&gt;host <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 查询百度的服务器主机IP<strong>dig</strong>dig <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  查询百度的服务器主机IPiwlist  iwconfig无线设置命令,在设置无线网络时用过。telnet <strong>telnet [host|IP [port]]</strong><br>>telnet localhost 110<br>wgettcpdump封包撷取器<strong>tcpdump [-AennqX] [-i 接口] [-w 储存档名] [-c 次数] [-r 档案] [所欲撷取的封包数据格式]</strong>选项与参数：-A ：封包的内容以 ASCII 显示，通常用来捉取 WWW 的网页封包资料。-e ：使用资料连接层 (OSI 第二层) 的 MAC 封包数据来显示；-nn：直接以 IP 及 port number 显示，而非主机名与服务名称-q ：仅列出较为简短的封包信息，每一行的内容比较精简-X ：可以列出十六进制 (hex) 以及 ASCII 的封包内容，对于监听封包内容很有用-i  ：后面接要『监听』的网络接口，例如 eth0, lo, ppp0 等等的界面；-w ：如果你要将监听所得的封包数据储存下来，用这个参数就对了！后面接档名-r  ：从后面接的档案将封包数据读出来。那个『档案』是已经存在的档案，并且这个『档案』是由 -w 所制作出来的。-c  ：监听的封包数，如果没有这个参数， tcpdump 会持续不断的监听，直到使用者输入 [ctrl]-c 为止。</p>
<p>所欲撷取的封包数据格式：我们可以专门针对某些通讯协议或者是 IP 来源进行封包撷取， 那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有：</p>
<blockquote>
<p>‘host foo’, ‘host 127.0.0.1’ ：针对单部主机来进行封包撷取</p>
<p>‘net 192.168’ ：针对某个网域来进行封包的撷取；</p>
<p>‘src host 127.0.0.1’ ‘dst net 192.168’：同时加上来源(src)或目标(dst)限制</p>
<p>‘tcp port 21’：还可以针对通讯协议侦测，如 tcp, udp, arp, ether 等</p>
<p>还可以利用 and 与 or 来进行封包数据的整合显示呢！</p>
</blockquote>
<p>>tcpdump -i eth0 -nn</p>
<p>>tcpdump -i eth0 -nn  port 21</p>
<p>>tcpdump -i lo -nn -X  ‘port 21’</p>
<p>>tcpdump -i eth0 -nn ‘port 22 and src host 192.168.14.100’</p>
<h3 id="nc，netcat-接口监听"><a href="#nc，netcat-接口监听" class="headerlink" title="nc，netcat 接口监听"></a>nc，netcat 接口监听</h3><p><strong>nc [-lu] [IP|host] [port]</strong></p>
<p>-l ：作为监听之用，亦即开启一个 port 来监听用户的联机；-u ：不使用 TCP 而是使用 UDP 作为联机的封包状态 <img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/65ea43e2-e5ba-4e63-8cfc-78202b5b8c7a.png" alt="img"><br>server:<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/f1788bb8-dc26-4596-8817-744d3b358d83.png" alt="img"></p>
<p>client:<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/ef0bdf06-470b-4a92-a961-75b60c9381f4.png" alt="img">在客户端我们可以打入一些字，你会发现在服务器端会同时出现你输入的字眼吶！</p>
<p>端口与服务的启动/关闭及开机时状态设定1.最直接 kill -9 rpcbind  但是是强制关闭，会引起不确定因素。2.stand alone 方式服务<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/e2ae4e66-62c8-47cc-a373-5e9c24eb8102.png" alt="img"><br> rpc.statd 的启动脚本在：『rpm  -qc $(rpm  -qf $(which rpc.statd) ) | grep init』这样找，结果是在 /etc/rc.d/init.d/nfslock3.super daemon 方式服务要启动 telnet 首先必须要已经安装了 telnet 的服务器才行，先以 rpm 查询看看是否有安装 telnet-server『rpm -qa | grep telnet-server』<br>       如果没有安装的话，用『yum install telnet-server』安装；</p>
<ul>
<li>由于是 super daemon 控管，所以请编辑 /etc/xinetd.d/telnet 这个档案，将其中的『disable = yes』改成『disable = no』</li>
</ul>
<p>​     之后以『/etc/init.d/xinetd restart』重新启动 super daemon 吧！</p>
<ul>
<li>利用 netstat -tnlp 察看是否有启动 port 23 </li>
</ul>
<p><strong>将服务关闭，并设为开机不启动</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/941af9ae-ee2b-493b-9b37-65527f0cc782.png" alt="img"></p>
<hr>
<h3 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a><strong>防火墙</strong>：</h3><p>​      <strong>TCP Wrappers (程序控管) 通过**</strong>/etc/hosts.{allow|deny} 的设定方式，进行权限设定</p>
<p>​      <strong>Proxy (代理服务器）</strong></p>
<p>​      <strong>Netfilter (封包过滤机制)</strong> <strong>Netfilter 提供**</strong>了 iptables 这个软件来作为防火墙封包过滤的指令。</p>
<p>Linux 的 iptables 至少就有三个表格，包括管理本机进出的 filter 、管理后端主机 (防火墙内部的其他计算机) 的 nat 、管理特殊旗标使用的 mangle (较少使用 ) 常用的是本机的 filter 表格， 这也是默认表格啦<br>  filter (过滤器) ：主要跟进入 Linux 本机的封包有关，这个是预设的table 喔！</p>
<p>​     o  INPUT：主要与想要进入我们 Linux 本机的封包有关；</p>
<p>​     o  OUTPUT：主要与我们 Linux 本机所要送出的封包有关；</p>
<p>​    o  FORWARD：这个咚咚与 Linux 本机比较没有关系， 他可以『转递封包』到后端的计算机中，与下列 nat table 相关性较高。</p>
<p>  nat (地址转换) ：是 Network Address Translation 的缩写， 这个表格主要在进行来源与目的之 IP 或 port 的转换，与 Linux 本机较无关，主要与Linux 主机后的局域网络内计算机较有相关。</p>
<p>​     o  PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)</p>
<p>​    o  POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)</p>
<p>​     o  OUTPUT：与发送出去的封包有关</p>
<p>  mangle (破坏者) ：这个表格主要是与特殊的封包的路由旗标有关， 早期仅有 PREROUTING 及 OUTPUT 链，不过从 kernel 2.4.18 之后加入了 INPUT及FORWARD 链。 由于这个表格与特殊旗标相关性较高，所以像咱们这种单纯的环境当中，较少使用 mangle 这个表格。</p>
<p><strong>1.规则的观察与清除</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/7177f2fe-ee52-4c54-9b07-028616a45238.jpg" alt="9b983a51-8bdc-496e-b62d-357f05d50001.jpg"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/b8450685-cf84-4c07-b851-190d7684e4fe.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/05343c60-1e87-4f6b-9d04-f6ba42b39e76.jpg" alt="img"><br><strong>2.定义预设政策 (policy)</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/438112eb-7307-4ed4-a670-9ce84a8e00d7.jpg" alt="img"></p>
<p><strong>3.封包的基础比对：IP, 网域及接口装置</strong></p>
<p>iptables [-AI 链名] [-io 网络接口] [-p 协议] [-s 来源 IP/网域] [-d 目标 IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</p>
<p>选项与参数：</p>
<p>-AI 链名：针对某的链进行规则的 “插入” 或 “累加”</p>
<p>  -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，使用 -A 就可以加上第五条规则！</p>
<p>  -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。例如原本有四条规则，使用 -I 则该规则变成第一条，</p>
<p>​      而原本四条变成 2~5 号链 ：有INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。</p>
<p>-io 网络接口：设定封包进出的接口规范</p>
<p>  -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；</p>
<p>  -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；</p>
<p>  -p 协定：设定此规则适用于哪种封包格式，主要的封包格式有： tcp, udp, icmp 及 all 。</p>
<p>-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：</p>
<blockquote>
<p>IP  ：192.168.0.100</p>
<p>网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。</p>
<p>若规范为『不许』时，则加上 ! 即可，例如：</p>
<p>-s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；</p>
</blockquote>
<p>-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。</p>
<p>-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/702693c5-4944-4947-9f62-d46c5301caff.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/32d6e73a-09cd-44b5-846d-6fd9f251857e.png" alt="img"></p>
<p><strong>4.TCP, UDP 的规则比对：针对埠口设定
</strong></p>
<p>iptables [-AI 链] [-io 网络接口] [-p tcp,udp] [-s 来源 IP/网域] [–sport 埠口范围] [-d 目标 IP/网域] [–dport 埠口范围] -j [ACCEPT|DROP|REJECT] </p>
<p>选项与参数：–sport 埠口范围：限制来源的端口口号码，端口口号码可以是连续的，例如1024:65535–dport 埠口范围：限制目标的端口口号码。因为仅有 tcp 与 udp 封包具有埠口，因此你想要使用 –dport, –sport 时，得要加上 -p tcp 或 -p udp 的参数才会成功喔<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/bdc40c07-dbb5-49af-b3b0-6d1971f3c00d.png" alt="img"><br>只要来自 192.168.1.0/24 的 1024:65535 埠口的封包，且想要联机到本机的 ssh port 就予以抵挡：&gt;iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24  –sport 1024:65534 –dport ssh -j DROP</p>
<p>将来自任何地方来源 port 1:1023 的主动联机到本机端的 1:1023 联机丢弃</p>
<p>>iptables -A INPUT -i eth0 -p tcp –sport 1:1023 –dport 1:1023 –syn -j DROP </p>
<p><strong>5.iptables 外挂模块：mac 与 state</strong><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/77bcb250-b0fa-4961-9af2-420e559b741a.png" alt="img"></p>
<p>范例：只要已建立或相关封包就予以通过，只要是不合法封包就丢弃</p>
<p>> iptables -A INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT</p>
<p>> iptables -A INPUT -m state –state INVALID -j DROP</p>
<p>范例：针对局域网络内的 aa:bb:cc:dd:ee:ff 主机开放其联机</p>
<p>> iptables  -A INPUT  -m mac  –mac-source aa:bb:cc:dd:ee:ff -j ACCEPT</p>
<p>选项与参数：</p>
<p>–mac-source ：就是来源主机的 MAC 啦！</p>
<p><strong>6.ICMP 封包规则的比对：针对是否响应 ping 来设计</strong><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/6f057fe4-1127-4e5d-be61-a733e5101b2d.jpg" alt="img"></p>
<p><strong>7.简单的客户端防火墙设计与防火墙规则储存</strong><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/cb1dc68f-7931-4923-b7eb-6afb5df50a32.jpg" alt="img"></p>
<hr>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a><strong>SSH</strong></h3><p>SSH 是 Secure  SHell protocol 的简写 (安全的壳程序协议)，它可以透过数据封包加密技术，将等待传输的封包加密后再传输到网络上。取代了明码传输的telnet技术。<br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/3b4426d0-ad39-42ca-8dc7-8cf835a0a022.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/4becbb44-d79b-4b96-85c6-73ac4afb4c16.jpg" alt="img"></p>
<p>>ssh <a href="mailto:student@127.0.0.1" target="_blank" rel="noopener">student@127.0.0.1</a> find / &amp;&gt; ~/find1.log  执行后需要等待</p>
<p>>ssh -f <a href="mailto:student@127.0.0.1" target="_blank" rel="noopener">student@127.0.0.1</a> find / &amp;&gt; ~/find1.log  加上 -f 的参数可以将指令后台执行而立马断开联机</p>
<p>>ssh -o StrictHostKeyChecking=no root@localhost</p>
<p>>ssh -f root@some_IP shutdown -h now  不用等待关机后退出，直接断开连接。</p>
<h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p>模拟 FTP 的文件传输方式，使用 ssh 的通道 (port 22)，只是模拟成 FTP 与复制的动作而已。<br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/5a8f0d34-770e-4b00-a675-e34efb54e82d.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/8668cca1-18ca-4d8f-9c83-be542b0d34a7.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/e23af27d-6fc3-47e9-9f40-e9c3da21cdcc.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/000c8821-76fd-4457-8ee8-785a47548f0a.jpg" alt="img"></p>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>档案异地直接复制，通常使用 sftp 是因为可能不知道服务器上面有什么档名的档案存在，如果已经知道服务器上的档案档名了，  那么最简单的文件传输则是透过 scp 这个指令喔！最简单的 scp 用法如下：<br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/3f8cd937-351d-4890-8abe-6dde583910ab.png" alt="img"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解压缩</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>*.tar.gz    tar 程序打包的档案，其中并且经过 gzip的压缩</p>
<p>*.tar.bz2   tar 程序打包的档案，其中并且经过 bzip2 的压缩</p>
<p>gzip -v man.config 压缩 man.config 生成 man.config.gz,源文件没有了。</p>
<p>gzip -d man.config.gz 解压缩 man.config.gz </p>
<p>gzip -9 -c man.config &gt; man.config.gz  -9等级，1-9,1最快，9最慢 -c重定向</p>
<p>-—–<br>bzip2 -z  -k man.config   -z 压缩 -k 保留原文件</p>
<p>bzip2 -d man.config.bz2  -d解压缩</p>
<p>bzip2 -9 -c man.config &gt; man.config.bz2<br>-——</p>
<p>j代表bzip2软件 z代表gzip软件  c 创建 t 查询 x 解压</p>
<p>-p  ：保留备份数据癿原本权限不属性，常用于备份(-c)重要癿配置文件</p>
<p>-P (大写) ：保留绝对路径，亦即允讲备份数据中吨有根目录存在之意，一般不用；</p>
<p>–exclude=FILE 压缩式不包含FILE</p>
<p>bzip2</p>
<p>压缩：tar -jcv -f aa.tar.bz2  /usr</p>
<p>查询：tar -jtv -f aa.tar.bz2</p>
<p>解压缩：tar -jxv -f aa.tar.bz2 -C  /tmp</p>
<p><strong>gzip</strong></p>
<p><strong>压缩：tar -zcv -f  /root/aa.tar.gz  /etc    将/etc中文件压缩成/root下的aa.tar.gz</strong></p>
<p><strong>查询：tar -ztv -f aa.tar.gz</strong></p>
<p><strong>解压缩：tar -zxv -f aa.tar.gz  -C /tmp    将 aa.tar.gz解压到/tmp中</strong></p>
<p>打包</p>
<p>tar -cv -f /backup  /home /root /etc  将/home /root /etc打包到/backup  </p>
<p>tar -cvf - /etc|tar -xvf -              打包/etc复制到当前目录</p>
<p>dd if=”input_file” of=”out_file” bs=”block_size” count=”number” </p>
<p>bs默认为512 bytes（一个sector的大小）</p>
<p>dd  -if=/dev/zero  -of=/boot/testing.img  bs=1M  count=10</p>
<p>dd if=/etc/passwd of=/tmp/passwd.back 将 /etc/passwd 备份到 /tmp/passwd.back 当中</p>
<p>dump 可备份文件系统或单一目录，在备份目录时不能用level和-u更新时间</p>
<p>dd 可备份完整分区或磁盘，因为 dd 可读取磁盘的 sector 表面数据</p>
<p>cpio 为相当优秀的备份指令，不过必项要搭配类似 find 指令来读入欲备份的文件名数据，方可进行备份动作。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>账号管理和ACL权限和PAM</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E5%92%8CACL%E6%9D%83%E9%99%90%E5%92%8CPAM/</url>
    <content><![CDATA[<p>使用者标识符： UID （User ID ） GID （Group ID ）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UID取值范围如下</span><br><span class="line">0：           * *系统管理员**</span><br><span class="line"></span><br><span class="line">1~99：      由 distributions 自行建立的**系统账号**；100~499：   若用户有**系统账号**需求时，可以使用的账号 UID。500~65535：**可登入账号**，给一般使用者用的。</span><br><span class="line">用户验证步骤：</span><br><span class="line">1.在/etc/passwd中寻找输入的用户名，如果存在则读取对应的UID，GID（在/etc/group中），该账号家目录和shell设定一并读出。</span><br><span class="line">2.在 /etc/shadow中根据用户UID查找密码是否和输入密码一致。</span><br><span class="line">/etc/group    群组用户文件</span><br><span class="line">/etc/gshadow 群组密码文件</span><br><span class="line"></span><br><span class="line">有效群组(effective group)与初始群组(initial group)</span><br></pre></td></tr></table></figure></p>
<p>>usermod -G users dmtsai     &lt;==先设定好次要群组<br>>grep  dmtsai  /etc/passwd  /etc/group  /etc/gshadow<br>/etc/passwd:dmtsai:x:503:504::/home/dmtsai:/bin/bash<br>/etc/group:users:x:100:dmtsai,daemon  &lt;==次要群组的设定<br>/etc/group:dmtsai:x:504:daemon      &lt;==因为是初始群组，所以第四字段不需要填入账号<br>/etc/gshadow:users:::dmtsai,daemon   &lt;==次要群组的设定<br>/etc/gshadow:dmtsai:!::daemon<br><code>`</code><br>dmtsai中GID为504，在/etc/group中查找第三字段（GID）为504的群组为dmtsai，故dmtsai为初始群组，在users的第四字段中有dmtsai用户，故users群组为dmtsai用户的次要群组。dmtsai群组为dmtasi，users。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/30d3c14e-b22f-4efc-ac80-7aede2518684.png" alt="img"></p>
<p>><strong>groups</strong></p>
<p>dmtsai users  第一个为有效群组，建立文件时该文件群组为第一个。</p>
<p>><strong>newgrp</strong> users  更改有效群组</p>
<p>users  dmtsai </p>
<p>-—————————————————————————————————————————-</p>
<p><strong>useradd</strong> [-u UID] [-g 初始群组] [-G 次要群组] [-mM]  [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名</p>
<blockquote>
<p>-M  ：强制！不要建立用户家目录！(系统账号默认值)</p>
<p>-m  ：强制！要建立用户家目录！(一般账号默认值)</p>
<p>-r   ：建立一个系统的账号，这个账号的 UID 会有限制 (参考 /etc/login.defs)</p>
</blockquote>
<p>>useradd zyf</p>
<p>结果为：</p>
<p>\1. 在 /etc/passwd 里面建立一行与账号相关的数据，包括建立 UID/GID/家目录等；</p>
<p>\2. 在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码；</p>
<p>\3. 在 /etc/group 里面加入一个和账号名称一模一样的组名；</p>
<p>\4. 在 /home 底下建立一个与账号同名的目录作为用户家目录，且权限为 700</p>
<p>>useradd -r vbird3  建立系统账号，不会建立家目录</p>
<p>useradd -D 默认值</p>
<p>/etc/login.defs  账号权限默认值</p>
<p>/etc/skel/*  家目录默认值</p>
<p><strong>passwd</strong><br>passwd [–sdtin] username </p>
<p>  –stdin ：可以透过来自前一个管线的数据，作为密码输入，对 shell script 有帮组</p>
<p>>passwd aaa</p>
<p>>echo “abc543CC” | passwd –stdin aaa  利用管线修改密码</p>
<p>>passwd -S aaa  –显示账号属性</p>
<p>aaa PS 2015-01-29 0 99999 7 -1 (Password set, SHA512 crypt.)&gt;passwd -l aaa  –将aaa加锁aaa LK 2009-02-26 0 60 7 10 (Password locked.)&gt;passwd -u aaa  –将aaa解锁</p>
<p><strong>chage  –更改用户属性</strong></p>
<p>chage -l aaa  –显示aaa用户详细属性</p>
<p>>echo “agetest” | passwd –stdin agetest<br>>chage -d 0 agetest<br>agetest第一次登陆时用’agetest’可以登陆，登陆后提示必须改密码。</p>
<p><strong>usermod –更改用户属性</strong></p>
<p><strong>userdel</strong><br>userdel [-r] user  加-r删除家目录<br><strong>id</strong> [username]  –显示UID/GID等信息，不加username显示自己的信息</p>
<p><strong>groupadd</strong></p>
<p><strong>&gt;</strong>groupadd group1  –添加群组</p>
<p><strong>groupmod</strong><br>groupmod [-g gid] [-n group_name] 群组名<br>> groupmod -g 201 -n mygroup group1</p>
<p><strong>groupdel</strong> [groupname]</p>
<p>>groupdel group1</p>
<p><strong>ACL（Acess Control List）</strong></p>
<p><strong>setfacl</strong></p>
<p>setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名</p>
<p>​    -m ：设定后续的 acl 参数给档案使用，不可于 -x 合用； </p>
<p>​     -x ： 删除后续的 acl 参数，不可与 -m 合用； </p>
<p>​     -b ：移除所有的 ACL 训定参数；</p>
<p>​     -k ：移除预设的 ACL 参数，关于所谓的『预设』参数与后续范例中介绍； </p>
<p>​     -R ：递归设定 acl ，亦即包括次目录都会被设定起来； </p>
<p>​     -d ：设定『预设 acl 参数』的意思！只对目录有效，在该目录新建的数据会引用此默认值</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/7d6c9dee-a090-45e8-bf92-cdecda17d652.png" alt="img"></p>
<p><strong>getfacl</strong></p>
<p>getfcal filename</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/0a59a4c6-d790-4de4-a469-024230fb4c04.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/a190becb-be14-4be8-a11b-8470d94b5779.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/c0326181-900d-4634-b63b-53a95a48e60e.png" alt="img"></p>
<p><strong>切换账号</strong></p>
<p><strong>su</strong></p>
<p>>su   切换到root时，env环境变量还是原来用户的变量。su  name 一般账户</p>
<p>>su -  切换到root时，env环境变量也变为root的。     su -  name或 su -l name  一般账户</p>
<p>>su - -c ‘head -n 3 /etc/passwd’ 仅想要执行一次root的指令，完成后变回原来的用户环境。</p>
<p><strong>root切换成一般使用者时不用输入用户密码</strong></p>
<p><strong>sudo</strong></p>
<p>root身份 不需输密码</p>
<p>sudo -c aaa touch /tmp/myfiles  以aaa的身份去执行命令,新建的文件owner为aaa</p>
<p>sudo -c aaa sh -c “mkdir ~aaa/www;cd ~aaa/www;echo ‘This is index.html file&gt;index.html’”</p>
<p>一般用户身份 需输入该用户密码</p>
<p>sudo cat /etc/passwd </p>
<p>sudo执行步骤：</p>
<p>\1. 当用户执行 sudo 时，系统于 /etc/sudoers 档案中搜寻该使用者是否有执行 sudo 的权限；</p>
<p>\2. 若使用者具有可执行 sudo 的权限后，便让使用者『输入用户自己的密码』来确认；</p>
<p>\3. 若密码输入成功，便开始进行sudo 后续接的指令。</p>
<p>\4. 若欲切换得身份不执行者身份相同，那也不需要输入密码(root 执行 sudo 时，不需要输入密码)。</p>
<p><strong>visudo 与/etc/sudoers</strong></p>
<p>>visudo  只能通过输入visudo命令来编辑sudoers</p>
<p>使用者账号  登入者的来源主机名=(可切换的身份)  可下达的指令</p>
<p>root                    ALL=(ALL)          ALL  &lt;==这是默认值</p>
<p>\1. aaa  ALL=(ALL)  ALL             –让aaa可以执行root命令</p>
<p>\2. %groupname  ALL=(ALL)  ALL     –让groupname里面的用户可以执行root命令</p>
<p>\3. myuser1  ALL=(root)   !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root    –可以执行『 passwd 任意字符』，但是『 passwd 』和『 passwd root 』这两个指令例外！ 如此一来 myuser1 就无法改变 root 的密码了！</p>
<p>\4. 用别名设定 </p>
<p>  User_Alias ADMPW = pro1, pro2, pro3, myuser1, myuser2</p>
<p>  Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</p>
<p>  ADMPW  ALL=(root)   ADMPWCOM</p>
<p><strong>PAM(Pluggable Authentication Modules, 嵌入式模块)</strong></p>
<p><strong>PAM 可以说是一套应用程序编程接口 (Application Programming Interface, API)，他提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 (成功或失败)。由于 PAM 仅是一套验证的机制，又可以提供给其他程序所呼叫引用，因此不论你使用什么程序，都可以使用 PAM 来进行验证，如此一来，就能够让账号密码或者是其他方式的验证具有一致的结果。)</strong></p>
<p>验证类别（Type）</p>
<p>auth 认证（authentication） 判断用户是否合法</p>
<p>account 账号（authenorization）授权</p>
<p>session 管理使用者在这次登入 (或使用这个指令) 期间，PAM 所给予的环境设定。 </p>
<p>password  提供验证的修订工作</p>
<p>控制旗标（control flag）</p>
<p>required  不论成功失败都向下执行。</p>
<p>requisite  成功时向下执行，失败时停止。</p>
<p>sufficient  失败时向下执行，成功时停止。</p>
<p>optional  用在显示讯息，不在验证方面。</p>
<p>常用模块</p>
<p>pam_securetty.so</p>
<p>pam_nologin.so</p>
<p>pam_selinux.so</p>
<p>pam_console.so</p>
<p>pam_loginuid.so</p>
<p>pam_env.so</p>
<p>pam_unix.so</p>
<p>pam_cracklib.so</p>
<p>pam_limits.so</p>
<p>passwd的PAM验证流程：</p>
<p>\1.  用户开始执行 /usr/bin/passwd 这支程序，并输入密码；</p>
<p>\2.  passwd 呼叫 PAM 模块进行验证；</p>
<p>\3.  PAM 模块会到 /etc/pam.d/ 找寻与程序 (passwd) 同名的配置文件；</p>
<p>\4.  依据 /etc/pam.d/passwd 内的设定，引用相关的 PAM 模块逐步进行验证分析；</p>
<p>\5.  将验证结果 (成功、失败以及其他讨息) 回传给 passwd 这支程序；</p>
<p>\6.  passwd 这支程序会根据 PAM 回传的结果决定下一个动作 (重新输入新密码或者通过验证！)</p>
<p> /etc/pam.d/*：每个程序个别的 PAM 配置文件；</p>
<p>  /lib/security/*：PAM 模块档案的实际放置目录； </p>
<p>  /etc/security/*：其他 PAM 环境的配置文件；</p>
<p>  /usr/share/doc/pam-*/：详绅的 PAM 说明文件。</p>
<p>查询登录信息</p>
<p>><strong>w</strong></p>
<p>><strong>who</strong></p>
<p>><strong>lastlog</strong> 读取 /var/log/lastlog内容</p>
<p>><strong>last</strong> </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖DSM使用端口大全</title>
    <url>/2021/network/NAS/%E7%BE%A4%E6%99%96DSM%E4%BD%BF%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>设置工具</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Synology Assistant</td>
<td>9999、9998、9997</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>备份</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Data Replicator、Data Replicator II、Data Replicator III</td>
<td>9999、9998、9997、137、138、139、445</td>
<td>TCP</td>
</tr>
<tr>
<td>网络备份</td>
<td>873（数据）、3260（iSCSI LUN）</td>
<td>TCP</td>
</tr>
<tr>
<td>加密的网络备份（远程 Time Backup）</td>
<td>22</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>下载</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>eMule</td>
<td>4662（TCP）、4672（UDP）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>BT</td>
<td>6890 ~ 6999（用于 DSM 版本早于 v2.0.1-3.0401 的机型）；  16881（用于 DSM 版本 v2.0.1 以上的机型）</td>
<td>TCP/UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>网页应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DSM</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Download Station</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>Photo Station、Web Station</td>
<td>80（可添加另外的端口）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Mail Station</td>
<td>80（HTTP）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Audio Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）、5353（Bonjour 服务）、6001-6010（AirPlay 控制/定时）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>File Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）</td>
<td>TCP</td>
</tr>
<tr>
<td>Surveillance Station</td>
<td>9900（HTTP）、9901（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>媒体服务器</td>
<td>1900（UPnP）、50001（内容浏览）、50002（内容串流）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Video Station</td>
<td>5000（HTTP）、5001（HTTPS）、9025-9040、 5002、5004、65001（使用 HDHomeRun 网络调谐器的情况下）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>邮件服务器</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP 含 SSL/TLS</td>
<td>993</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3 含 SSL/TLS</td>
<td>995</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>文件传输</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>FTP、FTP 含 SSL、FTP 含 TLS</td>
<td>21（命令）、20（主动模式的数据连接）、55536-55663（被动模式的数据连接）</td>
<td>TCP</td>
</tr>
<tr>
<td>AFP</td>
<td>548</td>
<td>TCP</td>
</tr>
<tr>
<td>CIFS</td>
<td>smbd：139（netbios-ssn）、445（microsoft-ds）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Nmbd：137、138</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>NFS</td>
<td>111、892、2049</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>WebDAV、CalDAV</td>
<td>5005、5006（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>iSCSI</td>
<td>3260</td>
<td>TCP</td>
</tr>
<tr>
<td>TFTP</td>
<td>69</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>套件</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Cloud Station</td>
<td>6690</td>
<td>TCP</td>
</tr>
<tr>
<td>VPN Server（OpenVPN）</td>
<td>1194</td>
<td>UDP</td>
</tr>
<tr>
<td>VPN Server（PPTP）</td>
<td>1723</td>
<td>TCP</td>
</tr>
<tr>
<td>Syslog Server</td>
<td>514（可添加另外的端口）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>iTunes Server</td>
<td>3689</td>
<td>TCP</td>
</tr>
<tr>
<td>Directory Server</td>
<td>389（LDAP）、636（LDAP 含 SSL）</td>
<td>TCP</td>
</tr>
<tr>
<td>DHCP Server</td>
<td>67、68</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>行动应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DS photo+</td>
<td>80、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS audio</td>
<td>5000、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cam</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS file</td>
<td>Android/iOS 设备：5005、5006（HTTPS） Windows Phone：5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS finder</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS video</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS download</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cloud</td>
<td>6690</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>打印机、UPS 和外围设备</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>LPR</td>
<td>515</td>
<td>UDP</td>
</tr>
<tr>
<td>网络打印机（IPP）/CUPS</td>
<td>631</td>
<td>TCP</td>
</tr>
<tr>
<td>Bonjour</td>
<td>5353</td>
<td>UDP</td>
</tr>
<tr>
<td>网络 MFP</td>
<td>3240-3259</td>
<td>TCP</td>
</tr>
<tr>
<td>UPS</td>
<td>3493</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>系统</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SSH/SFTP</td>
<td>22</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
<td>TCP</td>
</tr>
<tr>
<td>资源监视器/SNMP</td>
<td>161</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>MySQL</td>
<td>3306</td>
<td>TCP</td>
</tr>
<tr>
<td>LDAP</td>
<td>389、636（SLAPD）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖Photo_Station_Video_Station索引无视频缩略图</title>
    <url>/2021/network/NAS/%E7%BE%A4%E6%99%96Photo-Station-Video-Station%E7%B4%A2%E5%BC%95%E6%97%A0%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="群晖（Synology）Photo-Station索引无视频缩略图"><a href="#群晖（Synology）Photo-Station索引无视频缩略图" class="headerlink" title="群晖（Synology）Photo Station索引无视频缩略图"></a>群晖（Synology）Photo Station索引无视频缩略图</h2><h2 id="一、个人环境"><a href="#一、个人环境" class="headerlink" title="一、个人环境"></a>一、个人环境</h2><p>黑群晖DSM6.1.4</p>
<h2 id="二、解决方式"><a href="#二、解决方式" class="headerlink" title="二、解决方式"></a>二、解决方式</h2><p>目前群晖DSM自带的ffmpeg版本是 2.7.1 ，通过社区第三方安装 4.2.4 版本的ffmpeg，即可实现Photo Station索引生成视频缩略图</p>
<h2 id="三、解决步骤"><a href="#三、解决步骤" class="headerlink" title="三、解决步骤"></a>三、解决步骤</h2><h3 id="1、开启SSH登录功能"><a href="#1、开启SSH登录功能" class="headerlink" title="1、开启SSH登录功能"></a>1、开启SSH登录功能</h3><p> <img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424093136937-1495485162.jpg" alt="img"></p>
<h3 id="2、ssh方式登录群辉"><a href="#2、ssh方式登录群辉" class="headerlink" title="2、ssh方式登录群辉"></a>2、ssh方式登录群辉</h3><p>ssh客户端比较多，常见的有Putty、SecureCRT（付费），以Putty为例介绍</p>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424094227293-616185227.jpg" alt="img"></p>
<p>填入“群辉IP地址”和“端口号”，单击“open”</p>
<p>使用管理员账户和密码登录</p>
<h3 id="3、备份历史版本ffmpeg"><a href="#3、备份历史版本ffmpeg" class="headerlink" title="3、备份历史版本ffmpeg"></a>3、备份历史版本ffmpeg</h3><p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv /usr/bin/ffmpeg /usr/bin/ffmpeg_bak</span><br></pre></td></tr></table></figure>
<h3 id="4、安装新版本ffmpeg"><a href="#4、安装新版本ffmpeg" class="headerlink" title="4、安装新版本ffmpeg"></a>4、安装新版本ffmpeg</h3><ul>
<li>打开套件中心 – 右上角设置 – 常规 – 勾选任何发行者</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424095118933-317675568.jpg" alt="img"></p>
<ul>
<li>设置菜单 – 套件来源 – 新增</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424094953347-1914197471.jpg" alt="img"></p>
<p>名称：随便起名</p>
<p>位置：<a href="http://packages.synocommunity.com" target="_blank" rel="noopener">http://packages.synocommunity.com</a></p>
<ul>
<li>安装新版本ffmpeg</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424100424865-1954461477.jpg" alt="img"></p>
<ul>
<li>拷贝</li>
</ul>
<p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -r /usr/<span class="built_in">local</span>/ffmpeg/bin/ffmpeg /usr/bin/ffmpeg</span><br></pre></td></tr></table></figure>
<ul>
<li>重写索引</li>
</ul>
<p>控制面板 – 索引服务 – 索引文件夹，勾选照片+影片，保存，然后点击旁边的“重建索引”按钮</p>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/image-20210703205125971.png" alt></p>
<p>索引需要较长时间，等待其结束</p>
<h2 id="群晖（Synology）video-Station索引无视频缩略图"><a href="#群晖（Synology）video-Station索引无视频缩略图" class="headerlink" title="群晖（Synology）video Station索引无视频缩略图"></a>群晖（Synology）video Station索引无视频缩略图</h2><h2 id="一、个人环境-1"><a href="#一、个人环境-1" class="headerlink" title="一、个人环境"></a>一、个人环境</h2><p>黑群晖DSM6.1.4</p>
<h2 id="二、解决方式-1"><a href="#二、解决方式-1" class="headerlink" title="二、解决方式"></a>二、解决方式</h2><p>1、参考上文，下载新版本ffmpeg</p>
<p>2、编写python脚本，调用ffmpeg截取视频图像</p>
<h2 id="三、解决步骤-1"><a href="#三、解决步骤-1" class="headerlink" title="三、解决步骤"></a>三、解决步骤</h2><p>目前群晖DSM自带的ffmpeg版本是 2.7.1 ，通过社区第三方安装 4.2.4 版本的ffmpeg，Photo Station索引后，可以生成视频缩略图；但Video Station索引后，仍然无法生成视频缩略图。</p>
<p>个人的解决方式为编写python转换脚本</p>
<h3 id="1、下载安装新版ffmpeg"><a href="#1、下载安装新版ffmpeg" class="headerlink" title="1、下载安装新版ffmpeg"></a>1、下载安装新版ffmpeg</h3><h3 id="2、编写python转换脚本"><a href="#2、编写python转换脚本" class="headerlink" title="2、编写python转换脚本"></a>2、编写python转换脚本</h3><p>创建脚本文件photo_thumb.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_type</span><span class="params">(filename,video_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检查是否为视频文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array = map(filename.endswith,video_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span> <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_capture_delay_time</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取截取图片在视频中位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    file_size = os.path.getsize(file_path)</span><br><span class="line">    <span class="keyword">if</span> file_size &lt;= <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>:                                <span class="comment"># 视频大小 &lt;= 1MB，截取视频第1S图片</span></span><br><span class="line">        delay_time = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> file_size &lt;= <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>:                              <span class="comment"># 1MB &lt; 视频大小 &lt;= 4MB，截取视频第5S图片</span></span><br><span class="line">        delay_time = <span class="number">5</span></span><br><span class="line">    <span class="keyword">elif</span> file_size &lt;= <span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>:                             <span class="comment"># 4MB &lt; 视频大小 &lt;= 50MB，截取视频第10S图片</span></span><br><span class="line">        delay_time = <span class="number">10</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        delay_time = <span class="number">20</span>                                             <span class="comment"># 50MB &lt; 视频大小，截取视频第20S图片</span></span><br><span class="line">    <span class="keyword">return</span> delay_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_file_existed</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检查文件是否存在</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_pre</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文件名前缀，如my_video.mp4，返回my_video</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    video_name_list = os.path.splitext(file_name)</span><br><span class="line">    <span class="keyword">if</span> len(video_name_list) == <span class="number">2</span>:</span><br><span class="line">        video_name_pre = video_name_list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        video_name_pre = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> video_name_pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_thumb</span><span class="params">(file_path,video_types)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    遍历文件夹，调用ffmpeg截取视频图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> dir_path,dir_names,file_names <span class="keyword">in</span> os.walk(file_path):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> file_names:</span><br><span class="line">            <span class="comment"># print("*"*20)</span></span><br><span class="line">            <span class="comment"># print(name)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check_type(name,video_types):                    <span class="comment"># 不是视频文件，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                print(<span class="string">"not video,continue next"</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            video_full_path = os.path.join(dir_path, name)</span><br><span class="line">            video_name_pre = get_file_pre(name)</span><br><span class="line">            <span class="keyword">if</span> video_name_pre:                                      <span class="comment"># 如果缩略图已经存在，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                pic_name = <span class="string">'%s%s'</span> % (video_name_pre,<span class="string">'.jpg'</span>)</span><br><span class="line">                picture_full_path = os.path.join(dir_path,pic_name)</span><br><span class="line">                ret = check_file_existed(picture_full_path)</span><br><span class="line">                <span class="keyword">if</span> ret:</span><br><span class="line">                    print(<span class="string">"%s existed,continue next"</span> % picture_full_path)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                delay_time = get_capture_delay_time(video_full_path)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> delay_time:                                  <span class="comment"># 获取文件大小失败，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                shell = <span class="string">'ffmpeg -i "%s" -y -ss %s -frames:v 1 "%s"'</span> % \</span><br><span class="line">                        (video_full_path, delay_time,picture_full_path)</span><br><span class="line">                <span class="comment"># print("#"*20)</span></span><br><span class="line">                print(shell)</span><br><span class="line">                os.system(shell)</span><br><span class="line">                print(<span class="string">"%s capture success"</span> % picture_full_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 当前路径中执行脚本</span></span><br><span class="line">    file_path = sys.path[<span class="number">0</span>]</span><br><span class="line">    video_types = [<span class="string">'.mp4'</span>,<span class="string">'.avi'</span>,<span class="string">'.wmv'</span>,<span class="string">'.mkv'</span>,<span class="string">'.flv'</span>]</span><br><span class="line">    make_thumb(file_path,video_types)</span><br></pre></td></tr></table></figure>
<p> 也可参考如下链接，直接下载</p>
<p>链接：<a href="https://pan.baidu.com/s/1iHW_3GvutSz6d_KPeyxvlA" target="_blank" rel="noopener">https://pan.baidu.com/s/1iHW_3GvutSz6d_KPeyxvlA</a> 提取码：3uok</p>
<h3 id="3、上传至群辉共享文件夹"><a href="#3、上传至群辉共享文件夹" class="headerlink" title="3、上传至群辉共享文件夹"></a>3、上传至群辉共享文件夹</h3><ul>
<li>打开File Station，上传脚本文件photo_thumb.py至需要转换的文件夹，如video</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424104410603-2139857840.jpg" alt="img"></p>
<ul>
<li>脚本执行时，会自动遍历子文件夹，所以只需在最外层文件夹执行即可</li>
</ul>
<h3 id="4、运行脚本"><a href="#4、运行脚本" class="headerlink" title="4、运行脚本"></a>4、运行脚本</h3><p>ssh登录群辉</p>
<p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">cd</span> volume1/video/</span><br><span class="line">sudo python3 photo_thumb.py</span><br></pre></td></tr></table></figure>
<p>注：如上脚本采用python3执行，python2未实验</p>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器端口转发访问NAS</title>
    <url>/2021/network/NAS/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E8%AE%BF%E9%97%AENAS/</url>
    <content><![CDATA[<p>如果<strong>路由器具有公网IP</strong>，则访问家里的NAS时，不需要通过VPS进行转发，直接在路由器中设置端口转发即可。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>路由器具有公网IP</li>
<li>申请一个域名例如aaa.com，并设置了解析 aaa.com -&gt; 路由器公网IP</li>
</ol>
<h2 id="设置IP与MAC地址绑定"><a href="#设置IP与MAC地址绑定" class="headerlink" title="设置IP与MAC地址绑定"></a>设置IP与MAC地址绑定</h2><p>以华硕AC86U为例，开启IP与MAC地址绑定为：</p>
<p><img src="/2021/network/NAS/路由器端口转发访问NAS/Snipaste_2021-04-06_22-15-14.png" alt="Snipaste_2021-04-06_22-15-14"></p>
<h2 id="设置端口转发"><a href="#设置端口转发" class="headerlink" title="设置端口转发"></a>设置端口转发</h2><p>以华硕AC86U为例，开启端口转发的设置为：</p>
<p><img src="/2021/network/NAS/路由器端口转发访问NAS/Snipaste_2021-04-06_21-50-25.png" alt="Snipaste_2021-04-06_21-50-25"></p>
<h2 id="设置DDNS"><a href="#设置DDNS" class="headerlink" title="设置DDNS"></a>设置DDNS</h2><p>路由器的外网动态IP是不断变化的，所以域名解析设置也需要同步更新，使用DDNS服务，可以在路由器公网IP变化时，自动同步域名解析的配置，我们就可以只记住一个域名就可以访问NAS的服务。</p>
<p>以华硕ac86u为例，在软件中心安装<strong>Aliddns</strong>插件，设置如下图：</p>
<p><img src="/2021/network/NAS/路由器端口转发访问NAS/Snipaste_2021-04-06_21-57-55.png" alt="Snipaste_2021-04-06_21-57-55"></p>
<h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>DS file、DS finder、DS audio 官方使用5000端口 ， DS photo官方使用80端口</p>
<p>运营商封锁了aaa.com域名的80、443端口，所以不能访问aaa.com的80和443端口，不需要在端口转发中设置这两个端口的配置。</p>
<p>web端访问管理界面 <a href="http://aaa.com:5000/" target="_blank" rel="noopener">http://aaa.com:5000</a> 端口号不能省略</p>
<p>移动端APP填入以下地址：</p>
<p>ds file aaa.com:5000                :5000能省略，省略的话，APP可能默认使用5000端口<br>ds audio aaa.com:5000           :5000能省略，省略的话，APP可能默认使用5000端口<br>ds photo aaa.com:8008           :8008不能省略，省略的话，APP可能默认使用80端口<br>android drive aaa.com:5000   :5000能省略，省略的话，APP可能默认使用5000端口</p>
<p>windows drive   aaa.com:6690   不能省略端口</p>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>路由器</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title>WOL-远程唤醒-ARP绑定</title>
    <url>/2021/network/WOL/WOL-%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92-ARP%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>如果路由器具有公网IP，可以不需要VPS转发WOL数据包，直接在外网连接路由器发送WOL数据包，进行远程唤醒。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li><p>域名设置DDNS  <strong>aaa.com -&gt; 路由器公网IP</strong></p>
</li>
<li><p>windows系统设置了允许WOL的配置，可参考以前文章。</p>
</li>
<li><p>路由器设置了端口转发，如下：</p>
<p>外部9000端口转发到192.168.50.100的9号端口；外部9001端口转发到192.168.50.123的9号端口</p>
</li>
</ol>
<p><img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/dkzf.png" alt="dkzf"></p>
<ol start="4">
<li>路由器设置IP和mac地址绑定，<strong>内网wol可以不设置地址绑定, 外网wol必须设置地址绑定</strong>，如下：</li>
</ol>
<p><img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/bd.png" alt="bd"></p>
<p>数据流转：<br>   外网WOL：唤醒端在外网9000号端口发起请求-&gt;路由器端口映射-&gt;192.168.50.100:9 -&gt;查询绑定的mac地址的机器，然后启动。<strong>和frp远程访问不同（frpc配置广播地址，不需要设置端口转发）</strong></p>
<p>   内网WOL：使用广播地址192.168.50.255 和mac地址进行广播，找到mac地址相同的进行启动。frp原理和此相同。</p>
<p>遇到问题是，不能每次都唤醒，所以需要ARP绑定。</p>
<h2 id="何为-ARP-绑定"><a href="#何为-ARP-绑定" class="headerlink" title="何为 ARP 绑定"></a>何为 ARP 绑定</h2><p>华硕路由器居然连 ARP 绑定功能都没有。这里要区别一下，在客户端列表中开启 <code>MAC地址与IP绑定</code> 其实仅仅是 DHCP 绑定，它可以保证每次给相同设备总是分配同一个 IP 地址，但<strong>前提是设备必须请求IP！</strong></p>
<p>我们知道路由器内部会维护一个 ARP 表，记录 IP 与 MAC 的关系，每当设备请求 IP 时便会被记录，其超时时间因具体设置而不同。因此当设备长时间不在线（比如关机）时吗，ARP 记录就会失效，从而无法再通过 IP 给此设备发送数据。</p>
<p>有一个典型需求：PC需要 WOL 网络唤醒。因此我们要进行 <strong>ARP 绑定</strong>，与 DHCP 绑定不同，ARP 绑定相当于把 IP 对应关系写死在表里，无论设备是否在线。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>ssh 或 telnet 登录路由器，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -s [IP] [MAC]</span><br></pre></td></tr></table></figure>
<p>就搞定了。</p>
<p>但是这样每次重启都会失效，我们需要通过自启脚本来手动添加 ARP 项，因此官方固件是不行的，先刷梅林，使用putty连接到路由器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /jffs/scripts/ <span class="comment"># 进入脚本目录</span></span><br><span class="line">vi services-start <span class="comment"># 打开编辑器（你也可以用其他编辑器）</span></span><br></pre></td></tr></table></figure>
<p>将文件内容改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">arp -s [IP] [MAC]</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p>保存，最后给予执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+rx /jffs/scripts/*</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证ARP绑定无误也非常简单，上面步骤做完以后，重启一下路由器，putty连接路由器，直接输入<code>arp</code> 查看 ARP 表，对应项目如果标识有 <code>[PERM]</code> 就是已经绑定了。</p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_12-57-38.png" alt="Snipaste_2021-04-06_12-57-38"></p>
<p>应该可以通过域名从互联网开机了。</p>
<h2 id="唤醒端配置"><a href="#唤醒端配置" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h2><p>手机下载WOL软件，PC和NAS唤醒配置如下：</p>
<p> <img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_11-37-08.png" alt="Snipaste_2021-04-06_11-37-08"><br> <img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_11-36-52.png" alt="Snipaste_2021-04-06_11-36-52"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>WOL</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
        <tag>WOL</tag>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>WOL-远程唤醒-FRP</title>
    <url>/2021/network/WOL/WOL-%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92-FRP/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>VPS（具有公网IP），配置了fprs服务。</li>
<li>路由器可安装frpc插件,我是用的华硕ac86u</li>
<li>申请了域名 ，例如aaa.com，并配置DDNS域名解析：  <strong>aaa.com-&gt; vps IP</strong></li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>路由器没有公网IP，需要vps转发数据。唤醒端在外网通过域名请求vps 9号端口，vps将开机命令包通过udp协议转发给路由器所在局域网的 192.168.50.255（广播地址，此广播地址根据192.169.50.1路由器IP算出来的掩码），遍历mac地址相同的机器，发送到该机器的9号端口，进行开机。</p>
<h2 id="Windows系统唤醒"><a href="#Windows系统唤醒" class="headerlink" title="Windows系统唤醒"></a>Windows系统唤醒</h2><h3 id="被唤醒端配置"><a href="#被唤醒端配置" class="headerlink" title="被唤醒端配置"></a>被唤醒端配置</h3><ol>
<li><p>设置技嘉主板BIOS的Erp选项为disable，启动远程开机的功能。其他主板配置不同，参阅百度或者说明手册。</p>
</li>
<li><p>设置windows系统支持远程开机启动<br>设置网卡，选择当前使用的网卡，右键网卡属性，在“网络”tab页点击配置。</p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/image-20210406091402158.png" alt="image-20210406091402158" style="zoom: 67%;"></p>
<p>在 <strong>高级</strong> 菜单中的属性找到 <strong>唤醒魔包</strong> (Wake on Magic Packet) 设置为 <strong>启用</strong></p>
</li>
</ol>
<p>   <img src="/2021/network/WOL/WOL-远程唤醒-FRP/clip_image002.jpg" alt="IMG_258" style="zoom:50%;"></p>
<p>   在 <strong>电源管理</strong> 中 勾选 <strong>允许此设备唤醒计算机</strong></p>
<p>   <img src="/2021/network/WOL/WOL-远程唤醒-FRP/clip_image004.jpg" alt="IMG_259" style="zoom:50%;"></p>
<h3 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h3><ol>
<li>用vps进行开机udp命令包转发，需要在路由器中安装frpc插件，设置frpc内网穿透配置；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wol]</span><br><span class="line">type = udp  #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255  #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9 #一般采用这个端口进行wol</span><br><span class="line">remote_port = 9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将mac地址和IP地址进行绑定</li>
</ol>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/clip_image002b.jpg" alt="IMG_260"></p>
<h3 id="唤醒端配置"><a href="#唤醒端配置" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h3><p><strong>远程唤醒</strong>Android端下载WOL软件，可以通过手机唤醒</p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_09-42-52.png" alt="Snipaste_2021-04-06_09-42-52"></p>
<p><strong>局域网唤醒</strong></p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_09-45-52.png" alt="Snipaste_2021-04-06_09-45-52"></p>
<h2 id="NAS系统唤醒"><a href="#NAS系统唤醒" class="headerlink" title="NAS系统唤醒"></a>NAS系统唤醒</h2><h3 id="被唤醒端配置-1"><a href="#被唤醒端配置-1" class="headerlink" title="被唤醒端配置"></a>被唤醒端配置</h3><ol>
<li><p>改为设置主板华擎J4105的BIOS和NAS系统，NAS开机进入BIOS后，</p>
<p>选择Advanced -&gt; Chipset Configuration</p>
<p>Onboard LAN 设置为enable，启动网卡<br>Enable or disable the onboard network interface controller.</p>
<p>PCIE1 Link Speed<br>Select the link speed for PCIE1.</p>
<p>Deep S5 (设置系统的休眠级别，可能有关系，改小试试)<br>Configure deep sleep mode for power saving when the computer is shut down.</p>
<p>选择Advanced -&gt; ACPI Configuration</p>
<p>PCIE Device Power On 设置为 enable<br>Allow the system to be waked up by a PCIE device and enable wake on LAN.</p>
<p><strong>Boot From Onboard LAN设置为enable</strong><br><strong>Allow the system to be waked up by the onboard LAN.</strong></p>
</li>
<li><p>NAS系统暂未发现设置项，可能不需要设置</p>
</li>
</ol>
<h3 id="路由器端配置"><a href="#路由器端配置" class="headerlink" title="路由器端配置"></a>路由器端配置</h3><ol>
<li>用vps进行开机udp命令包转发，需要在路由器中安装frpc插件，设置frpc内网穿透配置；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wol]</span><br><span class="line">type = udp  #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255  #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9 #一般采用这个端口进行wol</span><br><span class="line">remote_port = 9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>将NAS的mac地址和IP地址进行绑定<br><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-05-49.png" alt="Snipaste_2021-04-06_10-05-49"></p>
<h3 id="唤醒端配置-1"><a href="#唤醒端配置-1" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h3></li>
</ol>
<p><strong>远程唤醒</strong></p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-07-15.png" alt="Snipaste_2021-04-06_10-07-15"></p>
<p><strong>局域网唤醒</strong></p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-07-37.png" alt="Snipaste_2021-04-06_10-07-37"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>WOL</category>
      </categories>
      <tags>
        <tag>WOL</tag>
        <tag>内网穿透</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>FRP内网穿透</title>
    <url>/2021/network/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/FRP%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>NAS没有公网IP是一件很不方便的事情，尤其是在国内的网络环境，学校和小区内的用户通常都没有公网IP。为了解决这个问题，则需要内网穿透，而内网穿透的方法主要有两种：</p>
<p>1.不借助第三方中转，直接建立点对点的连接，创建虚拟局域网。主要有tinc 、Zerotier(先尝试穿透，穿透不了则进行中转)。</p>
<p>2.借助第三方进行数据中转。主要有ngrok、frp。</p>
<p><strong>由于手机4G网络(5G都为IPv6公网IP)和运行商的大内网内的机器（指没有公网IP的机器）所在的网络都为双端NAT网络</strong>，所以第一种方案内网穿透很困难，成功率很低。</p>
<p>而ngrok的使用和配置比frp稍复杂，所以我采用frp进行内网穿透。</p>
<p><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a> 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。github地址：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>VPS有公网IP的服务器，</p>
</li>
<li><p>内网机器这里是群晖NAS，也可以是能安装frpc插件路由器</p>
</li>
<li><p>PUTTY 和WinSCP</p>
</li>
<li><p>阿里云域名,假设你的域名为 aaa.com</p>
</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol>
<li><p><strong>在域名服务商的控制台里设置DNS域名解析  aaa.com解析到NAS IP</strong></p>
</li>
<li><p>到 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a> 下载对应平台的安装包，我是用frp_0.21.0_linux_amd64.tar.gz</p>
</li>
<li><p>如果在windows上，解压后用WinSCP上传到VPS和NAS上/root下。</p>
</li>
<li><p>修改VPS和NAS中frp_0.21.0_linux_amd64文件夹属性改为0777</p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/Snipaste_2021-04-02_11-37-20.png" alt="Snipaste_2021-04-02_11-37-20" style="zoom:67%;"></p>
</li>
</ol>
<h2 id="VPS-NAS组合"><a href="#VPS-NAS组合" class="headerlink" title="VPS+NAS组合"></a>VPS+NAS组合</h2><h3 id="VPS配置"><a href="#VPS配置" class="headerlink" title="VPS配置"></a>VPS配置</h3><p>修改VPS上的frps.ini配置文件，服务端只用frps和frps.ini两个文件，其余都可删掉。</p>
<p>frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"></span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure>
<p>使用putty连接上VPS，切换到 /root/frp_0.21.0_linux_amd64目录下<br>前端开启，关闭窗口时服务同时关闭，仅用于观看输出，不建议使用此命令 <code>./frps -c ./frps.ini</code><br>执行命令 后台开启 <code>nohup ./frps -c ./frps.ini &amp;</code></p>
<h3 id="NAS配置"><a href="#NAS配置" class="headerlink" title="NAS配置"></a>NAS配置</h3><p>修改NAS上的frpc.ini配置文件，客户端只用frpc和frpc.ini两个文件，其余可删掉<br>frpc.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 144.168.60.183</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">log_file = /root/frp_0.21.0_linux_amd64/frpc.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br><span class="line"></span><br><span class="line">[nas]</span><br><span class="line">type = http</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /</span><br><span class="line"></span><br><span class="line">[photo]</span><br><span class="line">type = http</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /photo</span><br><span class="line"></span><br><span class="line">[windowsDrive]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 6690</span><br><span class="line">remote_port = 6690  #TCP类型不需要设置locations或者custom_domains</span><br></pre></td></tr></table></figure>
<p>NAS中配置开机启动脚本：</p>
<ol>
<li>新建 frpcExec.sh到/root,内容为：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">nohup /root/frp_0.21.0_linux_amd64/frpc   -c   /root/frp_0.21.0_linux_amd64/frpc.ini  &gt;  /root/frp_0.21.0_linux_amd64/mynohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>在NAS中新建用户触发脚本任务<code>/root/frpcExec.sh</code></p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/Snipaste_2021-04-02_13-48-45.png" alt="Snipaste_2021-04-02_13-48-45"></p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/Snipaste_2021-04-02_13-48-54.png" alt="Snipaste_2021-04-02_13-48-54"></p>
</li>
</ol>
<h2 id="VPS-路由器组合"><a href="#VPS-路由器组合" class="headerlink" title="VPS+路由器组合"></a>VPS+路由器组合</h2><h3 id="VPS配置-1"><a href="#VPS配置-1" class="headerlink" title="VPS配置"></a>VPS配置</h3><p>修改VPS上的frps.ini配置文件，服务端只用frps和frps.ini两个文件，其余都可删掉。</p>
<p>frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"></span><br><span class="line">#由于路由器不能使用locations，所以使用二级域名，要在此配置</span><br><span class="line">subdomain_host = aaa.com</span><br><span class="line"></span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure>
<p> 使用putty连接上VPS，切换到 /root/frp_0.21.0_linux_amd64目录下，下面的步骤选一个执行</p>
<ul>
<li><p>执行命令 后台开启 <code>nohup ./frps -c ./frps.ini &amp;</code></p>
</li>
<li><p>Centos6中或者将其写入开机启动 vim /etc/rc.local   加入此行<br><code>nohup  /root/frp_0.21.0_linux_amd64/frps -c  /root/frp_0.21.0_linux_amd64/frps.ini  &gt;  /root/frp_0.21.0_linux_amd64/frps.log 2&gt;&amp;1 &amp;</code></p>
</li>
</ul>
<ul>
<li><p>Centos7使用systemd，可以新建服务，开机自动启动</p>
<p>新建文件  <code>vi /etc/systemd/system/frp.service</code> </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/frp_0.21.0_linux_amd64/frps -c /root/frp_0.21.0_linux_amd64/frps.ini </span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -9 $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload # 添加或修改配置文件后，需要重新加载</span><br><span class="line">systemctl enable frp.service # 开机自启</span><br><span class="line">systemctl start  frp.service # 启动测试</span><br><span class="line">systemctl status frp.service # 查看启动状态</span><br><span class="line">systemctl disable frp.service # 关闭开机启动</span><br><span class="line">systemctl stop frp.service # 停止服务</span><br><span class="line">systemctl restart frp.service # 重启服务</span><br></pre></td></tr></table></figure>
<h3 id="路由器AC86U"><a href="#路由器AC86U" class="headerlink" title="路由器AC86U"></a>路由器AC86U</h3><ol>
<li><p>到koolshare论坛下载带有软件中心的固件刷机，下载Frpc插件。或者你用软路由系统的软件中心下载Frpc插件。</p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/image-20210402141322236.png" alt="image-20210402141322236"></p>
</li>
<li><p>在自定义配置中填入一下配置  </p>
<p>路由器的IP为192.168.50.1 </p>
<p>掩码为192.168.50.255</p>
<p>NAS的IP 192.168.50.123</p>
<p>电脑的IP 192.168.50.100</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = VPS IP地址</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log_file = /tmp/upload//frpc.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br><span class="line"></span><br><span class="line">#路由器ssh，需要在路由器中开启ssh模式，一般不需要对外网开放，访问VPS的6000端口，转发到路由器的22端口</span><br><span class="line">[routerSSH]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">#nas的ssh功能，一般不需要对外网开放，访问VPS的6001端口，转发到NAS(192.168.50.123)的22端口</span><br><span class="line">[nasSSH]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6001</span><br><span class="line"></span><br><span class="line">#nas的web端 访问http://aaa.com,转发到NAS(192.168.50.123)的5000端口</span><br><span class="line">[nas]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /</span><br><span class="line"></span><br><span class="line">#transmission的web端 访问http://aaa.com/trans,转发到NAS(192.168.50.123)的9091端口</span><br><span class="line">[transmission]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 9091</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /trans</span><br><span class="line"></span><br><span class="line">[aria2]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 6080</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /aria</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[photo]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /photo</span><br><span class="line"></span><br><span class="line">[windowsDrive]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 6690</span><br><span class="line">remote_port = 6690</span><br><span class="line"></span><br><span class="line">#路由器使用二级域名，通过http://router.aaa.com访问</span><br><span class="line">#使用远程管理路由器也可以进行局域网唤醒</span><br><span class="line">#需要添加二级域名解析 router.aaa.com解析到NAS IP</span><br><span class="line">[router]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.1</span><br><span class="line">local_port = 80</span><br><span class="line">subdomain = router</span><br><span class="line"></span><br><span class="line">#远程唤醒</span><br><span class="line">[wol]</span><br><span class="line">type = udp    #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255    #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9</span><br><span class="line">remote_port = 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#局域网唤醒后，使用远程桌面进行访问，走frps主机流量访问192.168.50.100(电脑固定IP)的3389端口</span><br><span class="line">[remote desktop]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.100</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 3389</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>DS file、DS finder、DS audio 官方使用5000端口 ， DS photo官方使用80端口</p>
<p>web端访问管理界面 <a href="http://aaa.com" target="_blank" rel="noopener">http://aaa.com</a> </p>
<p>web端访问路由器 <a href="http://router.aaa.com" target="_blank" rel="noopener">http://router.aaa.com</a></p>
<p>移动端APP填入以下地址：</p>
<p>ds file                                 aaa.com:80/               :80不能省略，省略的话，APP可能默认使用5000端口<br>ds audio                            aaa.com:80/               :80不能省略，省略的话，APP可能默认使用5000端口<br>ds photo                           aaa.com:80/photo<br>android drive                   aaa.com:80/</p>
<p>windows drive                 aaa.com:6690           不能省略端口</p>
]]></content>
      <categories>
        <category>network</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>内网穿透</tag>
        <tag>frp</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT号段</title>
    <url>/2021/network/%E7%90%86%E8%AE%BA/NAT%E5%8F%B7%E6%AE%B5/</url>
    <content><![CDATA[<p>我们现在常使用的IP地址是IPv4地址，由32位二进制数组成，每隔8位二进制数字用小数点分隔，可得四组二进制数，将每组二进制数转为十进制数，就是我们平常看到的IP地址。Internet上的每一台主机或者路由器都至少有一个IP地址。IP地址的长度是32位，总数为2的32次方，大约43亿个。</p>
<p>NAT（Network Address Translation），中文名唤作网络地址转换，诞生于IP地址匮乏的时代。</p>
<p>NAT的基本思想是ISP（Internet服务提供商）为每个家庭或者公司分配一个IP地址，这个IP地址用作Internet流量的传输，也就是大家常说的<strong>外网</strong>IP地址或者<strong>公网</strong>IP地址。在客户网络的内部，每台计算机有唯一一个IP地址，即<strong>内网</strong>IP地址，这些地址主要用于路由内部流量。当一个数据包离开客户网络发送至其他ISP时，需要进行<strong>地址转换</strong>，把唯一的内网IP地址转换成外网的IP地址。</p>
<p>这种地址转化使用IP地址的三个范围，这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的IP地址不允许出现在Internet（外网）上，这三个保留的地址范围是：</p>
<p>10.0.0.0~10.255.255.255/8</p>
<p><strong>100.64.0.0 ~100.127.255.255/10</strong>  <strong>用于在电信级NAT环境中服务提供商与其用户通信</strong> </p>
<p>172.16.0.0~172.31.255.255/12</p>
<p>192.168.0.0~192.168.255.255/16</p>
<p>他们分别可以容纳16777216、1048576、65536台主机。一般家里用无线路由器，就用到了网络地址转换技术，我们连上wifi后分配的IP地址一般是以172或192为开头。学校或者大企业里面的网络可能会用到10开头的地址范围。</p>
<p>NAT将内网外网划分好之后，是如何使内网的设备访问外网的呢？</p>
<p>如下图，当计算机<strong>A</strong>在内网（假设IP为10.0.0.1）想去访问一个Internet上的网站<strong>S</strong>（假设IP地址为54.223.189.245）时，<strong>A</strong>的数据包需要先经过一个<strong>NAT盒子</strong>(NAT box)，这个盒子先将<strong>A</strong>的IP源地址转换成外网的真实IP地址（假设IP为121.0.0.2），然后将转换后的数据包发送至Internet。</p>
<p><img src="/2021/network/理论/NAT号段/clip_image001.png" alt="clip_image001"></p>
<p>于是问题来了，当网站<strong>S</strong>收到这个数据包后，会处理请求，并发送响应的数据包，然而这个数据包的目标地址是121.0.0.2（外网IP），数据包如何返回内网中的<strong>A</strong>呢？</p>
<p>这里要先介绍一下<strong>源端口</strong>（Source Port）和<strong>目标端口</strong>（Destination Port）的概念。当一个进程希望与另一个进程建立TCP连接时，它把自己绑定到一个本机尚未被占用的TCP端口上，这个端口称为<strong>源端口</strong>，该TCP连接中所有入境的数据包都要被发送至这个端口。同时进程还需要提供一个<strong>目标端口</strong>，指明数据包到达远程主机后送至哪一个端口处理。每一个出境的TCP数据包都包括一个源端口和目标端口。</p>
<p>举例来说，如下图，网站服务器<strong>S</strong>（IP地址为54.223.189.245）的HTTP服务运行在80端口上，公网上的计算机<strong>D</strong>（IP地址为121.141.56.23）想去访问网站<strong>S</strong>，于是把自己绑定到本机的33121端口上，并发送请求的数据包，这个数据包中就包含了计算机<strong>D</strong>的源端口33121和目标端口80。网站<strong>S</strong>收到请求后，发送响应的数据包，这个数据包中包含了服务器<strong>S</strong>的源端口80和目标端口3312。</p>
<p> <img src="/2021/network/理论/NAT号段/20161103125031128.png" alt="20161103125031128"></p>
<p>上面的例子是外网中的一台计算机访问一个网站。在内网中计算机发送的数据包同样存在着源端口和目标端口。NAT盒子做的事情就是对出入境数据包的端口进行修改。</p>
<p>回到最初举的例子，假设内网计算机<strong>A</strong>（IP地址为10.0.0.1）发送的请求包的源端口是45421，目标端口是80，请求访问网站服务器<strong>S</strong>（IP地址为54.223.189.245）。</p>
<p>当这个出境数据包经过NAT盒子时，其源地址被修改成公网的真实IP（121.0.0.2），源端口被修改一个索引值（假设为50002），这个索引值指向NAT盒子的地址转化表中的某一项，这一表项保存了计算机<strong>A</strong>的内网源地址和源端口。最后NAT盒子将重新生成的数据包发送出去。</p>
<p>当网站S响应的入境数据包到达NAT盒子时，数据包经过处理，目的地址由公网IP（121.0.0.2）还原为计算机A的内网IP（10.0.0.1），目标端口由索引值（50002）还原为计算机A的源端口（45421）。还原后数据包可以正常的在内网路由。</p>
<p>这个过程基本如下图所示。</p>
<p><img src="/2021/network/理论/NAT号段/clip_image003.png" alt="clip_image003"></p>
<p>如此一来，NAT解决了数据包在内网公网之间的地址和端口的转换问题，暂时缓解了IP地址的短缺，但是它却有着不少的缺点。</p>
<p>NAT违背了IP的结构模型（每个IP地址唯一标识世界上的一台机器），采用NAT后可能有无数台主机使用10.0.0.1这个IP地址。NAT还打破了Internet的端-端的连接模型。内网中的主机可以通过NAT与一台公网上的服务建立连接，但是反过来却不行，公网上的主机无法与某一内网中的主机建立连接。举个简单的例子来说，你在内网某台计算机上搭建了一个网站，在外网是无法访问的。而且使用NAT后，Internet变得如电路交换网络一样脆弱。NAT盒子为每个经过它的连接维护必要的信息（即映射关系），若NAT盒子崩溃，并且所有映射表被摧毁，所有TCP连接将被摧毁。</p>
<p>目前的IP地址匮乏，归根结底是IPv4设计者的锅，NAT只是权宜之策。既然NAT这么复杂，有人要问了，在IPv6普及后，NAT是否就会被取缔了呢？答案是不会的。因为NAT已被广泛使用，尤其是家庭和小型企业的网络，即使IPv6普及了，NAT在短时间内也很难被取代。</p>
<p> <strong>IPv4保留地址</strong><br><img src="/2021/network/理论/NAT号段/Snipaste_2021-04-01_15-28-01.png" alt="Snipaste_2021-04-01_15-28-01"></p>
<p><strong>IPv6保留地址</strong><br><img src="/2021/network/理论/NAT号段/Snipaste_2021-04-01_15-28-14.png" alt="Snipaste_2021-04-01_15-28-14"></p>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">保留的IP地址</a></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT类型和穿透性</title>
    <url>/2021/network/%E7%90%86%E8%AE%BA/NAT%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A9%BF%E9%80%8F%E6%80%A7/</url>
    <content><![CDATA[<h2 id="网络地址映射"><a href="#网络地址映射" class="headerlink" title="网络地址映射"></a>网络地址映射</h2><p>在有中心化服务器的网络中，客户端，服务器，网关构成网络拓扑图。如下图1所示：由于后续出现的名词概念很多，先约法三章，在这里统一一下称呼：所有的终端机器成为客户端，不同客户端使用大写字母区分（A,B,C,…）；客户端上面运行的应用程序统一称为客户程序，不同的应用程序使用不数字区分（1,2,3,…）。作为服务器的物理机称为服务器，而服务器上运行的程序称为服务程序，后文中每一个拓扑组件都只有一个IP地址。为客户端提供公网IP服务的组件称为网关。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image002.jpg" alt="img" style="zoom:67%;"></p>
<p>图1 中心化服务器的网络拓扑图</p>
<p>从网关映射到客户端中的网络结构，这里需要引入一个NAT的概念。什么NAT呢？中文名叫网络地址转换，习惯称为网络地址映射。为什么需要网络地址映射呢？：需要说到IPV4网络地址已经用完，全部使用IPV6又会造成很多只支持IPV4的终端设备无法正常使用，所以网络地址映射应运而生，忍辱负重。才会有我们现在所谓的网络穿透的出现。到底怎么映射的？如图2网络地址映射所示。客户程序使用192.168.0.234:7890发送数据，通过网关的网络地址映射在公网被转换为112.93.116.102:6834，被互联网上的大家所认知。此时在公网上使用客户程序的ip与端口被112.93.116.102:6834代替。在这里大家应该明白了NAT是何许物种了。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image004.jpg" alt="img" style="zoom: 67%;"><br>​图2 网络地址映射</p>
<p>为了保持新手福音，业界良心的态度。什么是穿透？因为NAT是客户程序发起的，网络为了保持通讯新建的一个临时牌照，随时可能被收回，而且重新发起后的牌照不一样。从而外界及时知道了这个临时牌照也没有用。所以需要通过穿透在网关上面打个洞，来为外界进行服务。那NAT与穿透有什么关系呢？正因为有了NAT才需要穿透，如果是IPV6每个客户端一个IP地址，那就不需要直接可以找到客户端了。</p>
<h2 id="NAT种类"><a href="#NAT种类" class="headerlink" title="NAT种类"></a>NAT种类</h2><p>  由于网关的安全性要求不一致，就出现四种不同的NAT方式。分别进行阐述：</p>
<p>第一种<strong>完全锥形NAT</strong>，英文名叫<strong>Full Cone NAT</strong>。如图3完全锥形NAT所示，客户程序(192.168.0.234:7890)与服务器A(13.44.178.98:9800)通信，通过网关的地址转换产生的临时牌照的公网地址（112.93.116.102:6834），服务器B（157.78.13.156:23456）发送数据到公网地址（112.93.116.102:6834），如果客户程序(192.168.0.234:7890)能够收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为完全锥形NAT；</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image006.png" alt="img" style="zoom:67%;"><br>​图3 完全锥形NAT</p>
<p>第二种<strong>限制锥形NAT</strong>，英文名叫<strong>RestrictedCone NAT</strong>。在图3 完全锥形NAT中，如果客户程序(192.168.0.234:7890)不能收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为限制型锥形NAT。</p>
<p>第三种<strong>端口限制锥形NAT</strong>，英文名叫<strong>Port RestrictedCone NAT</strong>。客户程序(192.168.0.234:7890)发送数据给服务程序（13.44.178.98:9800）,网关通过网络地址转换产生的地址（112.93.116.102:6834）,同样的服务器内的另一个服务程序（13.44.178.178:9801）发送数据给网关（112.93.116.102:6834）地址，如果客户程序(192.168.0.234:7890)能够收到，则为限制锥形NAT，如果客户程序(192.168.0.234:7890)不能收到，则为端口限制锥形NAT。</p>
<p>  对于所有的锥型NAT，客户程序（192.168.0.234:7890）对外发送的数据时，网关地址转换的地址都是一样的为（112.93.116.102:6834）,那为什么在图4 限制型锥形NAT中，客户程序不能收到服务程序B（13.44.178.98:9801）的数据呢？因为在网关中没有发生过客户程序（192.168.0.234:7890）给服务程序B（13.44.178.98:9801），故服务程序（13.44.178.98:9801）直接发送给网关（112.93.116.102:6834），则被网关所丢弃。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image008.jpg" alt="img" style="zoom:67%;"></p>
<p>图4 限制型锥形NAT</p>
<p>第四种<strong>对称NAT</strong>，英文，名叫<strong>Symmetric NAT</strong>。如图5对称NAT所示，客户程序（192.168.0.234:7890）发送数据给两个不同服务器（13.44.178.98:9800）和（157.78.13.156:23456）时，网关会进行不同的网络地址映射产生（112.93.116.102:6834）和（112.93.116.102:6835）。这是对于整个NAT网络发送数据出去的过程，而接收数据与端口限制锥形NAT一致。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image010.png" alt="img" style="zoom:67%;"><br>             图5 对称NAT</p>
<h2 id="不同NAT组合的穿透性"><a href="#不同NAT组合的穿透性" class="headerlink" title="不同NAT组合的穿透性"></a><strong>不同NAT组合的穿透性</strong></h2><p>这里说的穿透指在没有经过第三方数据中转的情况下，两者直接建立点对点的连接，可直接进行数据交换，相当于两者在一个虚拟的局域网中。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/image-20210401162435764.png" alt="image-20210401162435764"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层模型与TCP IP五层模型</title>
    <url>/2021/network/%E7%90%86%E8%AE%BA/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、OSI参考模型"><a href="#一、OSI参考模型" class="headerlink" title="一、OSI参考模型"></a>一、OSI参考模型</h2><p>​    今天我们先学习一下以太网最基本也是重要的知识——OSI参考模型。</p>
<p> 1、OSI的来源</p>
<p>​    OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。</p>
<p>​    ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p>
<p> 2、OSI七层模型的划分</p>
<p>​    OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。如下图。</p>
<p>​    每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p>  <img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234824085-667046040.png" alt="img"></p>
<p> 3、各层功能定义</p>
<p>​    这里我们只对OSI各层进行功能上的大概阐述，不详细深究，因为每一层实际都是一个复杂的层。后面我也会根据个人方向展开部分层的深入学习。这里我们就大概了解一下。我们从最顶层——应用层 开始介绍。整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</p>
<p><1>  应用层</1></p>
<p>​    OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>​    实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</p>
<p><2>  表示层</2></p>
<p>​    表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>​    由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>
<p><3>  会话层</3></p>
<p>​    会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。   </p>
<p>​    会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p>
<p><4>  传输层</4></p>
<p>​    传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<p>​    传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>
<p><5>  网络层</5></p>
<p>​    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>​    网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>
<p><6>  数据链路层 </6></p>
<p>​    将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>   数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p>
<p>​    MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<p>​    这个没找到合适的例子</p>
<p><7> 物理层   </7></p>
<p>​    实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p>​     快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p>
<p>4、通信特点：对等通信   </p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234824866-481636745.png" alt="img"></p>
<h2 id="二、TCP-IP五层模型"><a href="#二、TCP-IP五层模型" class="headerlink" title="二、TCP/IP五层模型"></a>二、TCP/IP五层模型</h2><p>  TCP/IP五层协议和OSI的七层协议对应关系如下。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234825491-384470376.png" alt="img"></p>
<p>  在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234826351-1957282396.png" alt="img"></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同.下图列出了每层主要的协议。其中每层中具体的协议，我会在后面的逐一学习。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234827195-1493107425.png" alt="img"></p>
<p>参考文献：</p>
<p>  1.百度百科：OSI参考模型</p>
<p>  2.<a href="http://blog.csdn.net/wdkirchhoff/article/details/43915825" target="_blank" rel="noopener">http://blog.csdn.net/wdkirchhoff/article/details/43915825</a></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>AC86U创建虚拟内存U盘读写速度不够</title>
    <url>/2021/network/%E8%B7%AF%E7%94%B1%E5%99%A8/AC86U%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98U%E7%9B%98%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%A4%9F/</url>
    <content><![CDATA[<h4 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h4><p><code>AC86U</code> 升级固件后挂载虚拟内存总是提示读写速度不够，新固件的读取速度要求 <code>20M/s</code>，写入速度要求 <code>30M/s</code><br><img src="/2021/network/路由器/AC86U创建虚拟内存U盘读写速度不够/20210106091033.png" alt="img"></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>修改参数限制</p>
<p><code>ssh</code> 登录到路由器，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改写入速度限制，30替换为10</span><br><span class="line">sed -i &apos;s/^W_LIMIT=30/W_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br><span class="line"></span><br><span class="line"># 修改读取速度限制，20替换为10</span><br><span class="line">sed -i &apos;s/^R_LIMIT=20/R_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br></pre></td></tr></table></figure>
<p>以上参数可以根据自己的实际情况进行调整</p>
<p>完成后重新进入管理界面挂载虚拟内存即可</p>
]]></content>
      <categories>
        <category>network</category>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>雷鸟电视在线安装软件</title>
    <url>/2021/network/%E7%94%B5%E8%A7%86/%E9%9B%B7%E9%B8%9F%E7%94%B5%E8%A7%86%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新买的雷鸟R625C电视往往默认是无法安装第三方应用的，即使用U盘安装了第三方应用，应用也没有升级权限。另外，也无法通过沙发管家等应用市场来安装应用。接下来说说如何使用adb工具打开雷鸟电视的第三方应用安装权限。</p>
<h2 id="ADB安装"><a href="#ADB安装" class="headerlink" title="ADB安装"></a>ADB安装</h2><p>ADB的全称为Android Debug Bridge，通过ADB工具，我们可以直接操作管理android模拟器或者真实的android设备（如安卓手机、机顶盒）。它主要有以下几种作用：<br>（1）运行设备的shell(命令行)<br>（2）管理模拟器或设备的端口映射<br>（3）计算机和android设备之间上传/下载文件<br>（4）将本地apk软件安装至android模拟器或android设备</p>
<h3 id="下载Android-Platform-Tools"><a href="#下载Android-Platform-Tools" class="headerlink" title="下载Android Platform Tools"></a>下载Android Platform Tools</h3><p>到Android开发官网下载Android Platform Tools并解压，解压后可以看到文件夹platform-tools，里面包含adb调试工具。<br> <img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111636482.png" alt="image-20210331111636482"></p>
<h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><p>打开“我的电脑-&gt;属性-&gt;系统高级设置-&gt;环境变量”，在Path变量中添加platform-tools文件夹的路径：</p>
<p><img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111701288.png" alt="image-20210331111701288"></p>
<h3 id="运行ADB"><a href="#运行ADB" class="headerlink" title="运行ADB"></a>运行ADB</h3><p>打开命令行窗口，输入adb，能打印出adb的版本号和用法，即为安装成功。</p>
<p> <img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111724426.png" alt="image-20210331111724426"></p>
<h2 id="打开电视的adb调试开关"><a href="#打开电视的adb调试开关" class="headerlink" title="打开电视的adb调试开关"></a>打开电视的adb调试开关</h2><p>进入设置-&gt;系统-&gt;系统信息，遥控器依次按下“上”、“下”、“左”、“右”，即可看到页面中跳出adb开关，将ADB设为开启状态即可：</p>
<p><img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111929404.png" alt="image-20210331111929404"></p>
<h2 id="abd工具打开电视权限"><a href="#abd工具打开电视权限" class="headerlink" title="abd工具打开电视权限"></a>abd工具打开电视权限</h2><ol>
<li><p>首先将电脑和雷鸟电视连接到同一网络下。</p>
</li>
<li><p>查看雷鸟电视的ip地址，我的这台电视的ip为192.168.0.129</p>
</li>
<li><p>根据上一步获得的ip地址，在windows命令行执行<code>adb connect 192.168.0.129:5555</code>连接到雷鸟电视：</p>
</li>
<li><p>执行adb shell进入shell模式，然后执行以下两条命令就可以成功打开第三方应用安装权限：<br><code>setprop persist.tcl.debug.installapk 1</code><br><code>setprop persist.tcl.installapk.enable 1</code></p>
<p><img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331112424137.png" alt="image-20210331112424137"></p>
</li>
<li><p>然后再尝试用电视安装或升级第三方应用，第三方应用已经可以正常安装和升级，用当贝极速版或者沙发管家下载就可以了。</p>
</li>
<li><p>如果需要直接通过adb工具安装应用，先按照步骤1~3连接到电视，再执行<code>adb install</code>命令安装应用即可：<br><code>adb install XXX.apk</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>network</category>
        <category>电视</category>
      </categories>
      <tags>
        <tag>电视</tag>
      </tags>
  </entry>
  <entry>
    <title>远程桌面</title>
    <url>/2021/network/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="远程访问-Android"><a href="#远程访问-Android" class="headerlink" title="远程访问 Android"></a>远程访问 Android</h2><p>小米通话：小米手机之间远程软件，米聊已停服。</p>
<h2 id="远程访问-Windows"><a href="#远程访问-Windows" class="headerlink" title="远程访问 Windows"></a>远程访问 Windows</h2><p>远程软件主要有： </p>
<p><strong>向日葵</strong> 免费，多用时收费</p>
<p><strong>teamviewer</strong> 少用时免费，多用时可能检测为商业用途</p>
<p><strong>Anydesk</strong> 同是德国软件，teamviewer 公司里面的人再创业出品</p>
<p><strong>VNC Server</strong>(被控端) + <strong>VNC Viewer</strong>(控制端) </p>
<p><strong>microsoft remote desktop</strong> 和 <strong>远程桌面</strong>(system32\mstsc.exe) 微软官方出品 <strong>需要局域网环境或内网穿透</strong></p>
<h3 id="windows端设置"><a href="#windows端设置" class="headerlink" title="windows端设置"></a>windows端设置</h3><p>本文介绍在使用<strong>microsoft remote desktop</strong> 或  <strong>远程桌面</strong>(system32\mstsc.exe) 时windows需要设置的配置。</p>
<ol>
<li><p>先确定被遥控的电脑的系统必须是Professional或Enterprise以上版本，<strong>家庭版不支持远程桌面</strong>。</p>
</li>
<li><p>确保自己的系统登录是带有密码的，<strong>采用outlook网络账号登录</strong>，而不是本地账户登录。</p>
</li>
<li><p><strong>打开控制面板 -&gt;系统 -&gt;点击远程设置，在“远程设置”tab页中</strong> 点击允许远程连接到此计算机，并且勾上仅允许运行使用网络级别身份验证的远程桌面的计算机连接（建议）。</p>
<p><img src="/2021/network/远程桌面/远程桌面/1.png" alt="1"></p>
<ol start="4">
<li>点击选择用户，可以看到网络账户，例如：<a href="mailto:aaa@outlook.com" target="_blank" rel="noopener">aaa@outlook.com</a>已经有访问权。</li>
</ol>
</li>
</ol>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_13-25-44.png" alt="Snipaste_2021-04-06_13-25-44"></p>
<ol start="5">
<li>接下来是最重要的一步，依次打开控制面板 -&gt;Windows Defender 防火墙→允许应用或功能通过Windows Defender防火墙，点击更改设置，找到远程桌面（一般为最下方），将后面的两个框都勾上，点击确定保存。</li>
</ol>
<p><img src="/2021/network/远程桌面/远程桌面/22.png" alt="22"></p>
<h3 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问"></a>局域网访问</h3><ol>
<li><p>查看自己的内网IP地址，按Win+R，输入cmd，跳出对话框，输入ipconfig，在跳出的一筐数字中找到一栏，IPv4地址，记录下后面的地址。</p>
</li>
<li><p>打开Microsoft Remote Desktop，PC和Android端都有该软件。或  远程桌面(system32\mstsc.exe) PC端<br>PC name 填入主机的局域网IP，User name 填入网络outlook账号和密码，入下图所示，后面3389为默认端口，可省略。</p>
</li>
</ol>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_19-01-00.png" alt="Snipaste_2021-04-06_19-01-00"></p>
<h3 id="广域网访问"><a href="#广域网访问" class="headerlink" title="广域网访问"></a>广域网访问</h3><h4 id="路由器设置-frp内网穿透"><a href="#路由器设置-frp内网穿透" class="headerlink" title="路由器设置-frp内网穿透"></a>路由器设置-frp内网穿透</h4><p><strong>路由器没有公网IP</strong>，在外网访问家里的电脑，需要在路由器中对frpc进行配置，在VPS进行frps设置（自己的局域网可以利用路由器24小时开机的特性，进行frpc配置，公司网络没这个条件）</p>
<p>唤醒端应用请求vps 3389端口，vps转发到路由器所在的局域网中IP为192.168.50.100的主机的3389端口进行远程桌面。</p>
<p>WOL唤醒后才能远程访问，使用远程桌面进行访问，走vps主机流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote desktop]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.100</span><br><span class="line">local_port = 3389 #通常本地采用3389进行远程访问</span><br><span class="line">remote_port = 3389</span><br></pre></td></tr></table></figure>
<h4 id="路由器设置-端口转发"><a href="#路由器设置-端口转发" class="headerlink" title="路由器设置-端口转发"></a>路由器设置-端口转发</h4><p><strong>路由器有公网IP</strong>，在外网访问家里的电脑，不需要在路由器设置frpc，只需要设置端口转发，如下图：</p>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_19-14-42.png" alt="Snipaste_2021-04-06_19-14-42"></p>
<p>唤醒程序直接根据路由器IP，请求路由器IP的3389 端口，不需要经过VPS转发，速度更快。</p>
<h4 id="唤醒端设置"><a href="#唤醒端设置" class="headerlink" title="唤醒端设置"></a>唤醒端设置</h4><p>打开Microsoft Remote Desktop，PC name 填入域名:3389   User name 填入网络outlook账号和密码</p>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_19-01-19.png" alt="Snipaste_2021-04-06_19-01-19"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>远程桌面</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
        <tag>frp</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位</title>
    <url>/2019/%E5%89%8D%E7%AB%AF/HTML%20CSS/CSS%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;定位&lt;/title&gt;</span><br><span class="line">  &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-id">#left</span>,<span class="selector-id">#center</span>,<span class="selector-id">#right</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">33.3%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  相对定位</span></span><br><span class="line"><span class="comment">  1.相对于自己原来的显示位置进行显示</span></span><br><span class="line"><span class="comment">  2.原来的空间不会被其他元素占用</span></span><br><span class="line"><span class="comment">  3.如果一个元素，只是开启了相对定位，没有偏移量， 那么这个元素一般是用来作为参照的，&lt;div style="position: relative"&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   绝对定位</span></span><br><span class="line"><span class="comment">   1.相对于离他最近的，并且使用了定位的父元素，如果没有找到，以body为参照</span></span><br><span class="line"><span class="comment">   2.原来的显示空间会被其他元素占用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#fix</span>&#123;</span><br><span class="line">  <span class="comment">/*以整个屏幕为基准*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;div style="position: relative"&gt;</span><br><span class="line">  &lt;div id="left"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div id="center"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div id="right"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id="fix"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/前端/HTML CSS/CSS定位/Snipaste_2019-02-06_15-08-02.png" alt="Snipaste_2021-07-06_15-08-02"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>toFixed四舍五入问题</title>
    <url>/2021/%E5%89%8D%E7%AB%AF/Vue.js/toFixed%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近做的项目涉及到金额的计算，有一种方式就是进行四舍五入的规则进行小数点后面的尾数处理，以前一直以为toFixed方法就是四舍五入的，知道一个用户反馈了金额计算的bug我才如梦初醒，才仔细深究了下toFixed这个方法，唉，还是我不够严谨啊，前车之鉴，大家勿走我的老路！</p>
<p>toFixed还不同的浏览器实现，在IE10及以上里面是正常的四舍五入，但是别的浏览器里面就不一样了，它不是正常的四舍五入（等下重点说），比如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1.335</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.toFixed(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// IE         1.34</span></span><br><span class="line"><span class="comment">//chorme   1.33</span></span><br></pre></td></tr></table></figure>
<p> 其他的浏览器我没去一一测试，所以如果大家用了其他浏览器的还是需要去实际测试一下，我这里就说说javascript的toFixed()方法的四舍五入原理：</p>
<p>toFixed它是一个四舍六入五成双的诡异的方法(也叫银行家算法)，”四舍六入五成双”含义：对于位数很多的近似数，当有效位数确定后，其后面多余的数字应该舍去，只保留有效数字最末一位，这种修约（舍入）规则是“四舍六入五成双”，也即“4舍6入5凑偶”这里“四”是指≤4 时舍去，”六”是指≥6时进上，”五”指的是根据5后面的数字来定，当5后有数时，舍5入1；当5后无有效数字时，需要分两种情况来讲：①5前为奇数，舍5入1；②5前为偶数，舍5不进。（0是偶数）</p>
<p>但是，经过我的测试发现，在chorme下面（最新版），并没有完全遵守这个规则，尤其是5的后面没有数字的时候，不是这么判断的，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1.335</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.33"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.345</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.34"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.355</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.35"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.365</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.36"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.375</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.38"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.385</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.39"</span></span><br></pre></td></tr></table></figure>
<p>可以发现在chorme下没有完全去遵循这个规律，或许它有自己的算法，但是毕竟它没有遵循通用的银行家算法，所以tofixed这个方法在涉及到金钱计算的业务中还是少用，<br>最好别用，否则可能会出大问题！</p>
<p>总结：众所周知，遵循IEEE754数值格式的语言的浮点计算会出现精度损耗的通病，ES也并非独此一家，因此尽量不要进行某个特定浮点数值的测试，如：0.1+0.2；<br>解决方案：重写Number.prototype.toFixed()方法:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.toFixed=<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123; </span><br><span class="line">             <span class="keyword">var</span> s=<span class="keyword">this</span>+<span class="string">""</span>; </span><br><span class="line">             <span class="keyword">if</span>(!d)d=<span class="number">0</span>; </span><br><span class="line">             <span class="keyword">if</span>(s.indexOf(<span class="string">"."</span>)==<span class="number">-1</span>)s+=<span class="string">"."</span>; </span><br><span class="line">             s+=<span class="keyword">new</span> <span class="built_in">Array</span>(d+<span class="number">1</span>).join(<span class="string">"0"</span>); </span><br><span class="line">             <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^(-|\\+)?(\\d+(\\.\\d&#123;0,"</span>+(d+<span class="number">1</span>)+<span class="string">"&#125;)?)\\d*$"</span>).test(s))&#123;</span><br><span class="line">                <span class="keyword">var</span> s=<span class="string">"0"</span>+<span class="built_in">RegExp</span>.$<span class="number">2</span>,pm=<span class="built_in">RegExp</span>.$<span class="number">1</span>,a=<span class="built_in">RegExp</span>.$<span class="number">3.</span>length,b=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(a==d+<span class="number">2</span>)&#123;</span><br><span class="line">                    a=s.match(<span class="regexp">/\d/g</span>); </span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(a[a.length<span class="number">-1</span>])&gt;<span class="number">4</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">var</span> i=a.length<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                            a[i]=<span class="built_in">parseInt</span>(a[i])+<span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span>(a[i]==<span class="number">10</span>)&#123;</span><br><span class="line">                                a[i]=<span class="number">0</span>;</span><br><span class="line">                                b=i!=<span class="number">1</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    s=a.join(<span class="string">""</span>).replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(\\d+)(\\d&#123;"</span>+d+<span class="string">"&#125;)\\d$"</span>),<span class="string">"$1.$2"</span>);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">if</span>(b)s=s.substr(<span class="number">1</span>); </span><br><span class="line">                <span class="keyword">return</span> (pm+s).replace(<span class="regexp">/\.$/</span>,<span class="string">""</span>);</span><br><span class="line">           &#125;<span class="keyword">return</span> <span class="keyword">this</span>+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.335--&gt;"</span>+ <span class="number">1.335</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.335--&gt;"</span>+ <span class="number">1.335</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.345--&gt;"</span>+ <span class="number">1.345</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.345--&gt;"</span>+ <span class="number">1.345</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.355--&gt;"</span>+ <span class="number">1.355</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.355--&gt;"</span>+ <span class="number">1.355</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"1.365--&gt;"</span>+ <span class="number">1.365</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.365--&gt;"</span>+ <span class="number">1.365</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.375--&gt;"</span>+ <span class="number">1.375</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.375--&gt;"</span>+ <span class="number">1.375</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.385--&gt;"</span>+ <span class="number">1.385</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.385--&gt;"</span>+ <span class="number">1.385</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.045--&gt;"</span>+ <span class="number">1.045</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0455--&gt;"</span>+ <span class="number">1.0455</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0453--&gt;"</span>+ <span class="number">1.0453</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0450--&gt;"</span>+ <span class="number">1.0450</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0452--&gt;"</span>+ <span class="number">1.0450</span>.toFixed(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>js做四则运算精度丢失问题及解决方法</title>
    <url>/2021/%E5%89%8D%E7%AB%AF/Vue.js/js%E5%81%9A%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E6%97%B6%EF%BC%8C%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>之前项目上出现过这样一个bug,就是明明两个数都是一样的但是就是莫名其妙的报出两个数不相等,导致流程无法继续下去<br>然后我把所有数据导出来,进行一对一比对,只是一个很耗时的过程,最终让我找到<br>因为js计算过后会出现计算精度丢失的问题 找到问题所在就好说了,然后就开始解决这个让我为难了好长时间的问题<br>废话不多说直接上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相加精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==a||<span class="literal">null</span>==a||<span class="string">""</span>==a||<span class="built_in">isNaN</span>(a))&#123;a=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==b||<span class="literal">null</span>==b||<span class="string">""</span>==b||<span class="built_in">isNaN</span>(b))&#123;b=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = a.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        d = b.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(c, d));</span><br><span class="line">    <span class="keyword">return</span>  (floatMul(a, e) + floatMul(b, e)) / e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相减精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatSub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==a||<span class="literal">null</span>==a||<span class="string">""</span>==a||<span class="built_in">isNaN</span>(a))&#123;a=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==b||<span class="literal">null</span>==b||<span class="string">""</span>==b||<span class="built_in">isNaN</span>(b))&#123;b=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = a.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        d = b.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(c, d));</span><br><span class="line">    <span class="keyword">return</span> (floatMul(a, e) - floatMul(b, e)) / e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相乘精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatMul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">0</span>,</span><br><span class="line">        d = a.toString(),</span><br><span class="line">        e = b.toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c += d.split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c += e.split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(d.replace(<span class="string">"."</span>, <span class="string">""</span>)) * <span class="built_in">Number</span>(e.replace(<span class="string">"."</span>, <span class="string">""</span>)) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相除精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatDiv</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e = <span class="number">0</span>,</span><br><span class="line">        f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        e = a.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (g) &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f = b.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (g) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> c = <span class="built_in">Number</span>(a.toString().replace(<span class="string">"."</span>, <span class="string">""</span>)), d = <span class="built_in">Number</span>(b.toString().replace(<span class="string">"."</span>, <span class="string">""</span>)), floatMul(c / d, <span class="built_in">Math</span>.pow(<span class="number">10</span>, f - e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就解决js精度丢失<br>原理也很简单 就是很好的运用了我们小学所学的算术的小数相乘/相加/相减/相除后小数位的变化规律来进行精度的换算</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底明白VUE修饰符sync</title>
    <url>/2021/%E5%89%8D%E7%AB%AF/Vue.js/%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDVUE%E4%BF%AE%E9%A5%B0%E7%AC%A6sync/</url>
    <content><![CDATA[<blockquote>
<p>对于VUE的初学者来讲，肯定会感觉prop的写法很麻烦，很讨厌！你肯定想如果prop也可以实现双向绑定那怎是一个爽字了得！不过现实是残酷的，如果子组件可以任意修改父组件的内容，那势必会带来数据的混乱，从而造成维护的困扰！毕竟父组件也是有尊严的！</p>
</blockquote>
<p>官方推荐使用一种update:my-prop-name 的模式来替代事件触发，目的是为了优雅而不粗鲁的实现父子组件间的双向绑定！先来完成一个小功能：通过父组件按钮将子组件显示出来，如图：</p>
<p><img src="/2021/前端/Vue.js/彻底明白VUE修饰符sync/webp" alt="img"></p>
<p>父组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span> </span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"@/components/child"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                isShow:<span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=<span class="literal">true</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件child代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来加个需求，在子组当中增加一个按钮，通过该按钮来将自已隐藏起来！需要借助父子之间的传值了！如图：</p>
<p><img src="/2021/前端/Vue.js/彻底明白VUE修饰符sync/webp1" alt="img"></p>
<p>父组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> @<span class="attr">upIsShow</span>=<span class="string">"changeIsShow"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"@/components/child"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                isShow:<span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=<span class="literal">true</span>;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeIsShow(bol)&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=bol;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我隐身"</span> @<span class="attr">click</span>=<span class="string">"upIsShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods:&#123;</span><br><span class="line">            upIsShow()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">"upIsShow"</span>,<span class="literal">false</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我要将父组件中的事@upIsShow修改为@update:isShow不违法吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"changeIsShow"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>子组件的emit自然也要做对应调整：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">upIsShow()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"update:isShow"</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，一切正常！真好！</p>
<p>那么如果现在我将父组件的changeIsShow直接写成匿名函数，也能运行吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"function(bol)&#123;isShow=bol&#125;"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>再次运行，一切还是那么美好，真好！</p>
<p>现在我将那匿名函数改成箭头函数，不过分吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"bol=&gt;isShow=bol"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>再运行一次，完美，真好！</p>
<p>最后我将上面那行代码做最后一次修改：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child :isShow.<span class="keyword">sync</span>=<span class="string">"isShow"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>至此终于涉及到了sync了。以上代码 :isShow.sync=”isShow”其实是 @update:isShow=”bol=&gt;isShow=bol”语法糖。是其一种简写形式。附上完整代码。<br>父组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">:isShow.sync</span>=<span class="string">"isShow"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"@/components/child"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                isShow:<span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=<span class="literal">true</span>;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeIsShow(bol)&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=bol;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我隐身"</span> @<span class="attr">click</span>=<span class="string">"upIsShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods:&#123;</span><br><span class="line">            upIsShow()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">"update:isShow"</span>,<span class="literal">false</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后：sync只是给大家伙提供了一种与父组件沟通的思路而已！所以在后面日子里，你如果只是单纯的在子组件当中修改父组件的某个数据时，建议使用sync，简单，快捷，有档次！真好！</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>padding陷阱</title>
    <url>/2018/%E5%89%8D%E7%AB%AF/HTML%20CSS/padding%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>我们都知道padding是为块级元素设置内边距</p>
<p>但是在使用过程中，我们却会遇到一些问题。padding的标准盒模型和怪异盒模型</p>
<h4 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a><strong>标准盒模型</strong></h4><p>我们先摆出HTML和CSS代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.shoebox</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            padding: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.shoes</span>&#123;</span></span><br><span class="line">            width: 80px;</span><br><span class="line">            height: 80px;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoebox"</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoes"</span>&gt;</span>              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>一个demo，我的一双大小是 80*80  的鞋子,为此我给了这个鞋子做了一个 100*100 的盒子，我想要让这个鞋子有10px的内边距，所以我设了一个 padding: 10px; </p>
<p>我们想象中的场景效果可能是这样的：<img src="/2018/前端/HTML CSS/padding陷阱/Snipaste_2018-06-27_15-46-29.png" alt="Snipaste_2021-07-06_15-46-29">  但是现实真的好残酷。。他却是这样的：</p>
<p><img src="/2018/前端/HTML CSS/padding陷阱/Snipaste_2018-06-27_15-46-14.png" alt="Snipaste_2021-07-06_15-46-14"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27154932074.png" alt="image-20210706154932074"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27155011508.png" alt="image-20210706155011508"></p>
<p>这时候我们会很奇怪，明明我们设置的shoebox的高和宽是100*100怎么变成了110*110了呢，这多出来的10px是怎么回事。</p>
<p>这是padding元素膨胀造成的结果。在标准盒模型中，设置padding会自动挤压空间，而不会利用给出来的空间，不会占用宽内位置，不通过width影响，会自己挤出空间来，就好像，我的鞋子是80*80的，我不需要100*100的盒子，你给我一个80*80的盒子就好了，我靠我自己来把他挤成100*100，这时很显然的解决的办法就出来了，我们的盒子的宽度只要设置成80*80然后设置padding：10px；来让鞋子把周围额空间挤成100*100。</p>
<p>这就是padding的标准盒模型，先做好鞋子，再去做盒子</p>
<h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a><strong>怪异盒模型</strong></h4><p>怪异盒模型与标准盒模型的区别就是，怪异盒模型是先做好盒子，再来做鞋子，我把盒子的大小固定住，你鞋子怎么挤也没有用。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.shoebox</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            padding: 10px;</span><br><span class="line">            box-sizing: border-box;//怪异盒模型</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.shoes</span>&#123;</span></span><br><span class="line">            width: 80px;</span><br><span class="line">            height: 80px;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoebox"</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoes"</span>&gt;</span>              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这时我们只要在我们的代码中加一条box-sizing：boeder-box，就可以把我的盒子给固定住，这时你鞋子想要用padding来撑大盒子的空间已经没用了，因为鞋子已经被固定死了。<br><img src="/2018/前端/HTML CSS/padding陷阱/Snipaste_2018-06-27_15-46-29.png" alt="Snipaste_2021-07-06_15-46-29"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27155148568.png" alt="image-20210706155148568"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27155011508.png" alt="image-20210706155011508"></p>
<p>最后在<strong>总结</strong>一点padding的知识：</p>
<ol>
<li><p>当我们给width设置一个固定的值或者给width设置100%时，设置padding都会把盒子给挤开，挤大了</p>
</li>
<li><p>若想要不使用怪异盒模型又不会把盒子挤大，请把width设置为auto，width默认的值是auto。自动占满整个屏幕</p>
</li>
<li><p>标准盒模型在pc端比较常用，因为pc端的屏幕大，有优势可以撑</p>
</li>
<li><p>怪异盒模型在手机端比较常用。手机屏幕是有限大小的，有时我们往往需要使用怪异盒模型把他固定住。</p>
</li>
<li><p>怪异盒模型的盒子大小还要加上border的大小。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动</title>
    <url>/2018/%E5%89%8D%E7%AB%AF/HTML%20CSS/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>float<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#left</span>&#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: aqua;</span><br><span class="line">      width: 50%;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#right</span>&#123;</span></span><br><span class="line">      height: 120px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      width: 50%;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#content2</span>&#123;</span></span><br><span class="line">      height: 150px;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.clearFix</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line">      content: '清除浮动';</span><br><span class="line">      display: block;</span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#cle</span>&#123;</span></span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 行内元素 不占一行 宽度取决于包裹的元素宽度</span></span><br><span class="line"><span class="comment">     块状元素占一行</span></span><br><span class="line"><span class="comment">浮动后块状元素变成行内元素，如果不设置宽度时，宽度大小取决于其包裹的元素的大小--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content1"</span>  <span class="attr">class</span>=<span class="string">"clearFix"</span>  &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;div id="cle"&gt;&lt;/div&gt;--&gt;</span> <span class="comment">&lt;!--此清除float方法不好，添加了一个dom元素，采用class="clearFix"即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content2"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>清除浮动前：</p>
<p><img src="/2018/前端/HTML CSS/清除浮动/Snipaste11.png" alt="Snipaste11"></p>
<p>清除浮动后：</p>
<p><img src="/2018/前端/HTML CSS/清除浮动/Snipaste1.png" alt="Snipaste1"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>

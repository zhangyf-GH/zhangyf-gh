<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开博</title>
    <url>/2019/%E5%BC%80%E5%8D%9A/</url>
    <content><![CDATA[<p>记录生活<br>感悟人生</p>
]]></content>
  </entry>
  <entry>
    <title>1.走进Java</title>
    <url>/2015/JVM/1.%E8%B5%B0%E8%BF%9BJava/</url>
    <content><![CDATA[<p>-Xms400m -Xmx400m -XX:PermSize=200m -XX:MaxPermSize=200m </p>
<p>高级语言虚拟机讨论组 <a href="http://hllvm.group.iteye.com/" target="_blank" rel="noopener">http://hllvm.group.iteye.com/</a></p>
<p>RednaxelaFX博客  <a href="http://rednaxelafx.iteye.com/" target="_blank" rel="noopener">http://rednaxelafx.iteye.com/</a></p>
<p>1991-4 James Gosling   绿色计划（Green Project）  Oak(橡树)</p>
<p>1995-5-23  Oak-&gt;Java   Write Once,Run AnyWhere</p>
<p><strong>三大商用高性能java 虚拟机</strong></p>
<p><strong>1.Sun Classic VM  ——&gt; Exact VM ——&gt; Sun HotSpot VM</strong></p>
<p>  Sun Classic VM只能使用纯解释器方式来执行Java代码，如果使用JIT编译器，就必须进行外挂，但是假如外挂了JIT编译器，JIT编译器就完全接管了虚拟机的执行系统，解释器便不再工作了。</p>
<p><strong>2.BEA JRockit</strong></p>
<p>   专注于服务器领域，不太管组启动速度，内部不包含解析器实现，全部代码靠即时编译器编译后执行，JRockit的垃圾收集器和MIssionControl服务套件等部分的实现，也一直处于领先水平。</p>
<p><strong>3.IBM J9 VM</strong></p>
<p>Dalvik VM是Android平台的核心组件之一，但并不是一个Java虚拟机，没有遵循Java虚拟机规范，不能直接执行Java的Class文件，使用的是寄存器架构而不是JVM中常见的栈架构。但是它执行的dex(Dalvik Executable)文件可以通过Class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API。</p>
<p><strong>java未来发展趋势</strong></p>
<p>模块化</p>
<p>混合语言</p>
<p>多和并行</p>
<p>更丰富语法（自动装箱 泛型 动态注解 枚举 可变长参数 遍历循环）</p>
<p>64位虚拟机</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Java内存模型与线程</title>
    <url>/2015/JVM/11.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　多任务和高并发是衡量一台计算机处理器的能力重要指标之一。一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。在讨论Java内存模型和线程之前，先简单介绍一下硬件的效率与一致性。</p>
<h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>　　由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。<br>　　基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。</p>
<p>   除此之外，为了使得处理器内部的运算单元能竟可能被充分利用，处理器可能会对输入代码进行乱起执行（Out-Of-Order Execution）优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Recorder）优化。</p>
<p><img src="/2015/JVM/11.Java内存模型与线程/48b97589-3558-4b2f-a1c1-300af6a1a48c.jpg" alt="img"></p>
<p>　　</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>  Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model,JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能达到一致的内存访问结果。在此之前，主流程序语言(如C/C++等)直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。</p>
<p>　　定义Java内存模型并不是一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发操作不会产生歧义；但是，也必须得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存等）来获取更好的执行速度。经过长时间的验证和修补，在JDK1.5发布后，Java内存模型就已经成熟和完善起来了。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量(Variables)与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享,自然就不会存在竞争问题。为了获得较好的执行效能 Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内再进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p>
<p>　　Java内存模型中规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分)。每条线程还有自己的工作内存（Working Memory,可以与前面讲的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。</p>
<p><img src="/2015/JVM/11.Java内存模型与线程/1b4a3175-cd58-43cc-8ffd-7208a72b01db.jpg" alt="img"></p>
<p>这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机(甚至是硬件系统本身的优化措施)可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>　　关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成，虚拟机实现是必须保证下面提及的每一种操作都是原子的，不可再分的(对于double和long类型的变量来说，load、store、read和write)操作在某些平台上允许有例外：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>　　如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，现即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程成对其进行lock操作，lock和unlock必须成对出现。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把次变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="对于-volatile-型变量的特殊规则"><a href="#对于-volatile-型变量的特殊规则" class="headerlink" title="对于 volatile 型变量的特殊规则"></a>对于 volatile 型变量的特殊规则</h3><p>​    关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，当一个变量定义为volatile之后，它将具备两种特性：    <strong>第一是保证此变量对所有线程的可见性，这里的”可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</strong>    </p>
<p>​    volatile变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性的问题)，但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果并发正确的话，最后输出结果应该是200000，但是实际结果总是小于这个值，为什么呢？<br><img src="/2015/JVM/11.Java内存模型与线程/f2ee49ed-0384-4566-889b-74a923385b80.png" alt="img"><img src="/2015/JVM/11.Java内存模型与线程/7b5e6a79-61d5-4378-ba2f-4ebe10c86d2a.png" alt="img"></p>
<p>  问题就出现在自增运算”inc++”中，该行代码在Class文件中是由4条字节码指令构成的，(return指令不是有inc++产生的，这条指令可以不计算)，从字节码中分析出：当getstatic指定把inc的取值到操作栈顶时，volatile关键字保证了inc的值在此时时正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把inc的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic执行执行后就可能把较小的inc值同步回主内存之中。</p>
<p>  由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p>而在下面所示的这类场景就很适合使用volatile变量来控制并发，当shutdown()方法被调用时,能保证所有线程中执行的doWork()方法都立即停下来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!shutdownRequested)&#123;</span><br><span class="line">            <span class="comment">//do stuff</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>第二禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能在取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 因为在一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的”线程内表现为串行的语义(Within-Thread As-if-Setial Semantics)。</strong></p>
<h3 id="原子性-可见性与有序性"><a href="#原子性-可见性与有序性" class="headerlink" title="原子性 可见性与有序性"></a>原子性 可见性与有序性</h3><p>Java内存模型是围绕着在在并发过程中如何处理原子性、可见性与有序性3个特征来建立。</p>
<p><strong>原子性(Atomicity):</strong>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write,我们大致可以认为基本数据类型的访问读写是具备原子性的(例外就是long和double的非原子性协定，但在目前商用Java虚拟机中不会出现)，如果应用场景需要一个更大范围的原子性保证，java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
<p><strong>可见性(Visibility)</strong>:当一个线程修改了共享变量的值，其他线程能立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。    </p>
<p>​    除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去(this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见final字段的值。</p>
<p><strong>有序性(Ordering):</strong>如果在本线程内观察，所有的操作部是有序的；如果在一个线程中中观察另一个线程，所有的操作都是无序的。前半句是指”线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics),后半句是指”指令重排序”现象和”工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h3 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则(happens-before)"></a>先行发生原则(happens-before)</h3><p>​    先行发生时Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。    </p>
<p>​    另外，Java内存模型具备一些天然的先行发生关系，即不需要通过任何手段就能够得到保证的有序性。如果两个操作的执行次序无法从happens-before原则推导出来， 它们就没有顺序性保障，虚拟机可以随意地对它们进行重排序。重排序并不影响程序执行的逻辑结构和顺序。</p>
<ul>
<li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
</li>
<li><p>管程锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作，强调同一个锁，而“后面”是指时间上的先后顺序。\</p>
</li>
<li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作，“后面”是指时间上的先后顺序。</p>
</li>
<li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作。</p>
</li>
<li><p>线程终止规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</p>
</li>
<li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成先行(构造函数执行结束)发生于他的finalize()方法的开始。</p>
</li>
<li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p>
</li>
</ul>
<p>总结：一个操作“时间上的先发生”不代表这个操作先行发生；一个操作先行发生也不代表这个操作在时间上是先发生的（重排序的出现）。<strong>时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。</strong></p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a><strong>重排序</strong></h3><p>　　在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：</p>
<p><img src="/2015/JVM/11.Java内存模型与线程/5b33ff6f-fb57-4ba1-897e-2f8cf2fce076.png" alt="img"></p>
<p>为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：</p>
<p><img src="/2015/JVM/11.Java内存模型与线程/58f01be9-b5f8-41d5-b117-2e3f39a7e04c.png" alt="img"></p>
<h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>  进程是资源分配的基本单位，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start()且还未结束的java.lang.Thread类的实例就代表了一个线程。我们注意到Thread类与大部分的JavaAPI有显著的差别，它的所有关键方法都是声明为Native的。在JavaAPI中，一个Native方法往在意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关的手段）</p>
<p>实现线程主要有3种方式：<strong>使用内核线程实现</strong>、<strong>使用用户线程实现</strong>和<strong>使用用户线程加轻量级进程混合实现。</strong></p>
<h5 id="1-使用内核线程实现"><a href="#1-使用内核线程实现" class="headerlink" title="1.使用内核线程实现"></a><strong>1.使用内核线程实现</strong></h5><p>​    <strong>内核线程(Kernel-LevelThread,KLT)</strong>就是直接由<strong>操作系统内核（Kernel，下称内核）</strong>支持的线程，这种线程由内核来完成线程切换，内核通过操纵<strong>调度器（Scheduler)</strong>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-ThreadsKernel)。    </p>
<p>​    程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口一<strong>轻量级进程（LightWeightProcess，LWP)</strong>,轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型。      </p>
<p>​    由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：</p>
<p>​    首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态(UserMode）和内核态（KernelMode)中来回切换。</p>
<p>​    其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。<br>      <strong>对于SunJDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。</strong></p>
<p><img src="/2015/JVM/11.Java内存模型与线程/d8285364-48e9-47c4-909b-40887f6e2f0a.jpg" alt="img"></p>
<h5 id="2-使用用户线程实现"><a href="#2-使用用户线程实现" class="headerlink" title="2.使用用户线程实现"></a><strong>2.使用用户线程实现</strong></h5><p>​    从广义上来讲，一个线程只要不是内核线程，就可以认为是<strong>用户线程(UserThread,UT),</strong>因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现.。用户线程的建立、同步、销毁和度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态．因此操作可以是非常快速且低消耗的，也可以支特规模更大的线程数量，部分高性能数数据库中的多线程就是由用户线程实现的。</p>
<p>​    这种进程与用户线程之间1：N的关系称为一对多的线程模型，使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程字自己处理·线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上“这类问题解决起来将会异常难，甚至不可能完成·因而使用用户线程实现的程字一般都比较复杂除了以前在不支持多线程的操作系统中（如DOS）的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。</p>
<p>​                                        <img src="/2015/JVM/11.Java内存模型与线程/d097bf0f-b077-46b9-97c9-2a508714555d.jpg" alt="img"></p>
<h5 id="3-使用用户线程加轻量级进程混合实现"><a href="#3-使用用户线程加轻量级进程混合实现" class="headerlink" title="3.使用用户线程加轻量级进程混合实现"></a><strong>3.使用用户线程加轻量级进程混合实现</strong></h5><p>​    线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中。因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险·在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系，这种就是多对多的线程模。许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了N：M的线程模实现。</p>
<p>​                              <img src="/2015/JVM/11.Java内存模型与线程/d5da56da-1483-4252-bccf-37ea6f3c8686.jpg" alt="img"></p>
<h4 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h4><p>线程调度是指系统为线程分配处理器使用权的过程。</p>
<p><strong>协同式线程调度(CooperativeThreads-Scheduling)</strong>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</p>
<p><strong>抢占式线程调度(Preemptive Threads-Scheduling)</strong> 每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。</p>
<p><strong>线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，不建议在java程序中修改线程优先级。</strong></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>10.JVM_Server模式与Client模式</title>
    <url>/2015/JVM/10.JVM_Server%E6%A8%A1%E5%BC%8F%E4%B8%8EClient%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>JVM Server模式与Client模式启动，最主要的差别在于：</p>
<p>Server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。JVM如果不显式指定是-Server模式还是-client模式，JVM能够根据下列原则进行自动判断（适用于Java5版本或者Java以上版本）。原因是:</p>
<p>当虚拟机运行在-client模式的时候,使用的是一个代号为C1的轻量级编译器, </p>
<p>当虚拟机运行在-server模式的时候,使用的是一个代号为C2的重量级编译器。C2比C1编译器编译的相对彻底,,服务起来之后,性能更高.</p>
<p>Client、Server模式默认GC</p>
<table>
<thead>
<tr>
<th></th>
<th>新生代GC方式</th>
<th>老年代和永久<strong>代</strong>GC方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Client</td>
<td>Serial 串行GC</td>
<td>Serial Old 串行GC</td>
</tr>
<tr>
<td>Server</td>
<td>Parallel Scavenge 并行回收GC</td>
<td>Serial Old (PSMarkSwcep)串行GC (待验证)</td>
</tr>
</tbody>
</table>
<p>java -version 可以直接查看出你使用的是client还是 server</p>
<p>Jvm client代码:</p>
<p><img src="/2015/JVM/10.JVM_Server模式与Client模式/7ca3829a-fede-47ec-86e4-8f2373dffd19.png" alt="img"></p>
<p>Jvm server代码:</p>
<p><img src="/2015/JVM/10.JVM_Server模式与Client模式/d9cb1b1d-2055-4d2e-b516-5225f848f168.png" alt="img"></p>
<p>两种模式的切换可以通过更改配置(jvm.cfg配置文件)来实现:<br>32位的虚拟机在目录JAVA_HOME/jre/lib/i386/jvm.cfg,<br>64位的在JAVA_HOME/jre/lib/amd64/jvm.cfg, 目前64位只支持server模式,  配置内容大致如下</p>
<p><img src="/2015/JVM/10.JVM_Server模式与Client模式/0f284ef4-dd16-4ebe-8aa3-2a2b557e5346.png" alt="img"></p>
<p>一般只要变更 -server KNOWN 与 -client KNOWN 两个配置位置先后顺序即可,前提是JAVA_HOME/jre/bin 目录下同时存在 server 与client两个文件夹,分别对应着各自的jvm.<br>缺少其中一个,切换模式就会报错.类似下图:</p>
<p><img src="/2015/JVM/10.JVM_Server模式与Client模式/4670e1f1-c29a-4eda-895e-230286a95f73.png" alt="img"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>12.线程安全与锁优化</title>
    <url>/2015/JVM/12.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>面向对象和面向过程的区别</p>
<p>  <strong>面向过程</strong>一种以事件为中心的编程思想，以功能（行为）为导向，按模块化的设计，就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。这种思维方式是站在计算机的角度去抽象问题和解决问题。</p>
<p>  <strong>面向对象</strong>一种以事物为中心的编程思想，以数据（属性）为导向，将具有相同一个或者多个属性的物体抽象为“类”，将他们包装起来；而有了这些数据（属性）之后，我们再考虑他们的行为（对这些属性进行什么样的操作），是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。这种思维方式是站在现实世界的角度去抽象问题和解决问题。</p>
<h2 id="java语言中的线程安全"><a href="#java语言中的线程安全" class="headerlink" title="java语言中的线程安全"></a>java语言中的线程安全</h2><p>笔者认为(JavaConcurrencyInPractice)的作者BrianGoetz对“线程安全”有一个比较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。    将Java语言中各种操作共享数据范围内5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p>
<h3 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1.不可变"></a>1.不可变</h3><p>​    在Java语言中（特指JDK1.5以后，即Java内存模型被修正之后的Java语言），不可变(Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不,需要再采取任何的线程安全保障措施，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最简单和最纯悴的。</p>
<p>​    Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，例如java.lang.String类的对象，它是一个典型的不可变对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。还有枚举类行、java.long.Number的部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型。</p>
<h3 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2.绝对线程安全"></a>2.绝对线程安全</h3><p>​    Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全，例如java.util.Vector是一个线程安全的的容器它的add(),get()和size()方法都是被synchronized()修饰的，但是它要在调用端做额外的同步措施，否则也不是线程安全的。</p>
<h3 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3.相对线程安全"></a>3.相对线程安全</h3><p>​    相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等</p>
<h3 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4.线程兼容"></a>4.线程兼容</h3><p>​    线程兼容是指对像本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对像在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。JavaAPI中大部分的类都是属于线程兼容的，如与前面的Vector和HashTabIe相对应的集合类Arraylist和HashMap等。</p>
<h3 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5.线程对立"></a>5.线程对立</h3><p>​    线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而通常都是有害的，应当尽量避免。</p>
<p>​    一个线程对立的例了是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话·无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()屮断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因suspend()和resume()方法已经被JDK声明废弃(@Deprecated)了。常见的线程对立的操作还有System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()等。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1.互斥同步"></a>1.互斥同步</h3><p>​    互斥同步是常见一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，<strong>临界区（CriticalSection）、互斥量(Mutex)和信号量(Semaphore)</strong>都是主要的互斥实现方式。因此，在这4个字里面，<strong>互斥是因，同步是果；互斥是方法，同步是目的</strong>。</p>
<p>​    在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后·会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对像。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference;如果没有明确指定，那就根据synchromzed修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1,相应的，在执行monitorexit指令时会将锁计数器减1,当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 </p>
<p>   在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的或方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个重量级（Heavyweight）的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化。譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。</p>
<p>​    除了synchromzed之外，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁(ReentrantLock)来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别·一个表现为API层面的互斥锁(lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比synchronized，ReentrantLock增加了一些高级功能．主要有以下3项：等待可中断、可实现公平锁以及锁可以绑定多个条件。</p>
<p>​    <strong>优先考虑使用synchronized来进行同步。</strong></p>
<h3 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2.非阻塞同步"></a>2.非阻塞同步</h3><p>​    互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为<strong>阻塞同步（BlockingSynchronization）</strong>。从处理问题的方式上说，互斥同步属于一种<strong>悲观的并发策略</strong>，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竟争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>​    随着硬件指令集的发展，基于冲突检测的<strong>乐观并发策略</strong>，通俗地说，就是先进行操作,如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为<strong>非阻塞同步</strong>（Non-BlockingSynchronization)</p>
<p>​    为什么笔者说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？<strong>因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。</strong></p>
<h3 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h3><p>​    要保证线程安全，并不是一定就要进行同步，两者没有因果关系·同步只是保证共享数据争用时的正确性的手段．如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。</p>
<p><strong>可重入代码（Reentrant Code）</strong>：这种代码也叫做纯代码（PureCode)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重人性是更基本的特性，它可以保证线程安全，即所有的可重人的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。可重人代码有一些共同的特征，例如不依賴存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传人、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据。就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p>
<p><strong>线程本地存储（Thread Local Storage）</strong>：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题，符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者一消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的=一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线”（Thread-per-Request）的处理方式。这种处理方式的广泛应用使得很Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a><strong>锁优化</strong></h2><h3 id="1-自旋锁与自适应自旋"><a href="#1-自旋锁与自适应自旋" class="headerlink" title="1.自旋锁与自适应自旋"></a><strong>1.</strong>自旋锁与自适应自旋</h3><p>​    互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，<strong>我们只需让线程执行一个忙循环（自旋），这项技术就是所渭的自旋锁</strong>。</p>
<p>​    使用-XX:+UseSpinning来开启，在JDK1.6中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。</p>
<p>​    在JDK1.6中引入了自适应的自旋锁，自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确·虚拟机就会变得越来越“聪明”了。</p>
<h3 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2.锁消除"></a><strong>2.</strong>锁消除</h3><p>​    锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竟争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的。同步加锁自然就无须进行。</p>
<p>​    我们也知道，由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编泽器会对String连接做自动优化。在JDK1.5之前，会转化为StringButffer对象的连续append()操作，在JDK1.5及以后的版本中，会转化为StringBuilder对象的连续append()操作。<img src="/2015/JVM/12.线程安全与锁优化/e704bd72-3aef-440a-9e1d-d3a867f623f5.jpg" alt="img"></p>
<p><img src="/2015/JVM/12.线程安全与锁优化/1d9b2ca1-808d-431d-ba94-a7e949b3790a.jpg" alt="img"></p>
<p>每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，很快就会发现它的动态作用域被限制在concatstring()方法内部。也是说，sb的所有引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<h3 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3.锁粗化"></a><strong>3.</strong>锁粗化</h3><p>​    原则上，我们在写代码的时候，总是推荐将同步块的作用范围限制得尽量小一只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竟争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竟争，频繁地进行互斥同步操作也会导致不必要的性能损耗。上面连续的append()方法就属于这类情况，如果虚拟机探测到有这样一串零碎的操作都对同一个对像加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。以上面为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。</p>
<h3 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4.轻量级锁"></a><strong>4.</strong>轻量级锁</h3><p>​    轻量级锁是JDK1.6之中加人的新型锁机制．它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁·首先需要强调一点的是。轻量级锁并不是用来代替量级锁的，它的本意是在没有多线程竟争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。更改HotSpot虚拟机的对象头(Object Header)信息来实现加锁解锁操作。</p>
<p>​    轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁．在整个同步周期内都是不存在竟争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竟争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5.偏向锁"></a><strong>5.偏向锁</strong></h3><p>​    偏向锁也是JDK1.6中引人的一项锁优化，它的目的是消除数据在无竟争情况下的同步原，进一步提高程序的运行性能。如果说轻量级锁是在无竟争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竟争的情况下把整个同步都消除掉．连CAS操作都不做了·<br>​    偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个。获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。<br>​    偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡(Trade Off)性质的优化，它并不一定总是对程序运行有利．如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>3.垃圾收集器与内存分配策</title>
    <url>/2015/JVM/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>垃圾收集 Garbage Collection, GC</p>
<p>1960 年诞生于 MIT的Lisp 是第一门真正使用内存动态分配和垃圾收集的技术语言。</p>
<p>程序计数器，本地方法栈、虚拟机栈为线程私有，随线程生成和毁灭。</p>
<p>java堆，方法区为线程共享，为垃圾收集器主要回收范围。</p>
<h2 id="引用计数算法（Referece-Counting）"><a href="#引用计数算法（Referece-Counting）" class="headerlink" title="引用计数算法（Referece Counting）"></a>引用计数算法（Referece Counting）</h2><p>给对象中添加一个引用计数器，当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。</p>
<p>任何时刻计数器为0的对象就是不可能再被使用。</p>
<p>实现简单，判定效率高，大部分情况下不错。但不能解决对象之间相互循环引用的问题。</p>
<h4 id="可达性分析方法（Reachability-Analysis）"><a href="#可达性分析方法（Reachability-Analysis）" class="headerlink" title="可达性分析方法（Reachability Analysis）"></a>可达性分析方法（Reachability Analysis）</h4><p>在主流的商用程序语言中（Java、C#、Lisp）的实现中，都是采用可达性分析来判定对象是否存活的。通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（GC Roots到这个对象不可达）时，就证明这个对象是不可用的。</p>
<p>Java中，可作为GC Roots的对象包括全局性的引用〈例如常量或类静态属性）与执行上下文〈例如栈帧中的本地变量表)：</p>
<p>1.虚拟机栈（栈帧中的本地变量表）中引用的对象</p>
<p>2.方法区中类静态属性引用的对象</p>
<p>3.方法区中常量引用的对象</p>
<p>4.本地方法栈中JNI（即Nateive方法）引用的对象。</p>
<h4 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h4><p>在JDK1.2 以前Java中的引用的定义很传统。如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称</p>
<p>这块内存代表者一个引用.这种定且很纯粹，但是太过狭隘，一个对象在这种定且下只有被引用或者没有被引用两种状态。</p>
<p>JDK1.2之后，引用分为：</p>
<ol>
<li><p><strong>强引用(Strong Reference)</strong> 在程序代码中普遍存在，Object obj = new Object()这类的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。</p>
</li>
<li><p><strong>软引用(Soft Reference)</strong> 有用但非必须的对象，在系统将要内存溢出前，将会把这些对象进行二次回收。</p>
</li>
<li><p><strong>弱引用(Weak Reference)</strong> 非必须的对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</p>
</li>
<li><p><strong>虚引用(Phantom Reference)</strong> 幽灵引用或幻影引用，对象是否有虚引用，不会对生存时间构成影响，无法通过虚引用取得一个对象实例，为对象设置虚引用关联是为了能在这个对象呗收集器回收的时候能收到一个系统通知。</p>
</li>
</ol>
<p><img src="/2015/JVM/3.垃圾收集器与内存分配策略/d79a16a1-8586-4703-8614-6c6762c7df16.png" alt="img"><img src="/2015/JVM/3.垃圾收集器与内存分配策略/e2641d89-6e1a-4231-8013-8121cabf5e6c.png" alt="img"></p>
<p><img src="/2015/JVM/3.垃圾收集器与内存分配策略/d663a9d5-5c7a-4142-8225-8b1394246727.png" alt="img"></p>
<p><img src="/2015/JVM/3.垃圾收集器与内存分配策略/e9b14844-e3c9-41e0-b2f7-b1c738c7458b.png" alt="img"></p>
<p><img src="/2015/JVM/3.垃圾收集器与内存分配策略/a688e9e8-6ada-48e4-84bb-a053e66da7bb.png" alt="img"></p>
<p><img src="/2015/JVM/3.垃圾收集器与内存分配策略/76b69d28-13a0-43b6-b05b-5aaf99898e60.png" alt="img"><img src="/2015/JVM/3.垃圾收集器与内存分配策略/15b42407-04f7-4bb3-9cd2-c60646410ffb.png" alt="img"></p>
<p><img src="/2015/JVM/3.垃圾收集器与内存分配策略/57d4a08f-1b21-4ef9-840c-0a8929307cfc.png" alt="img"></p>
<p>永久代的垃圾收集主要回收部分为： 废弃常量和无用的类。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除算法-Mark-Sweep"><a href="#1-标记-清除算法-Mark-Sweep" class="headerlink" title="1.标记-清除算法(Mark-Sweep)"></a>1.标记-清除算法(Mark-Sweep)</h3><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被被标记的对象。</p>
<p>缺点：效率不高，碎片太多，不利于大对象分配。</p>
<p><strong>垃圾收集器两次标记
</strong>i. 对象在进行可达性分析后发现没有与GCRoots相连接的引用链!那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法. 当对象没有覆盖覆盖finalize()方法，或者finalize()方法已虽被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”，</p>
<p>ii. 如果这个时象被判定为有必要执行finaliz()方法,那么这个时象将会放置在一个叫F-Queue的队列中，在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它. GC将对F-Queue中的对象进行第二次小规模标记，如果对象没有在finalize()中拯救自己，那么将会被回收。</p>
<h3 id="2-复制算法-Copying"><a href="#2-复制算法-Copying" class="headerlink" title="2.复制算法(Copying)"></a>2.复制算法(Copying)</h3><p>它将整个可用内存一分为二，每次只使用其中的一块。当这一块的内存用完了，就将还存活的时象制到另外一块上去.然后把已使用过的这半块内存空间一次清理掉. 每次回收半个内存，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针， 据顺序分配内存即可。实现简单，运行高效. 缺点内存缩小一半，代价太高。<br>Hotspot中用此法回收新生代，内存比例分为8:1:1（Eden Survivor Survivor）,每次使用一块Eden和一块Survivor,占内存90%,由于新生代中大部分对象（98%）“朝生夕死”，所以一次清理Eden和Survivor空间，将存活的对象(2%)复制到另一个Survivor区域，大部分情况下是足够的，当Survivor空间不够用时，需要依赖其他内存(老年代) 进行分配担保(Handle Promotion)。</p>
<p>-XX:+HandlePromotionFailure 是否允许新生代收集担保，进行一次minor gc后, 另一块Survivor空间不足时，将直接会在老年代中保留</p>
<h3 id="3-标记-整理算法-Mark-Compact"><a href="#3-标记-整理算法-Mark-Compact" class="headerlink" title="3.标记-整理算法(Mark-Compact)"></a>3.标记-整理算法(Mark-Compact)</h3><p>标记过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的时象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="4-分代收集算法-Generational-Collection"><a href="#4-分代收集算法-Generational-Collection" class="headerlink" title="4.分代收集算法(Generational Collection)"></a>4.分代收集算法(Generational Collection)</h3><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存则分为几块. 一般是把Java堆分为新生代和老年代。可以根据各个年代的特点采用适当的收集算法. 在新生代中 每次垃圾收集时都发现有大批对象死去，只有少量存话，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<p><strong>Stop The world</strong>  GC进行时必须停顿所有Java执行线程，确保GC在一致性快照中进行。是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性无法得到保证。</p>
<p><strong>安全点(Safepoint)  程序停顿点，</strong>安全点的选定基本上以程序“是否具有让程序长时间执行的特征” 为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长的原因而长时间运行，”长时间执行”的最明显特征就是指令序列复用，例如方法调用、 循环跳转、异常跳转等，所以具有这些功能的指令才生产生Safepoint。</p>
<p><strong>安全区域（Safe Region）</strong>是指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任何地方开始GC都是安全的。用于解决程序不执行就是没有分配CPU时间，线程处于Sleep状态和Blocked状态时，无法响应JVM中断请求，进行自动挂起。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>​                                            HotSpot虚拟机的垃圾收集器                      <img src="/2015/JVM/3.垃圾收集器与内存分配策略/4d93f4ce-a8e2-4092-bbdb-c6460460c564.jpg" alt="img"><br>上面有7中收集器，分为两块，上面为新生代收集器，下面是老年代收集器。如果两个收集器之间存在连线，就说明它们可以搭配使用。</p>
<h3 id="1-Serial-串行GC-收集器"><a href="#1-Serial-串行GC-收集器" class="headerlink" title="1.Serial(串行GC)收集器"></a>1.Serial(串行GC)收集器</h3><p>Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单 线程收集效率。</p>
<p>​                        <img src="/2015/JVM/3.垃圾收集器与内存分配策略/edc39568-79f4-4b3a-a264-dc9bca718653.png" alt="img">                                         <strong>图为Serial/Serial Old收集器运行示意图</strong>     </p>
<p>-XX:+SurvivorRatio  新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Subrvivor = 8:1</p>
<p>-XX:+PretenureSizeThreshold  直接晋升到年老代的对象大小，设置此参数后，超过该大小的对象直接在年老代中分配内存-XX:+MaxTenuringThreshold   直接晋升到年老代的对象年龄，每个对象在一次Minor GC之后还存活，则年龄加1，当年龄超过该值时进入年老代</p>
<h3 id="2-ParNew-并行GC-收集器"><a href="#2-ParNew-并行GC-收集器" class="headerlink" title="2.ParNew(并行GC)收集器"></a>2.ParNew(并行GC)收集器</h3><p>ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。<br>许多运行在Server模式下的虚拟机中首先的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。<br>                         <img src="/2015/JVM/3.垃圾收集器与内存分配策略/9fd18455-0ea9-4251-8685-2b8069021d4d.png" alt="img"><br>                                      图为ParNew/Serial Old收集器运行示意图<br>-XX:ParallelGCThreads  设置并行GC进行内存回收的线程数</p>
<p>并发(Concurrent)是在同一时段发生，实际微观上线程先后执行的，但宏观上感觉两者同时执行。</p>
<p>并行(Parallel)是两线程在同一时刻发生。</p>
<h3 id="3-Parallel-Scavenge-并行回收GC-收集器"><a href="#3-Parallel-Scavenge-并行回收GC-收集器" class="headerlink" title="3.Parallel Scavenge(并行回收GC)收集器"></a>3.Parallel Scavenge(并行回收GC)收集器</h3><p>Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器，也叫“吞吐量优先”收集器，parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。示意图和ParNew类似。</p>
<p>-XX:+MaxGCPauseMillis   Parallel Scavenge收集器最大垃圾收集停顿时间，大于零的毫秒数。</p>
<p>-XX:+GCTimeRation      Parallel Scavenge收集器运行时间占总时间比率。GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占且总时间的比率。相当于是吞吐量的倒数.如果把此参数设置为19，那允许的最大 GC 时间就占总时间的5%（即1/(1+19)）,默认值我99，就是允许最大1%（即1/(1+99)）的垃圾收集时间。</p>
<p>-XX:+ParallelGCThreads  设置并行GC时进行内存回收的线程数。</p>
<p>-XX:+UseAdaptiveSizePolicy  GC自适应调节策略(GC Ergonomics)，动态调整年老代对象年龄和各个区域大小。不需要设置新生代的大小(-Xmn)、Eden与Survivor区比例(-XX:SurvivorRatio)晋升老年代对象年龄(-XX:PretenureSizeThreshold)等参数。</p>
<h3 id="4-Serial-Old-串行GC-收集器"><a href="#4-Serial-Old-串行GC-收集器" class="headerlink" title="4.Serial Old(串行GC)收集器"></a>4.Serial Old(串行GC)收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。</p>
<h3 id="5-Parallel-Old-并行GC-收集器"><a href="#5-Parallel-Old-并行GC-收集器" class="headerlink" title="5.Parallel Old(并行GC)收集器"></a>5.Parallel Old(并行GC)收集器</h3><p>parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑优先与虑 Parallel Scavenge加Parallel Old收集器。<br>                             <img src="/2015/JVM/3.垃圾收集器与内存分配策略/e030ada0-1cf3-457f-9d92-f467ee3ae0fa.jpg" alt="img">                                            图为Parallel Scavenge/ Parallel Old收集器运行示意图</p>
<h3 id="6-CMS-并发GC-收集器"><a href="#6-CMS-并发GC-收集器" class="headerlink" title="6.CMS(并发GC)收集器"></a>6.CMS(并发GC)收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤：  </p>
<p>①.初始标记(CMS initial mark)   <strong>需要停顿其他用户线程(Stop The World)</strong>,初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快。  </p>
<p>②.并发标记(CMS concurrenr mark)   并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。  </p>
<p>③.重新标记(CMS remark)   <strong>需要停顿其他用户线程(Stop The World)</strong>, 重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一 部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。  </p>
<p>④.并发清除(CMS concurrent sweep)     由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。    </p>
<p>CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，    </p>
<p>CMS收集器的 缺点：CMS收集器对CPU资源非常敏感。CMS收集器无法处理浮动垃圾。CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后,会产生大量碎片。                             <img src="/2015/JVM/3.垃圾收集器与内存分配策略/6d4a6f13-4eb8-4971-9bdb-6eac373697af.png" alt="img">                                               </p>
<p>图为Concurrent Mark Sweep收集器运行示意图<br>-XX:CMSInitiatingOccupancyFraction  当老年代使用设定值的空间后就会被激话，进行垃圾回收，设置太高容易导致”Concurrent Mode Failure” 失败， 性能反而降低。</p>
<p>-XX:+UseCMSCompactAtFullCollection  默认开启，CMS进行一次Full GC的同时，开启内存碎片合并整理过程，响应时间变长。<br>-XX:+CMSFullGCBeforeCompaction  每次都进行内存随便合并整理的话，时间太长，设置此值，在进行几次不压缩的Full GC之后，进行一次带有内存碎片整理的，通常与UseCMSCompactAtFullCollection参数一起使用</p>
<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3><p>G1(Garbage First)收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。还有一个特点之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代，老年代)。用G1收集器时. Java堆的内存布局就与其他收集器有很大差别，<strong>它将整个lava堆划分为多个大小相等的独立区域(Region)</strong>，虽然还保留有新生代和老年代的概念，但新生代和 老年代不再是物理隔离的了，它们都是一部分Region (不需要连续〉的集合。    </p>
<p>GI 跟踪各个Region里面的垃披堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值) 在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region (这也就是Garbagc-First名称的来由). 这种使用Region划分内存空间记忆有优先级的区域回收主式，保证了G1收集器在有限的时间内可以尽可能高的收集效率。   </p>
<p> G1 收集器的运作大致可划分为以下几个步骤,和CMS很相似：</p>
<blockquote>
<p> 初始标记(lnitial Marking) </p>
<p> 并发标记(Concurrent Marking) </p>
<p> 最终标记(Final Marking) </p>
<p> 筛选回收(Live Data Counting and Evacuation)</p>
</blockquote>
<h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+&lt;option&gt; 启用选项</span><br><span class="line">-XX:-&lt;option&gt; 不启用选项</span><br><span class="line">-XX:&lt;option&gt;=&lt;number&gt; </span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;</span><br><span class="line">Sun/oracle JDK GC组合方式</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>新生代GC方式</th>
<th>老年代和永久<strong>代</strong>GC方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>Serial 串行GC</td>
<td>Serial Old 串行GC</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>Parallel Scavenge  并行回收GC</td>
<td>SerialOld (PSMarkSwcep)串行GC(待验证)</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>ParNew 并行GC</td>
<td>CMS 并发GC  当出现“Concurrent Mode Failure”时 采用Serial Old 串行GC</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>ParNew 并行GC</td>
<td>Serial Old 串行GC</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>Parallel Scavenge  并行回收GC</td>
<td>Parallel Old 并行GC</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</td>
<td>Serial 串行GC</td>
<td>CMS 并发GC  当出现“Concurrent Mode Failure”时 采用Serial Old 串行GC</td>
</tr>
</tbody>
</table>
<p>Client、Server模式默认GC</p>
<table>
<thead>
<tr>
<th></th>
<th>新生代GC方式</th>
<th>老年代和永久<strong>代</strong>GC方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Client</td>
<td>Serial 串行GC</td>
<td>Serial Old 串行GC</td>
</tr>
<tr>
<td>Server</td>
<td>Parallel Scavenge 并行回收GC</td>
<td>Serial Old (PSMarkSwcep)串行GC (待验证)</td>
</tr>
</tbody>
</table>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），HotSpot虚拟机中，将堆和方法区设定为新生代 Yong Generation（堆），老年代 Old Generation（堆），永久代Permanent Generation（方法区），主要在这些地方进行分派。</p>
<p><img src="/2015/JVM/3.垃圾收集器与内存分配策略/ffb82734-d81b-4a7b-ab37-ab0e66c31612.png" alt="46ca5791-5c7f-365a-bb1c-171ddc03b5b5.png">    <img src="/2015/JVM/3.垃圾收集器与内存分配策略/8c3d9678-728c-4298-8c4b-1f2a0706bc8a.jpg" alt="img"></p>
<p><strong>-Xms20m</strong> 堆最小值 <strong>-Xmx20m</strong> 堆最大值，相等时可避免堆自动扩展</p>
<p><strong>-XX:NewSize</strong>   新生成的池的初始大小.缺省值为2M。</p>
<p><strong>-XX:MaxNewSize</strong>   新生成的池的最大大小.缺省值为32M。</p>
<p><strong>-Xmn10M</strong>  新生代大小 堆大小为20M,所以老年代大小为10M,推荐使用的是-Xmn参数，这个参数很简洁，相当于一次性设定-XX:NewSize和-XX:MaxNewSize相等。</p>
<p><strong>-XX:SurvivorRatio=8</strong>   决定了新生代中Eden区与一个Survivor区的空间比例是8:1,故 eden sace 8192K from space 1024K to space 1024K 新生代且可用空间为9216KB (Eden区+1个Survivor区的总容量)  Eden与Survivor的占用比例。这里的8表示，一个survivor区占用 1/8 的新生代内存，因为survivor有2个，所以是 2/8，那么Eden的占比为 6/8。</p>
<p><strong>-XX:NewRatio=2</strong>    新生代和年老代的堆内存占用比例。这里的2表示，新生代占最大堆内存的1/2。也就是和年老代平分堆的占用。</p>
<p><strong>-XX:PermSize=10M  -MaxPermSize=10M</strong>   最大方法区容量 溢出时有”PermGen space”信息</p>
<p><strong>-XX:+PrintGCDetails</strong> 打印GC详细信息</p>
<p><strong>-XX:+PrintGCTimeStamps</strong> 打印GC停顿时间</p>
<p><strong>-XX:+PrintTenuringDistribution</strong></p>
<p><strong>新生代GC(Minor GC)</strong>       指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收这度也比较快。</p>
<p><strong>老年代GC(Major GC/Full GC)</strong> 指发生在老年代的GC。 同时也会对永久代进行GC。出现了MajorGC，经常会伴随至少一次的MinorGC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选持过程。Major GC的速度一舷会比Minor GC慢10倍以上。<br><strong>1.大多情况下，对象在新生代Eden区中分配</strong>，当Eden区没有足够空间进行分配时，虚拟机发起一次Minor GC，将活着的对象放入Survivor区，如果Survivor区没有足够空间，将通过分配担保机制提前将活着的对象放入老年代去，为新分配对象腾空间。</p>
<p><strong>2. 大对象直接进入老年代</strong>。所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串和数组。虚拟机提供了一个-XX:PretenureSizeThreshold=3145728(3M，只有数字)参数，令大于这个设置值的对象直接在老年代分配。避免在Eden区和两个Survivor区之间发生大量的内存复制。PretenureSizeThreshold只在Serial和ParNew两款收集器有效。</p>
<p><strong>3.长期存活的对象将进入老年代</strong>。对象有对象年龄计计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存在，并且能被Survovor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区每“熬过”一次Minor GC，年龄就增加1，当年龄增加到-XX:MaxTenuringThreshold设置的值(默认为15)后，将会被晋升到老年代中。</p>
<p><strong>4.动态对象年龄判定。</strong>为了能更好好地适应不同程序的内存壮况，虚拟机并不是永远地要求对象的年龄必须达到maxTenuringThreshold 才能晋升老年代 ，如果 Survivor 空间中相同年龄的所有时象大小之和大于 Survivor 空间的一半， 年龄大于或等于该年龄的时象就可且直接进入老年代，无须等到maxTenuringThreshold要求的年龄。</p>
<p><strong>5. 空间分配担保。</strong>新生代在进行Minnor GC前，检查老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行MinorGC，极端情况下所有对象都存活，Survivor空间放不下，将把这些对象放入老年代（保证放的下）。否则将进行 Full GC。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Java内存区域</title>
    <url>/2015/JVM/2.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>Java 虚拟机所管理的内存将会包括以下几个运行时数据区域:<br>有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="/2015/JVM/2.Java内存区域/7f860cf4-03c6-4825-87fd-3b625ba14114.png" alt="img"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>当前线程所执行的字节码的行号指示器。为线程私有内存。<br>如果线程正在执行的是 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址 。<br>如果正在执行的是 Native 方法，这个计数器值则为空 (Undefined)。<br>此内存区域是唯一 一个在 Java 虚拟机规范中没有且应任何 OutOfMemoryError 情况的区域。</p>
<h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>  为线程私有内存，它的生命周期和线程相同。每个方法在执行的同时都会创建一个栈帧 (Stack Frame) 用于存储局部变量表、操作数栈.动在链接、方法出口等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。平时把java内存区域分成的堆内存(heap)和栈内存(Stack),比较粗糙，其中的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。局部变量表存放了编译器可知的各种基本数据类型 、对象引用和returnAddress类型〈指向了一条字节码指令的地址)。<br>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。<br>如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常。<br>如果虚拟机栈可以动态扩展，且扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>  本地方法栈与虚拟机栈所发挥的作用是非常相似的，也是线程私有，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法〈也就是字节码〉服务，而本地方法栈则为虚拟机使用到的 Native 方法服务 。在Sun HotSpot 虚拟机中直接就把本地方法栈和 虚拟机栈合二为一  。本地方法也会抛出StackOverflowError异常和OutOfMemoryError异常。</p>
<h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>  是java虚拟机所管理的内存中最大的一块。为所有线程共享，在虚拟机启动时创建，用于存放对象实例和数组。但随着JIT编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换优化技术将会导致一些变化，所有对象在堆上分配也不是那么绝对了。<br>  java堆为垃圾收集器管理的主要区域，也被成为“GC堆(Garbage Collected Heap)”,在分代收集算法中，Java堆可分为新生代和老年代，再细致可分为Eden空间、From Survivor空间、To Survivor空间。从内在分配的角度来看，线程共享Java 堆中 可能划分出多个线程私有的分配缀冲区 (Thread Local Allocation Buffer TLAB)。<br>  可以通过-Xmx和-Xms参数控制大小，可抛出OutOfMemoryError异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>为线程共享区域 用于存储虚拟机加载的类信息、常量、静态变量 即时编译器编译后的代码等数据 。<br>虽然Java虚拟机把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap (非堆).目的应该是与 Java 堆区分开来。<br>对于HotSpot虚拟机，把GC分代收集扩展至方法区，或者说使用永久代实现方法区。方法区可称为“永久代”(Permanent Generation)<br>HotSpot的垃圾收集器可以向管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。<br>对于BEA JRockit、IBM J9等虚拟机来说并不存在永久代的概念。<br>对于该区域的内存回收主要目标是常量池的回收和对类型的卸载，一般成绩比较难以令人满意。<br>可以用-XX:MaxPermSize参数控制大小，会抛出OutOfMemoryError异常。<br>运行时常量池<br>  方法区的一部分 Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有项信息是常量池 (Constant Pool Table) ，用于存放编译期生成的各种字面量和符号引用。这部分内容将在在家后进入方法区的运行时常量池中存放.，不同的提供商实现的虚拟机可出按照向己的需要来实现这个内存区域。<br>  会抛出OutOfMemoryError异常。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>  直接内存 并不是虚拟机运行时数据区的一部分即非堆内存，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。对于非堆内存，只能等到老年代满了后Full GC，然后才会帮它清理掉废弃的对象，否则，就会抛出内存溢出异常。<br>JDK 1.4中新加入了 (New Input/Ouput)类，引入了一种基于通道(Channel)与缓冲区 (Buffer) I/O 方式，它使用 native 函数库直接分配堆外内存，然后通过存储在 Java 堆中的 DirectByteBuffer对象作为这块内存的引用进行操作。能显著提高性能，因为避免了在 Java 堆和 Native堆中来回复制散据。<br>  本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存〈包括 RAM以及SWAP区或者分页文件〉大小以及处理器寻址空间的限制。管理员在配置虚拟机参数时，会根据实际内存设置-Xmx 等参量信息，但经常忽略直接内存，使得各个内存区域且和大于物理内存(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。</p>
<hr>
<p>HotSpot虚拟机中对象创建 对象内存布局 对象的访问定位</p>
<p><strong>对象创建</strong></p>
<ol>
<li><p>检查指令参数能否在常量池中定位到一个符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，则执行类加载过程。</p>
</li>
<li><p>在堆中分配空间，分配的方式也有两种：</p>
<p>​    i. 第一种如果使用Serial、ParNew等带Compact过程的收集器的时候，Java内存中的堆都是规整的，只需把作为使用和未使用空间的分界点的指针移动一段距离就可以了，称为“指针碰撞”(Bump the pointer)<br>​    ii. 第二种如果使用CMS这种基于Mark-Sweep算法的收集器的时候，Java内存并不是规整的，虚拟机就要维护了一个列表来记录内存的使用情况，这种方式叫做“空闲列表”(Free List)的方式，进行分配。<br>​     虚拟机为对象分配空间是非常频繁的，如果同时为多个线程分配对象，就涉及到并发安全控制了。一般有两个解决方案：</p>
<p>​    (1)第一种是对分配内存空间动作进行同步-使用CAS配上失败重试的方式保证更新操作的原子性。</p>
<p>​    (2)第二种是把内存分配的动作分配在不同的空间中进行，既每个线程在Java堆中预先分配一小块内存，称之为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB使用完并需要分配新的TLAB的时候才需要同步锁定。</p>
</li>
<li><p>续集你将分配到的内存空间初始化为零值，不包括对象头。保证实例字段在java代码中不赋初始值也可直接使用。</p>
</li>
<li><p>虚拟机设置对象头信息，包括类的元数据，对象哈希码等。</p>
</li>
<li><p>java线程执行<init>方法，按照程序员的意愿进行初始化。</init></p>
</li>
</ol>
<p><strong>对象内存布局</strong></p>
<p>分为三块：对象头（Header）  实例数据（Instance Data）  对齐填充（Padding）</p>
<p><strong>对象访问</strong></p>
<p>目前主要访问方式有使用句柄和直接指针两种。如果使用句柄访问的话，那么 Java堆中将划分一块内存来作为句柄池， refcrence中存储的就是对象句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄来访问的好处就是 refcrence 中存储的是稳定的句柄地址，在对象被移动〈垃圾收集时移动对象是非常普遍的行为〉 时只会改变句柄中的实例数据指针 ，而reference 本身不需要修改。        </p>
<p>   <img src="/2015/JVM/2.Java内存区域/0c29e6f4-e5e5-4a3f-b32b-51fe9f697148.jpg" alt="img"></p>
<p>如果使用直接指针访问，那么 Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信且 reference中存储的直接就是对象地址 。使用直接指针的问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，虚拟机 Sun HotSpot  用第二种方式进行对象访问的。</p>
<p>​          <img src="/2015/JVM/2.Java内存区域/85a64cc3-cecc-4da4-bdd5-a96dc5154ce3.jpg" alt="img"></p>
<p>-Xms20m 堆最小值 -Xmx20m堆最大值，相等时可避免堆自动扩展</p>
<p>-Xmn10M 新生代大小 堆大小为20M,所以老年代大小为10M,由于-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1,故 eden sace 8192K from space 1024K to space 1024K 新生代且可用空间为9216KB (Eden区+1个Survivor区的总容量)</p>
<p>-Xss128k 栈大小，不区分java栈和本地方法栈</p>
<p>-XX:PermSize=10M  -MaxPermSize=10M 最大方法区容量 溢出时有”PermGen space”信息</p>
<p>-XX:MaxDirectMemorySize=10M 直接内存，不指定是和Java堆最大值-Xmx制定一样，出现异常时，dump文件比较小，但是用了NIO技术。</p>
<p>-XX:+HeapDumpOnOutOfMemoryError 溢出是生成dump文件</p>
<p>Eclipse Memory Analyzer</p>
<p>内存泄露（Memory Leak） 内存溢出（Memory Overflow）</p>
<p>​    每个线程分配到的栈容量越大，可建立的线程数量越少，建立线程使越容易把剩下的内存耗尽，会内存溢出。在不能减少线程数或者更换64位虚拟机的情况下只能通过减少最大堆和减少栈熔炼来换取更多线程</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>4.JDK监控和故障处理工具与调试</title>
    <url>/2015/JVM/4.JDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p> Sun JDK 监控和故障处理工具</p>
<p>  （1）jps：JVM process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</p>
<p>  （2）jstat：JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</p>
<p>  （3）jinfo：Configuration Info for Java，显示虚拟机配置信息</p>
<p>  （4）jmap：Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）</p>
<p>  （5）jhat：JVM Heap Dump Browser，用于分析headdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</p>
<p>  （6）jstack：Stack Trace for Java，显示虚拟机的线程快照。</p>
<p><strong>JConsole</strong> (java Monitoring and Management Console)  是一种基于JMX的可视化监视、管理工具。</p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/4c3f050a-275d-4f4d-b316-40ba102b5ab5.png" alt="img"></p>
<p>   非堆除了包括持久代外，非堆还包括了CodeCache代码缓存区，它主要用于存放JIT所编译的代码。如果代码缓存被占满，JVM会打印出一条警告消息，并切换到interpreted-only 模式：JIT编译器被停用，字节码将不再会被编译成机器码。CodeCache代码缓冲区的大小在client模式下默认最大是32m，在server模式下默认是48m，当然，这个值也是可以设置的，它所对应的JVM参数为-XX:ReservedCodeCacheSize=128m 和 -XX:InitialCodeCacheSize=128m。</p>
<p>  如果代码缓存不断增长，例如，因为热部署引起的内存泄漏，那么提高代码的缓存大小只会延缓其发生溢出。为了避免这种情况的发生，我们可以尝试一个有趣的新参数：当代码缓存被填满时让JVM放弃一些编译代码。通过使用-XX:+UseCodeCacheFlushing 这个参数，我们至少可以避免当代码缓存被填满的时候JVM切换到interpreted-only 模式。</p>
<p>  从5.0版本开始，Hotspot JVM中引入了一个称为类数据共享（Class Data Sharing，CDS）的特色功能。在JVM的安装过程中，安装程序加载一系列的关键JVM类到一个内存映射的共享档案中（memory-mapped shared archive），如rt.jar。CDS可以减少用于加载这些类的时间，从而提高JVM的启动速度，并允许不同的JVM实例共享这些类，减少内存的使用。</p>
<p>  对于使用class data sharing的JVM。Permanent Generation分为唯读(shared-ro)和读写(shared-rw)两个区域，和Perm Gen区域。</p>
<p><strong>VisualVM</strong> (All-in-One Java Troubleshooting Tool)  是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，并且可预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具Eclipse Memory Analyzer </p>
<p><strong>Eclipse Memory Analyzer Tool(MAT)</strong></p>
<p>​    虚拟机回收的内存包括堆内存和非堆内存，但是对于非堆内存，只能等到老年代满了后Full GC，然后才会帮它清理掉废弃的对象，否则，就会抛出内存溢出异常。另外，若打开了-XX:+DisableExplicitGC，则虚拟机不会对其进行回收。</p>
<p>​    垃圾收集进行时 虚拟机虽然会对 Direct memory 进行回收，但是 Direct Memory 却不能像新生代、老年代那样，监现空间不足了就通知收靠器进行垃圾回收</p>
<p>它只能等待老年代满了后 Full GC。然后”顺便地”帮它清理掉内存的废弃对象 否则它只能一直等到抛出内存溢出异常时，先catch掉，再在catch块里面”大喊”一声“Systcm  gc” 要是虚拟机还是不听(譬如打开 -XX:DisableExplicitGC开关),那就只能眼睁睁的看着堆中海油很多空闲内存，自己却不得不抛出内存异常了。</p>
<p>​    从实践经验的角度出发，除了Java堆和永久代之外，我们还应关注以下区域也会占用较多的内存，都受到操作系统的最大内存限制：</p>
<ul>
<li>Direct Memory：可通过-XX:MaxDirectMemeorySize调整大小，内存不足时抛出OutOfMemoryError或OutOfMemoryError:Direct buffer memory；</li>
<li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverFlowError(纵向无法分配，即无法分配新的栈帧)或StackOverFlowError:unable to create new native thread(横向无法分配，既无法建立新的线程)；</li>
<li>Socket缓存区：每个Socket连接都Recieve和Send两个缓存区，分别占大约37KB和25KB，无法分配时抛出IOException:Too many open files；</li>
<li>JNI代码：若代码中使用JNI调用本地库，那本地库使用的内存也不在堆中；</li>
<li>虚拟机和GC：虚拟机和GC代码的执行也要耗费一定的内存。</li>
</ul>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/74b948ba-822b-493c-bb44-e758b273fd80.jpg" alt="img"></p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/8b7fa0b2-389d-451c-bec1-572150c3dc3a.jpg" alt="img"></p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/1f41b9e1-9522-4208-9ed5-2e1c105760ff.jpg" alt="img"></p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/da10e107-a1cd-433b-99da-c5e2c83798f2.jpg" alt="img"></p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/59330162-1acc-4128-8864-beb5cb3f5a3c.jpg" alt="img"></p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/69255d2a-64a9-4637-8503-2b996ad0e0c8.jpg" alt="img"></p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/3175bb54-3c2f-4488-b696-9daa1e71293f.jpg" alt="img"></p>
<p><img src="/2015/JVM/4.JDK监控和故障处理工具与调试/17bcf01d-a954-4843-8fed-35c0251f25c0.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>5.class类文件的结构</title>
    <url>/2015/JVM/5.class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>平台无关性</strong>：Java虚拟机可以运行在各种平台上，保证“一次编写，到处运行”（write once,run anywhere）,实现了平台无关性。</p>
<p><strong>语言无关性</strong>：Java语言通过Javac编译器将源代码（<em>.java）编译成 字节码文件（</em>.class），JRuby语言通过jrubyc编译器将源代码（<em>.rb）编译成字节码文件（</em>.class），各种语言都可以通过自己的编译器将源代码编译成class文件，这种class文件支持一定的标准，可以运行在Java虚拟机上。这就实现了语言无关性。</p>
<p>一个16进制数需要4位2进制数进行描述，一个字节为8bit，可以表示2个16进制数。CA=1100 1010</p>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><p><strong>魔数</strong> 为class文件开头的四个字节的数据 CA FE BA BE</p>
<p><strong>版本号</strong> 接着魔数的四个字节，前两个为次版本号(Minor Version)，后两个为主版本号(Major Version)。</p>
<p><strong>常量池</strong> 常量池入口设置一次u2类型的数据，为常量池容量计数值（constant_pool_count）,常量池主要用来存放字面量（Literal）和符号引用（Symbolic References）</p>
<blockquote>
<p>符号引用包括：</p>
</blockquote>
<blockquote>
<p>​    类和接口的全限定名（Fully Qualified Name）</p>
<p>​    字段的名称和描述符（Descriptor）</p>
<p>​    方法额名称和描述符</p>
</blockquote>
<blockquote>
<p>Java代码在进行Javac编译的时候，并不像C和C++那样有”连接” 边一步骤，而是在虚拟机加载Class文件的时候进行动态链接. 也就是说， 在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、 方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用. 当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中. </p>
<p>动态语言调用类型 CONSTANT_MethodHandle_info  CONSTANT_MethodType_info  CONSTANT_InvokeDynamic_info</p>
<p><img src="/2015/JVM/5.class类文件的结构/c9d2fa88-06bf-434c-8509-c1c3027f66ca.jpg" alt="img"></p>
<p><img src="/2015/JVM/5.class类文件的结构/190b9510-4a39-4323-a48c-b0c82571389c.jpg" alt="img"></p>
</blockquote>
<p><strong>访问标志</strong> 常连池后紧接的2个字节位访问标志（access_flags）,标志是class还是接口，是否为public类型，是否为abstrac类，如果是类，是否为final修饰</p>
<p>​      <img src="/2015/JVM/5.class类文件的结构/dee5b8fb-f64d-4efb-b2a0-be8543135a9f.jpg" alt="img"></p>
<p><strong>类索引 父类索引和接口索引集合</strong>  前两个为u2类型数据，接口索引集合为一组u2类型的数据的集合。表示整个类的全限定名，父类名，实现的接口名。</p>
<p><strong>字段表集合（field info**</strong>）**</p>
<p><strong>方法表集合  类构造器<clinit>方法   实例构造器<init>方法</init></clinit></strong></p>
<p><strong>属性表集合</strong></p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a><strong>字节码指令</strong></h2><p><strong>加载和存储指令</strong> iload istore bipush wide</p>
<p><strong>运算指令</strong> iadd isub imul idiv irem(求余) ineg(取反)</p>
<p><strong>类型转换指令</strong> </p>
<p><strong>对象创建和访问指令</strong> new newarray getfield getstatic baload bastore arraylength  instanceof checkcast</p>
<p><strong>操作数栈管理指令</strong> pop dup swap</p>
<p><strong>控制转移指令</strong>  ifeq iflt ifle tableswitch lookupswitch goto jsr ret</p>
<p><strong>方法调用和返回指令</strong> </p>
<p>  invokevirtual指令 用于调用时象的实例方法，根据时象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式.</p>
<p>  invokeinterface指令 用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</p>
<p>  invokespecial 指令 用于调用一些需要特殊处理的实例方法 包括实例初始化化方法、私有方法和父类方法.</p>
<p>  invokestatic指令 用于调用类方法(slatic方法).</p>
<p>  invokeddynamic指令 用于在运行时动态解析出调用点限定符所引用的方法，并执行该方哇，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的</p>
<p><strong>异常处理指令</strong> athrow</p>
<p><strong>同步指令</strong></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>7.虚拟机字节码执行引擎</title>
    <url>/2015/JVM/7.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，</p>
<p>虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。其概念模型里虚拟机实现里面代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代代码执行)。</p>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a><strong>栈帧</strong></h3><p>​    栈帧 (Stack Frame) 是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的<strong>虚拟机栈</strong>(Virtual Machine Stack)的栈元素。</p>
<p>栈帧存储了方法的<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>和<strong>方法返回地址</strong>等信息。</p>
<p>​    每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响 而仅仅取决于具体的虚拟机实现。</p>
<p>​    一个线程中的方法调用链可能会根长，很多方法都同时处于执行状态.对于执行引擎来说，在活动战程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame) 与这个栈帧相关联的方法称为当前方法 (Current Method)。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<p><strong>局部变量表</strong></p>
<p>​    局部变量表(Local Variable Table)是一组变量值存储空间。用于存放方法参数和方法内部定义的局部变量。</p>
<p>在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的容量以变量槽(Variable Slot)为最小单位。</p>
<p><strong>操作数栈</strong></p>
<p>​    操作数栈(Operand stack) 也常称为操作栈，它是一个后入先出(Last In First Out LIFO)栈。 同局部变量表 一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过max_stacks数据项中设定的最大值。</p>
<p>​    当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。</p>
<p>​    <strong>java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</strong></p>
<p><strong>动态连接</strong></p>
<p>   每个栈帧都包含一个指向运行时常盘池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 (Dynamic Linking)</p>
<p>   class文件的常盘池中存有大量的符号引用，字节码中的方法调用指令就山以常量池中指向方法的符号引用作为参数。</p>
<blockquote>
<p> 符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为<strong>静态解析</strong>。</p>
<p> 另外一部分将在每一次运行期间转化为直接引用，这部分称为<strong>动态连接。</strong></p>
</blockquote>
<p><strong>方法返回地址</strong></p>
<p>正常完成出口(Normal Method Invocation Completion)</p>
<p>异常完成出口(Abrupt Method Invocation Completion) 方法使用异常完成出口的方式退出，不会给它的上层调用者产生任何返回值。</p>
<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p>
<p>回复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压人调用者栈帧的操作数栈中，调整PC计数区的值以指向方法调用指令后面的一条指令等。</p>
<p><strong>附加信息</strong></p>
<p>一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>​    方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，暂时还不涉且方法内部的具体运行过程。<br>在程序运行时，进行方法调用是最普遍 最频繁的操作， Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了强大的动在扩展能力，但也使得Java方法调用过程变得相时复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用.</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h4><p>​    方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载过程中的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法调用称为解析(Resolution).</p>
<p>​    在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>​    与之相时应的是，在Java虚拟机且面提供了5条方法调用字节码指令：</p>
<ul>
<li>invokestatic  调用静态方法。</li>
<li>invokespecial 调用实例构造器<init>方法、私有方法和父类方法。</init></li>
<li>invokevirtual  调用所有的虚方法。</li>
<li>invokeinterface  调用接口方法，会在运行时再确定一个实现此接口的对象。</li>
<li>invokedynamic  先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令， 分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>​    只要能被invokestatic和invokespecial指令调用的方法，都可在解析阶段中确定唯一的调用版本，符合过个条件的有静态方法、私有方法、实例构造器、父类方法4类。它们在类加载的时候就会把符号引用解析为该方法的直接引用. 这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final方法）</p>
<p>虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是种非虚方法.解析调用一定是个静态的过程， 在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成. </p>
<h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a><strong>分派</strong></h4><p><strong>静态分派</strong></p>
<p>所有依赖静态类型来定位方法执行版本的分派动作都为静态分派. 静态分派的典型应用是方法重载，静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的.</p>
<p><strong>动态分派</strong></p>
<p>方法重写，运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<p><strong>单分派和多分派</strong></p>
<p>方法的接收者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量时对目标方法进行选择。</p>
<p><strong>JAVA是一门静态多分派、动态单分派的语言。</strong></p>
<h3 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h3><p><strong>动态类型语言：</strong>在运行期进行类型检查的主体过程，而不是编译期。变量无类型而变量值才有类型。常用的包括 APL Clojure、Erlang、GroovyJavaScript、Jython、 Lisp、 Lua、 PHP、Prolog、 Python、 Ruby、 Smalltalk和Tcl等。</p>
<p><strong>静态类型语言</strong>：在编译期就进行类型检查过程的语言(如C++和Java等)</p>
<p><strong>比较</strong></p>
<ul>
<li><p>静态类型语言在编译期确定类型，可以提供严谨的类型检查，这样与类型相关的问题能在编码的时候就能及时发现。利于稳定性及代码达到更大规模。</p>
</li>
<li><p>动态类型语言在运行期确定类型，可为开发人员提供更大的灵活性，某些在静态类型语言中需用大量”臃肿”代码来实现的功能，由动态类型语言来实现可能会更加清晰和简洁，提高开发效率。</p>
</li>
<li><p>随有JDK7的发布，字节码指令添加invokedynamic指令. 这条新增加的指令是JDK7实现”动态类型语言”(Dynamically Typed Language)支持而进行的改进之一，也是为JDK8可以顺利实Lambda 表达式做的技术准备。</p>
</li>
</ul>
<h3 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h3><p>  虚拟机是如何执行字节码指令的。许多Java虚拟机的执行引擎在执行Java代码的时候都有<strong>解释执行(</strong>通过解释器执行)和<strong>编译执行</strong>(通过即时编译器产生本地代码执行)两种选择。</p>
<p><strong>java的解释执行引擎是基于栈的</strong>字节码解释执行引擎。</p>
<p><strong>Java编译器输出的指令流。基本上是一种基于栈的指令集型构(Instruction Set Architecture,ISA),指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。基于寄存器的指令集，最典型的就是x86的二地址指令集，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作.</strong><br>  基于栈的指令集主要的<strong>优点：</strong></p>
<ol>
<li><p>可移植性强，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。</p>
</li>
<li><p>代码相对更加紧凑(字节码中每个字节就时应一条指令，而多地址指令集中还需要存放参数) 。</p>
</li>
<li>编译器实现更加简单(不需要考虑空间分配的问题，所需空间都在栈上操作)。</li>
</ol>
<p><strong>缺点：</strong>执行速度稍慢。</p>
<p>1) 虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量，导致变慢的一个原因。</p>
<p>2) 栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，也是变慢的另一个原因。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>6.虚拟机类加载机制</title>
    <url>/2015/JVM/6.%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>虚拟机类加载机制：虚拟机把描述类的数据从Class文件加载到内存，井对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>​    与那些在编译时需要进行连接工作的语言不同 在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销.但是会为Java应用程序提供高度的灵活性。Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="/2015/JVM/6.虚拟机类加载机制/4ab95afe-f39b-4156-9002-afb0687b89df.png" alt="img"></p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定〈也称为动态绑定或晚期绑定)，注意，按部就班的“开始”，而不是按部就班的“进行”或“完成”。强调这点事因为这些阶段通常都是互相交叉的混合式进行的，通常会在一个阶段执行的过程中调用，激活另外一个阶段。</p>
<p><strong>有且只有</strong>5种情况必须立即对类进行”初始化’”而加载、验证、准备自然需要在此主前开始，称为对类的主动式引用，其余为被动式引用：</p>
<p>1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。2.使用Java.lang.reflect包的方法进行对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化。3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发初始化。4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法额那个类)，虚拟机会先初始化这个主类。5.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发器初始化。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h3><p>“加载”是”类加载”(ClassLoading) 过程的一个阶段，在加载阶段，虚拟机需要完成3件事情：1)通过一个类的全限定名来获取定义此类的二进制字节流.2)将这个字节流所代表的静在存储结构转化为方法区的运行时数据结构.3)在内存中生成一个代表这个类的java.lang.Class时象,作为方法区这个类的各种数据的访问入口在第一条中，没有严格限制二进制字节流必须从Class文件中获取，没有指明从那里获取，怎么获取，可以自定义类加载器，从zip war ear  jar 网络等获取。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><p>文件格式验证、元数据验证、字节码验证、符号引用验证可以用-Xverify:none关闭大部分的类验证措施，缩短虚拟机类加载时间</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p>  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 首先，这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在”对象实例化“时随着对象一起分配在Java堆中。其次，这里所说的初始值”通常情况”下是数据类型的零值，假设一个类变量的定且为 pulic static int value = 123 那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatlc指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。<br>  如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为public static <strong>final</strong> int value =123编降时Javac将会为value生成ConstantValue属性,在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123</clinit></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h3><p>解析阶段是虚拟机将常量池内的符号引用替候为直接引用的过程。</p>
<p><strong>符号引用(Symbolic Refercnces)</strong>  符号引用以一组符号来描述所引用的目标。</p>
<p>符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的。因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
<p><strong>直接引用(Direct References)</strong> ，直接引用可以是直接指向目标的指针、相时偏移量或是一个能间接定位到目标的句柄. 直往引用是和虚拟机实现的内存布局相关的，同一</p>
<p>个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同. 如果有了直接引用。那引用的目标必定已经在内存中存在。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>  前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的lava程序代码（或者说是字节码）。</p>
<p>​    在准备阶段，变量已赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
<ul>
<li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块〉中的语句合并产生的，编译器收集的顺序是由语句在源主件中出现的顺序所决定的，静态语句块中只能访问到定义在静在语句块之前的变量，定且在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span>&#123; </span><br><span class="line">         i=<span class="number">0</span>;                 <span class="comment">//赋值 给变量赋值可以正常编译通过    </span></span><br><span class="line">         System.out.print(i); <span class="comment">//访问 编译错误 “Cannot reference a field before it is defined”，非法向前引用</span></span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">1</span>;           <span class="comment">//定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><clinit>()方法与类的构造函数(或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕.因此在虚拟机中第一个被执行的<clinit>()方法的肯定是java.lang.Object</clinit></clinit></clinit></init></clinit></li>
<li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先与自雷的变量赋值操作，字段B的值将是2而不是1</clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        A=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B=A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.print(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></p>
</li>
<li><p>接口中不能使用静态语句块，但仍有有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。 但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></clinit></p>
</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</clinit></clinit></clinit></clinit></li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>  虚拟机设计团队把类加载阶段中的”通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类.实现这个动作的代码模块称为”类加载器”。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h3><p>  对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间. 即比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>  这里所指的”相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h3><p>Java虚拟机角度：</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分。</li>
<li>其他类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类Java.lang.ClassLoader。</li>
</ul>
<p>java开发人员的角度：</p>
<ul>
<li><strong>启动类加载器(Bootstrap ClassLoader)</strong>：这个加载器负责将存放在<java home>\lib 目录中的，或者被-Xbootclasspath参数所指定的路径中的， 并且是虚拟机识别的（仅按照文件名识别,如rt.Jar,名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。 </java></li>
<li><strong>扩展类加载器(Extension ClassLoader)</strong>：这个加载器由sun.misc.Launcher$ExtClassLoader’”实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或被java.ext.dirs系统变量多指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器(Application ClassLoader)</strong>：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中的默认加载器。</li>
</ul>
<p>​                                         <img src="/2015/JVM/6.虚拟机类加载机制/51516997-cec4-451e-b142-8e77426a4285.png" alt="img"></p>
<p>​                                            <strong>类加载器的双亲委派模型(Parents Delegation Model)</strong></p>
<p>​    这里类加载器之间父子关系一般不会以继承(Inheritance)的关系来实现，而是都使用组合(Composition)关系来服用加载器的代码。</p>
<p>​    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>​    使用双亲委派模型来组织类加载器之间的关系，可以使Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中是同一个类。</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a><strong>破坏双亲委派模型</strong></h3><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过3较大规模的 “反双亲”情况    </p>
<ul>
<li><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2发布之前。由于双亲委派模型在JDK 1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK 1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。    </p>
</li>
<li><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码。例如java中涉及SPI的加载动作如JNDI、JDBC、JCE、JAXB和JBI等服务，设计团队为了解决这个问题，引入<strong>线程上下文类加载器(Thread Context ClassLoader)</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。有了线程上下类加载器，JNDI服务可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为是加上就是打通了 双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型 的一般性原则。    </p>
</li>
<li><p>双亲委派模型的第三次“被破坏”是由于用户对<strong>程序动态性</strong>的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）、OSGI模块化编程等。OSGi 实现模块化热部署的关键原则则是它自定义的类加载器机制的实现。 每个程序模换(OSGi中称为 Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGI环境下，类加载器不再是树形结构，而是发展成更复杂的网状结构。</p>
</li>
</ul>
<h2 id="tomcat的类加载器架构"><a href="#tomcat的类加载器架构" class="headerlink" title="tomcat的类加载器架构"></a>tomcat的类加载器架构</h2><p>功能健全的Web服务器，要解决如下几个问题：</p>
<p>1）部署在同一个服务器上的两个web应用程序所使用的Java类库可以实现相互隔离。保证两个web应用程序可依赖同一个第三万类库的不同版本。</p>
<p>2）部署在同一个服务器上的两个web应用程序所使用的Java类库可以互相共享. 例如srping类库。</p>
<p>3）服务器所使用的类库应该与应用程序的类库相互独立。</p>
<p>4）支持JSP应用的Web服务器，大多数都需要支持HotSwap功能。但是运行在生产模式(Production Mode) 下的WebLogic服务器默认就不会处理JSP文件的变化。</p>
<p>Java类库放置在这些目录中的含义如下：</p>
<ul>
<li>放置在/common 目录中:类库可被Tomcat 和所有的Web应用程序共同使用。</li>
<li>放置在/server目录中:类库可被Tomcat使用,对所有的Web应用程序都不可见。</li>
<li>放置在/shared目录中:类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li>
<li>放置在/WebApp/WEB-INF目录中:类库仅仅可被此Web应用程序使用,时Tomcat和其他Web应用程序都不可见。</li>
</ul>
<p>​                                      <img src="/2015/JVM/6.虚拟机类加载机制/ad660f14-b0bd-40a4-a028-37c4058b4fea.png" alt="img"></p>
<p>  CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载/common/*、/server/*、 /shared/<em>和/WebApp/WEB-INF/\</em>中的Java类库。</p>
<p>其中WebApp类加载器和Jsp类加载器通常会存在多个实例。每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件时应一个Jsp类加载器.</p>
<p>  CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那个Class,它出现的目的就是为了被丢弃；当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap的功能。   在tomcat6.x后，conf/catalina.properties配置文件的server.loader和share.loader项现在为空，故/common /server /shared三个目录默认合并到一起变成一个/lib目录。</p>
<h2 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a>OSGi</h2><p><strong>OSGi(Open Service Gateway Initiative)</strong> 是OSGi 联盟(OSGi Alliance) 制定的一个基于Java语言的动态模块化规范。成为Java世界中”事实上”的模块化标准。应用案例有Eclipse IDE,1）可以实现精确的模块划分和可见性控制2）实现模块级的热插拔功能，在OSGi里面，加载器之间的关系不再是双亲委派模型的树形结构，而是已经进一步发展成了一种更复杂的、运行时才能确定的网状结构。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>9.晚期_运行期_优化_JIT编译</title>
    <url>/2015/JVM/9.%E6%99%9A%E6%9C%9F_%E8%BF%90%E8%A1%8C%E6%9C%9F_%E4%BC%98%E5%8C%96_JIT%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>​    在部分的商用虚拟机(Sun HotSpot、IBM J9)中，Java程序最初是通过解释器(Interpreter) 进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码”(Hot Spot Code). 为了提高热点代码的执行效率， 在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为<strong>即时编译器(Just In Time Compiler，下文中简称JIT编译器)。</strong></p>
<h4 id="1、为什么HotSpot虚拟机要使用解释器与编译器并存的架构？？"><a href="#1、为什么HotSpot虚拟机要使用解释器与编译器并存的架构？？" class="headerlink" title="1、为什么HotSpot虚拟机要使用解释器与编译器并存的架构？？"></a><strong>1、为什么HotSpot虚拟机要使用解释器与编译器并存的架构？？</strong></h4><p>现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。二者各有优势：</p>
<ul>
<li>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会发挥作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。</li>
<li>当程序运行环境中内存资源限制较大，可以<strong>使用解释执行节约内存</strong>，反之可以<strong>使用编译执行来提升效率</strong>。</li>
<li>解释器还可以作为编译器激进优化时的一个”逃生门”,让编译器根据慨率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现”罕见陷阱”(Uncommon Trap) 时可以通过逆优化(Deoptimization) 退回到解释状态继续执行(部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器担任”逃生门”的角色) 因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作，如图所示</li>
</ul>
<p>​                           <img src="/2015/JVM/9.晚期_运行期_优化_JIT编译/737675bb-3d5f-413e-a40e-394d9a7887d0.png" alt="img"></p>
<h4 id="2、为什么HotSpot虚拟机要实现两个不同的即时编译器的原因？-程序何时使用解释器执行？何时使用编译器执行？"><a href="#2、为什么HotSpot虚拟机要实现两个不同的即时编译器的原因？-程序何时使用解释器执行？何时使用编译器执行？" class="headerlink" title="2、为什么HotSpot虚拟机要实现两个不同的即时编译器的原因？/程序何时使用解释器执行？何时使用编译器执行？"></a><strong>2、为什么HotSpot虚拟机要实现两个不同的即时编译器的原因？/</strong>程序何时使用解释器执行？何时使用编译器执行？</h4><p>HotSpot虚拟机中内置了两个即时编译器：Client Complier和Server Complier，简称为C1编译器、C2编译器(也叫Opto编译器)，分别用在客户端和服务端，目前主流的HotSpot虚拟机中(SUN JDK1.7及之前版本的虚拟机)<strong>默认是采用解释器与其中一个编译器直接配合的方式工作</strong>。程序使用哪个编译器，取决于虚拟机运行的模式。HotSpot虚拟机会根据自身版本与宿主及其的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<ul>
<li><strong>java -version</strong>  显示 mixed mode， 可以通过虚拟机的”-version”命令的输出结果显示出这3种模式。无论来用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为”混合模式”(Mixed Mode)</li>
<li><strong>java -Xinit -version</strong> 显示interpreted mode  用户可以使用参数”-Xint” 强制虚拟机运行于”解释模式”(Interpreted Mode)，这时编译器完全不介入工作，全部代码都使用解释方式执行。</li>
<li><strong>java -Xcomp -version</strong>  显示compiled mode 也可以使用参数”-Xcomp”强制虚拟机运行子”编译模式”(Compiled Mode)，这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程，</li>
</ul>
<p>由于即时编译期编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译期收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动相应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用<strong>分层编译(Tiered Compilation)</strong>的策略，分层编译的概念在JDK1.6时期出现，后来一直处于改进阶段，最终在JDK1.7的Server模式虚拟机中作为默认编译策略被开启。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ul>
<li>第0层，程序解释执行，解释器不开启性能监控功能(Profiling),可触发第1层编译。</li>
<li>第1层，也成为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。</li>
<li>第2层(或2层以上)，也成为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>
</ul>
<p>实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被多次编译，<strong>用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量</strong>，在解释执行的同时也无须再承担收集性能监控信息的任务。</p>
<h4 id="4-哪些程序代码会被编译为本地代码？"><a href="#4-哪些程序代码会被编译为本地代码？" class="headerlink" title="4.哪些程序代码会被编译为本地代码？"></a><strong>4.哪些程序代码会被编译为本地代码？</strong></h4><p> 程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？运行过程中会被即时编译器编译的“热点代码”有两类：</p>
<ul>
<li>被多次调用的方法。</li>
<li>被多次调用的循环体。</li>
</ul>
<p>两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。 这种编译方式因为编译发生在发发执行过程之中，因此形象地称之为栈上替换(On Stack Replacement,简称OSR编译，即方法栈帧还在栈上，方法就被替换了)。</p>
<p>要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行<strong>Hot Spot Detection（热点探测）</strong>。目前主要的热点 判定方式有以下两种：</p>
<p>(1)<strong>基于采样的热点探测(Sample Based Hot Spot Detection)</strong></p>
<p>​    采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p>
<p>(2)<strong>基于计数器的热点探测(Counter Based Hot Spot Detection)</strong></p>
<p>​    采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p>
<p>(3)除了这两种方式外，还有其他热点代码的探测方式，如<strong>基于“踪迹”(Trace)的热点探测</strong>在最近相当流行，像FireFox中的TraceMonkey和Dalvik中的JIT编译期都用了这种热点探测方式。</p>
<p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：<strong>方法调用计数器(Invocation Counter)</strong>和<strong>回边计数器(Back Edge Counter)</strong>。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p>
<p><strong>方法调用计数器</strong>：这个计数器用于统计方法被调用的次数。它的默认阈值在Client模式下是1500次，在Server模式下是10000次，这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定。当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。</p>
<p>​    如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减(Counter Decay),而这段时间就成为此方法统计的半衰周期(Counter Half Life Time)。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行的时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。整个JIT编译的交互过程如果所示：</p>
<p>​                                <img src="/2015/JVM/9.晚期_运行期_优化_JIT编译/8ae9a39e-b1bd-4bc3-988c-24493773415b.jpg" alt="img"></p>
<p><strong>回边计数器</strong>：统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”(Back Edge)。显然，建立回边计数器统计的目的是为了触发OSR编译。</p>
<p>​    关于回边计数器的阈值，虽然HotSpot虚拟机也提供了一个类似于方法调用计数器阈值-XX:CompileThreshold的参数-XX:BackEdgeThreshold供用户设置，</p>
<p>但是实际上并未使用此参数，因此我们需要设置另外一个参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值，其计算公式如下：</p>
<ul>
<li>虚拟机运行在Client模式下，回边计数器阈值计算公式为：</li>
</ul>
<p>​    <strong>方法调用计数器阈值(CompileThreshold) * OSR比率(OnStackReplacePercentage)/100</strong> </p>
<p>​    其中OnStackReplacePercentage默认值是933,如果都取默认值，那Client模式虚拟机的回边计时器的阈值为13995</p>
<ul>
<li>虚拟机运行在Server模式下，回边计数器阈值的计算公式为：</li>
</ul>
<p>​    <strong>方法调用计时器阈值(CompileTHreshold) * (OSR比率(OnStackReplacePercentage)-解释器监控比率(InterpreterProfilePercentage)/100</strong></p>
<p>​    其中OnStackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33,如果都去默认值，那Server模式虚拟机回边计数器的阈值为10700。</p>
<p>​    当解释器遇到一条回边指令是，会先查找将要执行的代码片段是否有已经编译好的版本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译期输出编译结果，与方法计数器不同，回边计数器没有计数器热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次在进入该方法的时候就会执行标准编译过程。整个执行过程如图所示：</p>
<p>​                              <img src="/2015/JVM/9.晚期_运行期_优化_JIT编译/d6386816-cf4c-4bde-acd1-4b6f1768cbb5.jpg" alt="img"></p>
<p><strong>最后注意：图11-2和11-3都仅仅描述了Client VM的即时编译方式，对于Server VM来说，执行情况会比上面的描述更复杂一下。</strong></p>
<h4 id="5-如何编译为本地代码？"><a href="#5-如何编译为本地代码？" class="headerlink" title="5.如何编译为本地代码？"></a>5.<strong>如何编译为本地代码？</strong></h4><p>​    在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式执行，而编译动作则在后台的编译线程中进行。用户可以通过参数-XX:-BackgroundCompilation来禁止后台编译，在禁止后台编译后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。</p>
<p>   Server Compiler 和Client Compiler两个编译器的编译过程是不一样的。<strong>对于Client Compiler来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了很多耗时较长的全局优化手段。</strong></p>
<p>​    在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation,HIR)。HIR使用静态单分配(Static Single Assignment,SSA)</p>
<p>的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</p>
<p>​    在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示(Low-Level Intermediate Representation,LIR),而在此之前会在HIR上完成另外一些优化，如空值检查清除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</p>
<p>​    最后阶段是在平台相关的后端使用线性扫描算法(Linear Scan Register Allocation)在LIR上分配寄存器，并在LIR上做窥孔(Peephole)优化，然后产生机器代码。Client Compiler的大致执行过程如图所示</p>
<p>​                               <img src="/2015/JVM/9.晚期_运行期_优化_JIT编译/68b38662-fb76-4187-9a0d-8664c03a6676.png" alt="img"></p>
<p>​     <strong>Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器</strong>，几乎能达到GUN C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除(Dead Code Elimination)、循环展开(Loop Unrolling)、循环表达式外提(Loop Expression Hoisting)、消除公共自表达式(Common Subexpression Elimination)、常量传播(Constant Propagation)、基本快重排序(Basic Block Reordering)等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除(Range Check Elimination)、空值检查消除(Null Check Elimination,不过并非所有的空值检查消除都是依赖编译器优化的，有一些是在代码运行过程中自动优化了)等。另外，还可能根据解释器或Client</p>
<p>Compiler提供的性能监控信息，进行一些不稳定的激进优化，如守护内联(Guarded Inlining)、分支频率预测(Branch Frequency Prediction)等。</p>
<p>​     Server Compiler 的寄存器分配器是一个全局图着色分配器，它可且充分利用某些处理器架构(如RISC)上的大寄存器集合。以即时编译的标准来看， Server Compiler无疑是比较缓</p>
<p>慢的，但它的编译速度依然远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务器端的应用选择使用Server模式的虚拟机运行。 </p>
<h4 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a><strong>编译优化技术</strong></h4><p><strong>空循环会被编译时去掉，不会被执行。</strong></p>
<ul>
<li><p>方法内联(Method Inlining) 1.去除方法调用成本(建立栈帧等)  2.为其他优化建立良好的基础</p>
</li>
<li><p>冗余访问消除(Redundant Loads Elimination)</p>
</li>
<li><p>复写传播(Copy Propagation)</p>
</li>
<li><p>无用代码消除(Dead Code Elimination)</p>
</li>
</ul>
<p>语言无关的经典优化技术之一：公共子表达式消除(Common Subexpression Elimination)</p>
<p>语言相关的经典优化技术之一：数组范围检查消除(Array Bounds Chccking Elimination)</p>
<p>最重要的优化技术之一：方法内联(Method Inlining)</p>
<p>最前沿的优化技术之一：逃逸分析(Escape Analysis)</p>
<h4 id="Java与C-的编译器对比"><a href="#Java与C-的编译器对比" class="headerlink" title="Java与C++的编译器对比"></a>Java与C++的编译器对比</h4><p>Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势(下面列举的也包括一些虚拟机执行子系统的性能劣势):<br>    第一，因为<strong>即时编译器运行占用的是用户程序的运行时间</strong>，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。 如果编译速度不能达到要求，那用户将在启动程序或程序的某部分察觉到重大延迟，这点使得即时编译器不敢随便引入大规模的优化技术，而编译的时间成本在静态优化编译器中并不是主要的关注点。<br>    第二，Java语言是动态的类型安全语言，这就意味着需要由<strong>虚拟机来确保程序不会违反语言语义或访问非结构化内存。从实现层面上看，这就意味着虚拟机必须频繁地进行动态检查</strong>，如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。对于这类程序代码没有明确写出的检查行为，尽管编译器会努力进行优化，但是总体上仍然要消耗不少的运行时间。<br>    第三，<strong>Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言，这意味着运行时对方法接收者进行多态选择的频率远远大于C/C++语言</strong>，也意味着即时编译器在进行一些优化(如前面提到的方法内敛)时的难度要远大于C/C++的静态优化编译器。<br>    第四，<strong>Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行</strong>，因为编译器无法看见程序的全貌，很多全局的优化措施都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时撤销或重新进行一些优化。<br>    第五，<strong>Java语言中的对象内存分配都是堆上进行，只有方法中的局部变量才在栈上分配</strong>。而C/C++的对象则有多种内存分配方式，既可能在堆上分配，也可能在栈上分配，如果可以把线程私有的对象在栈上分配，将可以减轻内存回收的压力，也不需要考虑内存屏障方面的问题。另外，C/C++中主要由用户程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上（仅指运行效率，排除了开发效率）也垃圾收集机制要高。<br>    Java语言相对C/C++的劣势上面说了一大堆，倒不是说Java就真的不如C/C++了，相信大家也注意到了，<strong>Java语言的这些性能上的劣势都是为了换取开发效率上的优势而付出的代价，动态安全、动态扩展、垃圾回收这些“拖后腿”特性都为Java语言的开发效率作出了很大贡献</strong>。何况，还有很多优化是Java的JIT编译器能做，而C/C++的静态优化编译器不能做或者不好做的的，例如，在C/C++中，别名分析(Alias Analysis)的难度就要远高于Java。<br>    Java编译器另外一个红利是由它的动态性所带来的，由于C/C++编译器的静态性，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测（Call Frequency Prediction）、分支频率预测（Branch Frequency Prediction）、裁剪未被选择的分支（Untaken Branch Pruning）等，这些都会形成一些Java语言独有的性能优势。 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>8.早期_编译期_优化_字节码编译</title>
    <url>/2015/JVM/8.%E6%97%A9%E6%9C%9F_%E7%BC%96%E8%AF%91%E6%9C%9F_%E4%BC%98%E5%8C%96_%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p><strong>前端编译器</strong>(*.java-&gt;*.class)：SUN的Javac、Eclipse JDT中的增量式编译器(ECJ)<br><strong>JIT编译器(Just In Time Compiler)</strong>(*.class-&gt;机器码)：HotSpot VM的C1、C2编译器<br><strong>AOT编译器(Ahead Of Time Compiler)</strong>(*.java-&gt;本地机器码)：GUN Compiler for the Java(GCJ)、Excelsior JET</p>
<p>源文件经过<strong>字节码编译</strong>和<strong>JIT编译</strong>变为可执行的本地机器码，Javac 字节码编译器与虚拟机内的 JIT 编译器的执行过程合并起来其实就等同于一个传统编译器所执行的编译过程。</p>
<p>​    Javac做了许多针时Java语言编码过程的优化措施来改善程序员的编码风格和提高编码放率。相当多新生的Java语法特性，部是靠编译器的”语法糖”来实现，而不是依赖虚拟机的底层改进来支持，可以说，Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。</p>
<p>​    Javac编译器对代码的运行效率几乎没有任何优化措施，虚拟制设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由Javac产生的Class文(JRuby、Groovy等语言的Class文件)也同样能享受到编译器优化所带来的好处. </p>
<p>   在前端编译器中“优化”手段主要用于提升程序的编码效率，之所且把Javac这类将Java代码转变为字节码的编译器称作”前端编译器”，是因为它只完成了从程序到抽象语法树或中间字节码的生成，而在此之后，还有一组内置于虚拟机内部的”后端编译器” 完成了从字节码生成本地机器码的过程，即前面多次提到的即时编译器或JIT编译器，这个编译器的编译速度及编译结果的优劣，是衡量虚拟机性能一个很重要的指标。</p>
<p>从Sun Javac的代码来看.编译过程大致可以分为3个过程，分别是：</p>
<ul>
<li>解析与填充符号表过程</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ul>
<p><img src="/2015/JVM/8.早期_编译期_优化_字节码编译/d77f4a7f-b6ee-41ae-8675-37bcfdf53775.png" alt="img"><br><img src="/2015/JVM/8.早期_编译期_优化_字节码编译/59c5b5c1-872d-494e-8601-83cf2d8605b1.png" alt="img"></p>
<h2 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h2><h4 id="1-词法、语法分析解析"><a href="#1-词法、语法分析解析" class="headerlink" title="1.词法、语法分析解析"></a>1.词法、语法分析解析</h4><p>步骤由parseFiles()方法完成。解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。<br><strong>词法分析</strong>是将源代码的字符流转变为标记(Tokcn) 集合。<br><strong>语法分析</strong>是根据Token序列构造抽象语法树的过程。编译器就基本不会在对源码文件进行操作了，后续的操作都建立在抽象语法树之上。<br><strong>抽象语法树(Abstract Syntax Tree. AST)</strong> 是一种用来描述程序代码的语法结构的树形表示方式。语法树的每一个节点都代表着程序代码中的一个语法结构(Construct)，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p>
<h4 id="2-填充符号表"><a href="#2-填充符号表" class="headerlink" title="2.填充符号表"></a>2.填充符号表</h4><p><strong>符号表(SymbolTable)</strong>是由一组符号地址和符号信息构成的表格，由enterTrees()方法执行。</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>在JDK1.6中实现了JSR-269规范，提供了一组插入式注解处理器的标准APl在编译期间对注解进行处理，我们可以把它看做时一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理竹节期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有在对语法树进行修改为止，每一次循环称为一个Round，就是图中的回环过程。</p>
<h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的，语义分析的主要任务是在对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查，语义分析过程分为标注检查(attribute())和数据及控制流分析(flow())</p>
<h4 id="1-标注检查"><a href="#1-标注检查" class="headerlink" title="1.标注检查"></a>1.标注检查</h4><p>标注检查的内容包括变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等，还包括常量折叠，编译期进行常量折叠，不会增加运行期的运算量。</p>
<h4 id="2-数据及控制流分析"><a href="#2-数据及控制流分析" class="headerlink" title="2.数据及控制流分析"></a>2.数据及控制流分析</h4><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值、是否所有的受查异常都被正确处理了等问题</p>
<h4 id="3-解语法糖"><a href="#3-解语法糖" class="headerlink" title="3.解语法糖"></a>3.解语法糖</h4><p>语法糖(syntactic Sugar)指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员的使用，增加程序的可读性提高效率，提高语法严谨性，从而减少程序代码出错的机会。由desugar()执行。<br>java中最常用的语法糖主要是泛型(泛型并不一定都是语法糖实现，C#中的泛型就是直接由CLR支持的)、变长参数、自动装箱\拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p>
<h4 id="4-字节码生成"><a href="#4-字节码生成" class="headerlink" title="4.字节码生成"></a>4.字节码生成</h4><p>​    字节码生成阶段不仅把前面各个步骤所生成的信息(语法树、符号表)转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。    <strong>实例构造器<init>()方法</init></strong>和<strong>类构造器<clinit>()方法</clinit></strong>就是在这个阶段添加到语法树之中的(注意：这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性(public、protected或private)与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成),   </p>
<p>​     这两个构造器的产生过程实际上时一个代码收敛的过程，编译器会把语句块(对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块)、变量初始化(实例变量和类变量)、调用父类的实例构造器(仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，虚拟机会自动保证父类构造器的执行，但在<clinit>()方法中经常会生成调用Java.lang.Object的<init>()方法的代码)等操作收敛到<init>()和<clinit>()方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行。</clinit></init></init></clinit></clinit></clinit></p>
<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="1-泛型和类型擦除"><a href="#1-泛型和类型擦除" class="headerlink" title="1.泛型和类型擦除"></a>1.泛型和类型擦除</h3><p>​    泛型是JDK1.5的一项新增特性，它的本质是参数化类型(Parametersized Type) 的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别成为泛型类、泛型接口和泛型方法。   </p>
<pre><code> 泛型思想早在C++语言的模板(Template)中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，执行通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。但只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员区保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。
泛型技术在C#和Java之中的使用方式看似相同。但实现上却有着根本性的分歧，C#里面反省无论在程序源码中、编译后的IL中(Intermediate Language，中间语言，这时候泛型是一个占位符)，或是运行期的CLR中，部是切实存在的，List&lt;int&gt;与List&lt;String&gt;就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为**类型膨胀**，基于这种方法实现的泛型称为**真实泛型**。    
</code></pre><p>​    Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型(Raw Type,也称为裸类型)了，并且在相应的地方插入了强制类型代码，因此，对于运行期的Java语言来说，ArrayList<int>与ArrayList<string>就是同一个类，所以泛型技术实际上是Java语言的一个语法糖，Java语言中的泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为<strong>伪泛型</strong>。\</string></int></p>
<h3 id="2-自动装箱、拆箱与遍历循环"><a href="#2-自动装箱、拆箱与遍历循环" class="headerlink" title="2.自动装箱、拆箱与遍历循环"></a>2.自动装箱、拆箱与遍历循环</h3><h3 id="3-条件编译"><a href="#3-条件编译" class="headerlink" title="3.条件编译"></a>3.条件编译</h3><p>Java语言中条件编译的实现，也是Java语言的一个语法糖，根据布尔常量值得真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。Java语言还有不少其他的语法糖， 如<strong>内部类、枚举类、断言语句、对枚举和字符串(在JDK1.7中支持)的switch支持、try语句中定义和关闭在资源(在JDK1.7中支持)</strong>等。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>1.简介</title>
    <url>/2016/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/1.%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>在计算机中加入操作系统来实现多个程序的同时执行，基于 资源利用率、公平性、便利性的考虑。</p>
<p>进程（process）系统中资源分配的基本单位，一个应用程度至少有一个进程。</p>
<p>线程（thread）系统中独立运行和独立调度的基本单位，进程中包含一个或多个执行单元就是线程。</p>
<p>线程的优势：</p>
<ul>
<li>发挥多处理器的强大能力</li>
<li>建模的简单性</li>
<li>异步实践的简化处理</li>
<li>响应更灵敏的用户界面</li>
</ul>
<p>线程带来的风险</p>
<ul>
<li>线程安全性问题，在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。</li>
<li>活跃性问题，安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注“正确的事情最终会发生”。当某个操作无法继续执行下去时，就会发生活跃性问题。如死锁，饥饿、活锁。</li>
<li>性能问题，活跃性意味着正确的事情最终会发生，但却不够好，因为我们希望正确的事情尽快发生，性能问题包括多个方面，如服务时间过长，相应不灵敏，吞吐率低，资源消耗过高，可伸缩性较低等。</li>
</ul>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>11.并发程序测试</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/11.%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>并发测试大致分为两类。即<strong>安全性测试</strong>与<strong>活跃性测试</strong>。，我们将安全性定义为“不发生任何错误的行为”，而将活跃性定义为“某个良好的行为终究会发生”。</p>
<p>​    在进行安全性测试时，通常会采用测试不变性条件的形式，即判断某个类的行为是否与其规范保持一致。</p>
<p>​    测试活跃性本身也存在问题。活跃性测试包括进展测试和无进展测试两方面，这些都是很难量化的。如何验证某个方法是被阻塞了，而不只是运行缓慢？同样，如何测试某个算法不会发生死锁？要等待多久才能宣告它发生了故障？与活跃性测试相关的是性能测试。性能可以通过多个方面来衡量，包括：</p>
<ul>
<li>吞吐量：指一组并发任务中已完成任务所占的比例。</li>
<li>响应性：指请求从发出到完成之间的时间（也称为延迟）。</li>
<li>可伸缩性：指在增加更多资源的情况下（通常指CPU),吞吐量（或者缓解短缺）的提升情况。</li>
</ul>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>10.性能和可伸缩性</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/10.%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7/</url>
    <content><![CDATA[<p>可伸缩性：当增加计算资源时（例如CPU、内存、存储容器或I/O带宽），程序的吞吐量或者处理能力能相应的增加。</p>
<p> <strong>在所有的并发程序中都包含一些串行部分。</strong></p>
<h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p> <img src="/2017/Java 并发编程实践/10.性能和可伸缩性/25649746.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/10.性能和可伸缩性/25699230.png" alt="img"></p>
<h3 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h3><ul>
<li><p>上下文切换   正在运行的线程调度出来，从而使其他线程能够使用CPU   </p>
</li>
<li><p>内存同步</p>
</li>
<li><p>阻塞</p>
</li>
</ul>
<h3 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h3><p><strong>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。</strong></p>
<p>有三种方式可以降低锁的竞争程度：</p>
<ul>
<li>减少锁的持有时间</li>
<li>减低所得请求频率</li>
<li>使用带有协调机制的独占锁，这些机制允许更高的并发性。</li>
</ul>
<h4 id="缩小锁的范围（”快进快出“）"><a href="#缩小锁的范围（”快进快出“）" class="headerlink" title="缩小锁的范围（”快进快出“）"></a>缩小锁的范围（”快进快出“）</h4><p>降低发生竞争可能性的一种有效方式就是尽可能缩短锁的持有时间。例如，可以将一些与锁无关的代码移出同步代码块，尤其是那些开销较大的操作。以及可能被阻塞的操作，例如I／O操作。</p>
<p>缩小同步代码块之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttributeStore</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; attributes = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">userLocationMatches</span><span class="params">(String name, String regexp)</span> </span>&#123;</span><br><span class="line">        String key = <span class="string">"users."</span> + name + <span class="string">".location"</span>;</span><br><span class="line">        String location = attributes.get(key);</span><br><span class="line">        <span class="keyword">if</span> (location == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Pattern.matches(regexp, location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缩小同步代码块之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterAttributeStore</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; attributes = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">userLocationMatches</span><span class="params">(String name, String regexp)</span> </span>&#123;</span><br><span class="line">        String key = <span class="string">"users."</span> + name + <span class="string">".location"</span>;</span><br><span class="line">        String location;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            location = attributes.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (location == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Pattern.matches(regexp, location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>极大减少了在持有锁时需要执行的指令数量。根据Amadahl定律，这样消除了限制可伸缩性的一个因素，因为串行代码的总量减少了。</p>
<p>另一种方式，使用线程安全的Map(Hashtable、synchronizedMap、ConcurrentHashMap)来代替arrtibutes,可以讲确保线程安全性的任务委托给顶层的线程安全容器来实现。</p>
<p>缩小同步代码块时不能分割原子操作。</p>
<h4 id="锁分解"><a href="#锁分解" class="headerlink" title="锁分解"></a>锁分解</h4><p>​    另一种减小锁的持有时间的方式是降低线程请求锁的频率（从而减小发生竞争的可能性)-这可以通过锁分解和锁分段等技术来实现，在这些技术中将采用多个相互独立的锁来保护独立的状态变量，从而改变这些变量在之前由单个锁来保护的情况。这些技术能减小锁操作的粒度·并能实现更高的可伸縮性，然而，使用的锁越多，那么发生死锁的风险也就越高。</p>
<p>​    设想一下，如果在整个应用程序中只有一个锁，而不是为每个对象分配一个独立的锁，那么，所有同步代码块的执行就会变成串行化执行，而不考虑各个同步块中的锁。由于很多线程将竞争同一个全局锁，因此两个线程同时请求这个锁的概率将剧增，从而导致更严重的竞争。所以如果将这些锁请求分布到更多的锁上，那么能有效地降低竞争程度。由于等待锁而被阻塞的线程将更少，因此可伸缩性将提高。</p>
<p>​    <strong>如果一个锁需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且这个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。</strong></p>
<p>分解前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStatusBeforeSplit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; users;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; queries;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerStatusBeforeSplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        users = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        queries = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String u)</span> </span>&#123;</span><br><span class="line">        users.add(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addQuery</span><span class="params">(String q)</span> </span>&#123;</span><br><span class="line">        queries.add(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeUser</span><span class="params">(String u)</span> </span>&#123;</span><br><span class="line">        users.remove(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeQuery</span><span class="params">(String q)</span> </span>&#123;</span><br><span class="line">        queries.remove(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   分解后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStatusAfterSplit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"users"</span>) <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; users;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"queries"</span>) <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; queries;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerStatusAfterSplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        users = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        queries = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (users) &#123;</span><br><span class="line">            users.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQuery</span><span class="params">(String q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queries) &#123;</span><br><span class="line">            queries.add(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUser</span><span class="params">(String u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (users) &#123;</span><br><span class="line">            users.remove(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeQuery</span><span class="params">(String q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (users) &#123;</span><br><span class="line">            queries.remove(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在代码中不是用ServerStatus锁来保护用户状态和查询状态，而是每个状态都通过一个锁来保护。在对锁进行分解后，每个新的细粒度锁上的访问量将比最初的访问量少·（通过将用户状态和查询状态委托给一个线程安全的Set,而不是使用显式的同步，能隐含地对锁进行分解，因为每个set都会使用一个不同的锁来保护其状态。）</p>
<p>​    如果在锁上存在适中而不是激烈的竞争时，通过将一个锁分解为两个锁，能最大限度地提升性能。如果对竞争并不激烈的锁进行分解，那么在性能和吞吐量等方面带来的提升将非常有限，但是也会提高性能随着竞争提高而下降的拐点值。对竞争适中的锁进行分解时，实际上是把这些锁转变为非竟争的锁，从而有效地提高性能和可伸縮性。</p>
<h4 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h4><p>​    在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情况被称为锁分段。例如，在ConcurrentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第(Nmod16）个锁来保护。假设散列函数其有合理的分布性，并且关键字能够实现均匀分布，那么这大约能把对于锁的请求减少到原来的1/16.正是这项技术使得ConcurrentHashMap能够支持多达16个并发的写人器。（要使得拥有大量处理器的系统在高访问量的情况下实现更高的并发性，还可以进一步增加锁的数量，但仅当你能证明并发写入线程的竞争足够激烈并需要突破这个限制时，才能将锁分段的数量超过默认的16个。）</p>
<p>​    锁分段的一个劣势在于：与采用单个锁来实现独占访问相比，要获取多个锁来实现独占访问将更加困难并且开销更高。通常在执行一个操作时最多只需获取一个锁，但在某些情况下需要加锁整个容器．例如当concurrentHashMap需要扩展映射范围，以及重新计算键值的散列值要分布到更大的桶集合中时，就需要获取分段所集合中所有的锁。在程序StripedMap中给出了基于散列的Map实现，其中使用了锁分段技术。它拥有N_LOCKS个锁，并且每个锁保护散列桶的一个子集。大多数方法，例如get,都只需要获得一个锁，而有些方法則需要获得所有的锁，但并不要求同时获得，例如clear方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Synchronization policy: buckets[n] guarded by locks[n%N_LOCKS]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_LOCKS = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] buckets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] locks;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node next;</span><br><span class="line">        Object key;</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StripedMap</span><span class="params">(<span class="keyword">int</span> numBuckets)</span> </span>&#123;</span><br><span class="line">        buckets = <span class="keyword">new</span> Node[numBuckets];</span><br><span class="line">        locks = <span class="keyword">new</span> Object[N_LOCKS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_LOCKS; i++)</span><br><span class="line">            locks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(key.hashCode() % buckets.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">synchronized</span> (locks[hash % N_LOCKS]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node m = buckets[hash]; m != <span class="keyword">null</span>; m = m.next)</span><br><span class="line">                <span class="keyword">if</span> (m.key.equals(key))</span><br><span class="line">                    <span class="keyword">return</span> m.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (locks[i % N_LOCKS]) &#123;</span><br><span class="line">                buckets[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="替代独占锁的方法"><a href="#替代独占锁的方法" class="headerlink" title="替代独占锁的方法"></a>替代独占锁的方法</h4><p>​    当每个操作都请求多个变量时，锁的粒度将很难降低。这是在性能与可伸缩性之间相互制衡的另一个方面，一些常见的优化措施，例如将一些反复计算的结果缓存起来，都会引人一些“热点域(HotField)＂而这些热点域往往会限制可伸缩性。   </p>
<p>​    第三种降低竞争锁的影晌的技术就是放弃使用独占锁，从而有助于使用一种友好并发的方式来管理共享状态。例如，使用并发容器、读－写锁、不可变对象以及原子变量．       ReadWriteLock实现了一种在多个读取操作以及单个写人操作情况下的加锁规则：如果多个读取操作都不会修改共享资源，那么这些读取操作可以同时访问该共享资源，但在执行写人操作时必须以独占方式来获取锁。对于读取操作占多数的数据结构，ReadWriteLock能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要加锁撲作。</p>
<p>​    原子变量提供了一种方式来降低更新“热点域”时的开销，例如静态计数器、序列发生器、或者对链表数据结构中头节点的引用。原子变量类提供了在整数或者对象引用上的细粒度原子作（因此可伸缩性更高),并使用了现代处理器中提供的底层并发原语（例如比较并交换[compare-and-swap]）。如果在类中只包含少量的热点域，并且这些域不会与其他变量参与到不变性条件中，那么用原子变量来替代它们能提高可伸縮性。（通过减少算法中的热点域，可以提高可伸縮性一一虽然原子变量能降低热点域的更新开销，但并不能完全消除。</p>
<p><strong>ConcurrentHashMap与同步的HashMap</strong></p>
<p>​    在单线程坏境下，ConcurrentHashMap的性能比同步的HashMap的性能略好一些，但在并发坏境中则要好得多。在concurrentHashMap的实现中假设，大多数常用的操作都是获取某个已经存在的值，因此它对各种get操作进行了优化从而提供最高的性能和并发性。</p>
<p>​    在同步Map的实现中．可伸缩性的最主要阻碍在于整个Map中只有一个锁，因此每次只有一个线程能够访问这个Map.不同的是，concurrentHashMap对于大多数读操作并不会加锁，并且在写人操作以及其他一些需要锁的读操作中使用了锁分段技术。因此，多个线程能并发地访问这个Map而不会发生阻塞。</p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>12.显式锁</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/12.%E6%98%BE%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>​    在Java5.0之前，在协调对共享对象的访问时可以使用的机制只有synchronized和volatile。Java5.0增加了一种新的机制：ReentrantLock。与之前提到过的机制相反，ReentrantLock并不是一种替代内置加锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。</p>
<h2 id="Lock与ReentrantLock"><a href="#Lock与ReentrantLock" class="headerlink" title="Lock与ReentrantLock"></a>Lock与ReentrantLock</h2><p>​    与内置加锁机制不同的是，Lock提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显式的。在Lock的实现中必须提供与内部锁相同的内存可见性语义，但在加锁语义、调度算法、顺序保证以及性能特性等方面可以有所不同。</p>
<p><img src="/2017/Java 并发编程实践/12.显式锁/12584007.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/12.显式锁/13655500.png" alt="img"></p>
<h3 id="轮询锁与定时锁"><a href="#轮询锁与定时锁" class="headerlink" title="轮询锁与定时锁"></a>轮询锁与定时锁</h3><p>​    可定时的与可轮询的锁获取模式是由tryLock方法实现的，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。在内置锁中，死锁是一个严重的问题，恢复程序的唯一方法是重新启动程序，而防止死锁的唯一方法就是在构造程序时避免出现不一致的锁顺序。可定时的与可轮询的锁提供了另一种选择：避免死锁的发生。</p>
<p>​    如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁（或者至少会将这个失败记录到日志，并采取其他措施)。使用tryLock来获取两个锁，如果不能同时获得，那么就回退并重新尝试。在休眠时间中包括固定部分和随机部分，从而降低发生活锁的可能性。如果在指定时间内不能获得所有需要的锁，那么transferMoney将返回一个失败状态，从而使该操作平缓地失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlockAvoidance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transferMoney</span><span class="params">(Account fromAcct,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Account toAcct,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 DollarAmount amount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 TimeUnit unit)</span> </span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> InsufficientFundsException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> fixedDelay = getFixedDelayComponentNanos(timeout, unit);<span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">long</span> randMod = getRandomDelayModulusNanos(timeout, unit);<span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">long</span> stopTime = System.nanoTime() + unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAcct.lock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (toAcct.lock.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                fromAcct.debit(amount);</span><br><span class="line">                                toAcct.credit(amount);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            toAcct.lock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    fromAcct.lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (System.nanoTime() &lt; stopTime)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY_FIXED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY_RANDOM = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getFixedDelayComponentNanos</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DELAY_FIXED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getRandomDelayModulusNanos</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DELAY_RANDOM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DollarAmount</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">DollarAmount</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(DollarAmount other)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DollarAmount(<span class="keyword">int</span> dollars) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Lock lock;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(DollarAmount d)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(DollarAmount d)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">DollarAmount <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InsufficientFundsException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在实现其有时间限制的操作时，定时锁同样非常有用。<strong>当在带有时间限制的操作中调用了一个阻塞方法时，它能根据剩余时间来提供一个时限。如果操作不能在指定的时间内给出结果，那么就会使程序提前结束。</strong>当使用内置锁时，在开始请求锁后，这个操作将无法取消，因此内置锁很难实现带有时间限制的操作。定时的tryLock能够在这种带有时间限制的操作中实现独占加锁行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySendOnSharedLine</span><span class="params">(String message, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message);</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(nanosToLock, NANOSECONDS))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sendOnSharedLine(message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sendOnSharedLine</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* send something */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">estimatedNanosToSend</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可中断的锁获取操作"><a href="#可中断的锁获取操作" class="headerlink" title="可中断的锁获取操作"></a>可中断的锁获取操作</h3><p>​    locklnterruptibly方法能郇在获得锁的同时保持对中断的响应，并且由于它包含在Lock中，因此无须创建其他类型的不可中断阻塞机制。可中断的锁获取操作的标准结构比普通的锁获取操作略微复杂一些，因为需要两个try块。（如果在可中断的锁获取操作中抛出了InterruptedException，那么可以使用标准的try-finally加锁模式。）定时的tryLock同样能响应中断，因此当需要实现一个定时的和可中断的锁获取操作时，可以使用tryLock方法。     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptibleLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendOnSharedLine</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cancellableSendOnSharedLine(message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cancellableSendOnSharedLine</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/* send something */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非块结构的加锁"><a href="#非块结构的加锁" class="headerlink" title="非块结构的加锁"></a>非块结构的加锁</h3><p>​    在内置锁中，锁的获取和释放等操作都是基于代码块的一一释放锁的操作总是与获取锁的作处于同一个代码块，而不考虑控制杈如何退出该代码块。自动的锁释放操作简化了对程序的分析，避免了可能的编码错误，但有时侯需要更灵活的加锁规则。</p>
<p>​    通过降低锁的粒度可以提高代码的可伸縮性。锁分段技术在基于散列的容器中实现了不同的散列链，以便使用不同的锁。我们可以通过采用类似的原则来降低链表中锁的粒度，即为每个链表节点使用一个独立的锁，使不同的线程能独立地对链表的不同部分进行操作“每个节点的锁将保护链接指针以及在该节点中存储的数据，因此当遍历或修改链表时，我们必须持有该节点上的这个锁，直到获得了下一个节点的锁，只有这样，才能释放前一个节点上的锁。连锁式加锁(Hand-Over-HandLocking)或者锁耦合(LockCoupling)介绍了使用这项技术。</p>
<h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><p>​    在ReentrantLock的构造函数中提供了两种公平性选择：创建一个非公平的锁（默认）或者一个公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。（在Semaphore中同样可以选择采用公平的或非公平的获取顺序·）非公平的ReentrantLock并不提倡“插队”行为，但无法防止某个线程在合适的时候进行“插队”。在公平的锁中，如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将被放人队列中。在非公平的锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。</p>
<p>​    在激烈竞争的情况下，非公平锁的性能高于公平锁的性能的一个原因是：在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁，并且线程B请求这个锁。由于这个锁已被线程A持有，因此B将被挂起。当A释放锁时，B将被唤醒，因此会再次尝试获取锁。与此同时，如果C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面：B获得锁的时刻并没有推迟，c更早地获得了锁，并且吞吐量也获得了提高。</p>
<p>当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。在这些情况下，“插队”带来的吞吐量提升（当锁处于可用状态时，线程却还处于被唤醒的过程中）則可能不会出现。</p>
<h2 id="synchronized和ReentrantLock比较"><a href="#synchronized和ReentrantLock比较" class="headerlink" title="synchronized和ReentrantLock比较"></a>synchronized和ReentrantLock比较</h2><p><img src="/2017/Java 并发编程实践/12.显式锁/4572826.png" alt="img"></p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><img src="/2017/Java 并发编程实践/12.显式锁/11760057.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/12.显式锁/12790428.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteMap</span> &lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = lock.writeLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteMap</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.remove(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.putAll(m);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.containsValue(value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>13.构建自定义的同步工具</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/13.%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="状态依赖性管理"><a href="#状态依赖性管理" class="headerlink" title="状态依赖性管理"></a>状态依赖性管理</h2><p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/2498855.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/2533175.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffer</span> &lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        buf[tail] = v;</span><br><span class="line">        <span class="keyword">if</span> (++tail == buf.length)</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">doTake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V v = buf[head];</span><br><span class="line">        buf[head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++head == buf.length)</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == buf.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将前提条件的失败传递给调用者"><a href="#将前提条件的失败传递给调用者" class="headerlink" title="将前提条件的失败传递给调用者"></a>将前提条件的失败传递给调用者</h3><p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/3005998.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrumpyBoundedBuffer</span> &lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当不满足前提条件时，有界缓存不会执行相应的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrumpyBoundedBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrumpyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> BufferFullException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferFullException();</span><br><span class="line">        doPut(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> BufferEmptyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferEmptyException();</span><br><span class="line">        <span class="keyword">return</span> doTake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleUsage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GrumpyBoundedBuffer&lt;String&gt; buffer;</span><br><span class="line">    <span class="keyword">int</span> SLEEP_GRANULARITY = <span class="number">50</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useBuffer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String item = buffer.take();</span><br><span class="line">                <span class="comment">// use item</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BufferEmptyException e) &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferFullException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferEmptyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/3015655.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/3378794.png" alt="img"></p>
<h3 id="通过轮询与休眠来实现简单的阻塞"><a href="#通过轮询与休眠来实现简单的阻塞" class="headerlink" title="通过轮询与休眠来实现简单的阻塞"></a>通过轮询与休眠来实现简单的阻塞</h3><p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/28580615.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepyBoundedBuffer</span> &lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用简单阻塞实现有界缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> SLEEP_GRANULARITY = <span class="number">60</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepyBoundedBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isFull()) &#123;</span><br><span class="line">                    doPut(v);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isEmpty())</span><br><span class="line">                    <span class="keyword">return</span> doTake();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;java</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/28645387.png" alt="img"></p>
<h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30117256.png" alt="img"><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30132435.png" alt="img"></p>
<ul>
<li>条件谓词</li>
<li>过早唤醒</li>
<li>丢失的信号</li>
<li>通知</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> &lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用条件队列实现有界缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 条件谓词: not-full (!isFull())</span></span><br><span class="line">    <span class="comment">// 条件谓词: not-empty (!isEmpty())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞并直到: not-full</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞并直到: not-empty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isEmpty())</span><br><span class="line">            wait();</span><br><span class="line">        V v = doTake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞并直到: not-full</span></span><br><span class="line">    <span class="comment">// Alternate form of put() using conditional notification</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">alternatePut</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        <span class="keyword">boolean</span> wasEmpty = isEmpty();</span><br><span class="line">        doPut(v);</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty)</span><br><span class="line">            notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30416014.png" alt="img"> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/4590657.png" alt="img"> </p>
<h3 id="阀门类"><a href="#阀门类" class="headerlink" title="阀门类"></a>阀门类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用wait和notifyAll来实现可重新关闭的阀门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 条件谓词: opened-since(n) (isOpen || generation&gt;n)</span></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">boolean</span> isOpen;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> generation;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++generation;</span><br><span class="line">        isOpen = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞并直到: opened-since(generation on entry)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arrivalGeneration = generation;</span><br><span class="line">        <span class="keyword">while</span> (!isOpen &amp;&amp; arrivalGeneration == generation)</span><br><span class="line">            wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/11982826.png" alt="img"></p>
<h2 id="显示的Condition对象"><a href="#显示的Condition对象" class="headerlink" title="显示的Condition对象"></a>显示的Condition对象</h2><p>在某些情况下，当内置锁过于灵活时，可以使用显式锁。正如Lock是一种广义的内置锁，Condition也是一种广义的内置条件队列。<img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/29531238.png" alt="img"> </p>
<p><strong>注意：在Condition对象中，与wait、notify、notifyAll方法对应的分别是await、signal和signalAll。但是，Condition对Object进行了扩展，因而他也包含wait和notify方法。一定要确保使用正确的版本await和signal。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBoundedBuffer</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用显式条件变量的有界缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: notFull (count &lt; items.length)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: notEmpty (count &gt; 0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"lock"</span>) <span class="keyword">private</span> <span class="keyword">final</span> T[] items = (T[]) <span class="keyword">new</span> Object[BUFFER_SIZE];</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"lock"</span>) <span class="keyword">private</span> <span class="keyword">int</span> tail, head, count;</span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: notFull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[tail] = x;</span><br><span class="line">            <span class="keyword">if</span> (++tail == items.length)</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: notEmpty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            T x = items[head];</span><br><span class="line">            items[head] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++head == items.length)</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30132575.png" alt="img"> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30145851.png" alt="img"> </p>
<h2 id="Synchronizer剖析"><a href="#Synchronizer剖析" class="headerlink" title="Synchronizer剖析"></a>Synchronizer剖析</h2><p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/3972783.png" alt="img"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreOnLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: permitsAvailable (permits &gt; 0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition permitsAvailable = lock.newCondition();</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"lock"</span>) <span class="keyword">private</span> <span class="keyword">int</span> permits;</span><br><span class="line">    SemaphoreOnLock(<span class="keyword">int</span> initialPermits) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            permits = initialPermits;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: permitsAvailable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (permits &lt;= <span class="number">0</span>)</span><br><span class="line">                permitsAvailable.await();</span><br><span class="line">            --permits;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++permits;</span><br><span class="line">            permitsAvailable.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/4693726.png" alt="img"> </p>
<h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/28051600.png" alt="img"> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/28062302.png" alt="img"><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/28090522.png" alt="img"> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/28124780.png" alt="img"><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/28985796.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneShotLatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignored)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果闭锁是开的 (state == 1), 那么这个操作将成功，否则将失败</span></span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">1</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignored)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">1</span>); <span class="comment">// 现在打开闭锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 现在其他的线程可以获取该闭锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/29470086.png" alt="img"> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/29480148.png" alt="img"> </p>
<h2 id="java-util-concurrent同步器类中的AQS"><a href="#java-util-concurrent同步器类中的AQS" class="headerlink" title="java.util.concurrent同步器类中的AQS"></a>java.util.concurrent同步器类中的AQS</h2><p> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30041580.png" alt="img"> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30111453.png" alt="img"> <img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/30161264.png" alt="img"><img src="/2017/Java 并发编程实践/13.构建自定义的同步工具/db7ec425-1c0a-4d36-9909-9f9da4eddd59.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>15.JMM-Java内存模型</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/15.JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>​    JMM规定了JVM必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其他线程可见。JMM在设计时就在可预测性和程序的易于开发性之间进行了权衡，从而在各种主流的处理器体系架构上能实现高性能的JVM。如果你不了解在现代处理器和编译器中使用的程序性能提升措施，那么在刚刚接触JMM的某些方面时会感到困惑。</p>
<p>​    程序执行一种简单假设：想象在程序中只存在唯一的操作执行顺序，而不考虑这些操作在何种处理器上执行，并且在每次读取变量时，都能获得在执行序列中（任何处理器）最近一次写人该变量的值。这种乐观的模型就被称为串行一致性。软件开发人员经常会错误地假设存在串行一致性，但在任何一款现代多处理器架构中都不会提供这种串行一致性，JMM也是如此。冯．诺伊曼模型这种经典的串行计算模型，只能近似描述现代多处理器的行为。</p>
<p>​    在现代支持共享内存的多处理器（和编译器）中，当跨线程共享数据时，会出现一些奇怪的情况，除非通过使用内存栅栏来防止这些情况的发生。幸运的是，Java程序不需要指定内存栅栏的位置，而只需要通过正确的使用同步来找出合适将访问共享状态。</p>
<h2 id="Java内存模型简介"><a href="#Java内存模型简介" class="headerlink" title="Java内存模型简介"></a>Java内存模型简介</h2><p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/23430554.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/23452503.png" alt="img"></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="不安全的发布"><a href="#不安全的发布" class="headerlink" title="不安全的发布"></a>不安全的发布</h3><p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25794640.png" alt="img"><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25805654.png" alt="img"></p>
<h3 id="安全的发布"><a href="#安全的发布" class="headerlink" title="安全的发布"></a>安全的发布</h3><p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25841940.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25863780.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25888085.png" alt="img"></p>
<h3 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h3><p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25927444.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25943839.png" alt="img"></p>
<h2 id="初始化过程中的安全性"><a href="#初始化过程中的安全性" class="headerlink" title="初始化过程中的安全性"></a>初始化过程中的安全性</h2><p><img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25972200.png" alt="img"></p>
<p> <img src="/2017/Java 并发编程实践/15.JMM-Java内存模型/25983261.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>2.线程安全性——原子性</title>
    <url>/2016/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/2.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
    <content><![CDATA[<p>要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的(shared)和可变的(mutable)状态（存储在状态变量例如实例或静态域中的）的访问。</p>
<p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就成这个类时<strong>线程安全</strong>的。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>竞态条件：由于不恰当的执行时序而出现不正确的结果。最常见的类型为“先检查后执行(Check Then Act)”即基于一种可能失效的观察结果来做出判断是否执行某个计算。</p>
<p><img src="/2016/Java 并发编程实践/2.线程安全性——原子性/28527637.png" alt="img"></p>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><h4 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h4><p>java提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block),其包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以synchronized来修饰的方法就是一种横跨整个方法体的代码同步快，其中该同步代码块的锁就是方法调用所在的对象。</p>
<p>每个Java对象都可以用作一个实现同步的锁，这些锁被称为内置锁(Intrinsic Lock)或监视器锁(Monitor Lock)</p>
<h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><p>由于内置锁是可重入得，因此如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求就会成功。重入以为这获取锁的操作的粒度是“线程”，而不是“调用”。</p>
<p><img src="/2016/Java 并发编程实践/2.线程安全性——原子性/1381981.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>3.对象的共享——可见性</title>
    <url>/2016/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/3.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
    <content><![CDATA[<p>我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>原子性——通过同步(加锁)来避免多个线程在同一时刻访问相同的数据。</p>
<p>可见性——如何共享和发布数据，从而使它们能够安全的由多个线程同时访问。</p>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<h5 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h5><p>​    java用volatile变量确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的。因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或对其他处理器不可见的地方，因此在读取vatile类型的变量时总会返回最新写人的值。</p>
<p>​    在访问volatile变量时不会执行加锁操作，因此也就不会是执行线程阻塞，volatile变量时一种比sychronized关键字更轻量级的同步机制。</p>
<p>​    给出了volatile变量的一种典型用法：检查某个状态标记以判断是否退出循环。在这个示例中，线程试图通过类似于数绵羊的传统方祛进人休眠状态。为了使这个示例能正确执行，asleep须为volatile变量。否则，当asleep被另一个线程修改时，执行判断的线程却发现不了。我们也可以用锁来确保asleep更新操作的可见性，但这将使代码变得更加复杂。</p>
<p><img src="/2016/Java 并发编程实践/3.对象的共享——可见性/3876780.png" alt="img"></p>
<p>​    虽然volatile变量很方便，但也存在一些局限性。volatile变量通常用做某个操作完成、发生中断或者状态的标志·例如程序中asleep标志。尽管volatile变量也可以用于表示其他的状态信息，但在使用时要非常小心。例如，volatile的语义不足以确保递增操作(count++)的原子性·除非你能确保只有一个线程对变量执行写操作·（原子变量提供了“读一改一写”的原子操作，并且常常用做一种“更好的volatile变量”）。</p>
<p>​    <strong>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</strong></p>
<p>​    当且仅当满足以下所有条件时，才应该使用volatile变量：</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
<h3 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h3><p>​    “发布(Publish)”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape).</p>
<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>​    当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement)，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。 应用在 Swing、JDBC中。</p>
<p>   方法有Ad-hoc线程封闭（不推荐）、栈封闭、ThreadLocal类。</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>​    满足同步需求的另一种方法是使用不可变对象(ImmutableObject)。到目前为止，我们介绍了许多与原子性和可见性相关的问题，例如得到失效数据，丢失更新操作或者观察到某个对象处于不一致的状态等等，都与多线程试图同时访问同一个可变的状态相关。如果对象的状态不会改变，那么这些问题与复杂性也就自然消失了。</p>
<p>​    不可变对象一定是线程安全的。</p>
<p>​    虽然在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在行final类型的域中可以保存对可变对象的引用。</p>
<p>​    当满足以下条件莳，对象才是不可变的。</p>
<ul>
<li>对象创建以后其状态就不能修改。</li>
<li>对象的所有域都是final类型。</li>
<li>对象时正确创建的(在对象的创建期间，this引用没有逸出)。</li>
</ul>
<h3 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h3><p>​    要安全地发布一个对象，对象的引用以及对象的状态必須同时对其他线程可见。</p>
<p>​    一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用。</li>
<li>将对象引用保存到volatile类型的域或者AtomicReferance对象中。</li>
<li>将对象的引用保到某个正确构造对象的final类型域中。</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ul>
<p>​    尽管Javadoc在这个主题上没有给出很清晰的说明，但线程安全库中的容器类提供了以下的安全发布保证：</p>
<ul>
<li>通过将一个键或者值放人Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。</li>
<li>通过将某个元素放人Vector、CopyOnWnteAnayList、CopyOnwriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。</li>
<li>通过将某个元素放人BlockmgQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。  </li>
</ul>
<p>​    类库中的其他数据传递机制(例如Future和Exchanger)同样能实现安全发布，在介绍这些机制时将讨论它们的安全发布功能。</p>
<p>​    通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：</p>
<p>​     public static Holder holder=new Holder（42）;</p>
<p>​    静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<p>   对象的发布需求取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任意机制来发布。</li>
<li>事实不可变对象必须通过安全方式来发布。</li>
<li><p>可变对象必须通过安全方式来发布，并且必须是线程安全的或者有某个锁保护起来的。</p>
<p>在并发程序中使用和共享对象时，可以使用一些使用的策略，包括：</p>
</li>
<li><p><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</p>
</li>
<li><strong>只读共享</strong>。在没有额外同步的情况下，共享的只读对象可以由多个钱程并发访问，但任何线程都不能不修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li>
<li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁护的对象。</li>
</ul>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>4.对象的组合</title>
    <url>/2016/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/4.%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量。</li>
<li>找出约束状态变量的不变性条件。</li>
<li>建立对象状态的并发访问管理策略。</li>
</ul>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>5.基础构建模块</title>
    <url>/2016/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/5.%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h3><p>​    包括Vector和Hashtable，都是比较早期JDK的一部分，不大常用。这些同步的封装器类是由Collections.synchronizesXxxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，是的每次只有一个线程能访问容器的状态。</p>
<p>​    同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护符合操作。</p>
<p>​    无论在直接迭代还是在Java5.0引入的for-each循环语法中，对容器类进行迭代的标准方式都是使用Iterator。然而，如果有其他线程并发的修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。，当他们发现容器在迭代过程中被修改是，就会抛出一个ConcurrentModificationException异常。</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>​    Java5.0提供了多种并发容器类来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低。   </p>
<p>​    并发容器室针对多线程并发访问设计的。通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。在Java5.0中增加ConcurrentHashMap替代基于散列的Map,CopyOnWriteArrayList用于替换List。新增两种容器 Queue和BlockingQueue。Java6中引入ConcurrentSkipListMap和ConcurrentSkipListSet替换SortedMap和SortedSet。</p>
<p>​    Queue提供了几种实现，包括：ConcurrentLinkedQueue，这是一个传统的先进先出队列，以及PriorityQueue，这是一个（非并发的）优先队列。Queue上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。虽然可以用List来模拟Queue的行为一一事实上，正是通过LinkedLiSt来实现Queue的，但还需要一个Queue的类，因为它能去掉List的随机访问需求，从而实现更高效的并发。</p>
<p>​    BlockingQueue扩展了Queue，增加了可阻塞的插人和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。如果队列已满（对于有界队列来说），那么插人元素的操作将一直阻塞，直到队列中出现可用的空间。在“生产者一消费者”这种设计模式中，阻塞队列是非常有用的。</p>
<h4 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h4><p>​    concurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁（Lock Striping)。在这种机制中，任意数量的读取线程可以并发地访问Map，执行读取操作的线程和执行写人操作的线程可以并发地访问Map,并且一定数量的写人线程可以并发地修改Map。ConcurrentHashMap带来的结果是，在并发访问环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。ConcurrentHashMap与其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出ConcunentModificationException,因此不需要在迭代过程中对容器加锁。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList用于替代同步List,CopyOnWriteArraySet用于替换同步Set，提供更好的并发性能，并且在迭代期间不需要对容器进行加锁和复制。</p>
<p>CopyOnWriteArrayList在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性，即“写入时复制”。显然需要一定的开销在复制副本时，<strong>适合于迭代比较多，修改比较少的场景</strong>。</p>
<h4 id="Deque和BlockingDeque"><a href="#Deque和BlockingDeque" class="headerlink" title="Deque和BlockingDeque"></a><strong>Deque和BlockingDeque</strong></h4><p>​    Java6增加了两种容器类型，Deque和BlockingDeque，它们分别对Queue和BlockingQueue进行了扩展。Deque是一个双端队列，实现了在队列头和队列尾的高效插人和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。</p>
<p>​    正如阻塞队列适用于生产者一消费者模式，双端队列同样适用于另一种相关模式，即工作密取(Workstealing).在生产者一消费者设计中，所有消费者有一个共享的工作队列，而在工作密取设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。密取工作模式比传统的生产者一消费者模式具有更高的可伸縮性，这是因为工作者线程不会在单个共享的任务队列上发生竞争．在大多数时候，它们都只是访问自己的双队列，从而极大地减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是从头部获取工作，因此进一步降低了队列上的竞争程度。</p>
<p>​    工作密取非常适用于既是消费者也是生产者问题一一当执行某个工作时可能导致出现更多的工作。例如，在网页爬虫程序中处理一个页面时，通常会发现有更多的页面需要处理。类似的还有许多搜索图的算法，例如在垃圾回收阶段对堆进行标记，都可以通过工作密取机制来实现高效并行。当一个工作线程找到新的任务单元时，它会将其放到自己队列的末尾（或者在工作共享设计模式中，放人其他工作者线程的队列中)„当双端队列为空时，它会在另一个线程的队列队尾查找新的任务，从而确保每个线程都保持忙碌状态。</p>
<p><img src="/2016/Java 并发编程实践/5.基础构建模块/9723511-1640685198277.png" alt="img"></p>
<h3 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h3><h4 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h4><p>​    闭锁是一种同步工具类，可以廷迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过，当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行，例如：</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行“二元闭锁（包括两个状态）可以用来表示“资源R已经被初始化”，而所有需要R的操作都必须先在这个闭锁上等待。</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。每个服务都有一个相关的二元闭锁。当启动服务S时，将首先在s依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会释放闭锁S，这样其他依赖s的服务才能继续执行。</li>
<li>等待直到某个操作的所有参与者（例如，在多玩家游戏中的所有玩家）都就绪再继续执行。在这种情况中，当所有玩家都准备就绪时，闭锁将到达结束状态。</li>
</ul>
<p>​    CountDownLatch是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</p>
<p>​    在程序TestHarness中给出了闭锁的两种常见用法。TestHarness创建一定数的线程，利用它们并发地执行指定的任务。它使用两个闭锁，分别表示“起始门（StartingGate)”和“结束门(EndingGate)”。起始门计数器的初始值为1，而结束门计数器的初始值为工作线程的数量。每个工作线程首先要做的值就是在启动门上等待，从而确保所有线程都就绪后才开始执行。而每个线程要做的最后一件事情是将调用结束门的countDown方法减1，这能使主线程高效地等待直到所有工作线程都执行完成，因此可以统计所消耗的时间。</p>
<p>​    为什么要在TestHarness中使用闭锁，而不是在线程创建后就立即启动？或许，我们希望测试n个线程并发执行某个任务时需要的时间。如果在创建线程后立即启动它们，那么先启动的线程将“领先”后启动的线程，并且活跃线程数量会随着时间的推移而增加或减少，竟争程度也在不断发生变化，启动门将使得主线程能够同时释放所有工作线程，而结束门则使主线程能够等待最后一个线程执行完成，而不是顺序地等待每个线程执行完成。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        startGate.await();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        startGate.countDown();</span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>​    FutureTask也可以用做闭锁。(FutureTask实现了Future语义，表示一种抽象的可生成结果的计算)。FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：等待运行（Waitingtorun),正在运行(Running)和运行完成(Completed)。“执行完成”表示计算的所有可能结束方式，包括正常结束、由于取消而结束和由于异常而结束等。当FutureTask进人完成状态后，它会永远停止在这个状态上。</p>
<p>​    Future.get的行为取决于任务的状态。如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进人完成状态，然后返回结果或者抛出异常。FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。</p>
<p>​    FutureTask在Executor框架中表示异步任务，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。程序Preloader就使用了FutureTask来执行一个高开销的计算，并且计算结果将在稍后使用。通过提前启动计算，可以减少在等待结果时需要的时间。</p>
<p>​    Preloader创建了一个FutureTask，其中包含从数据库加载产品信息的任务，以及一个执行运算的线程。由于在构造函数或静态初始化方法中启动线程并不是一种好方法，因此提供了一个start方法来启动线程。当程序随后需要Productlnfo时，可以调用get方法，如果数据已经加载，那么将返回这些数据，否则将等待加载完成后再返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Preloader</span> </span>&#123;</span><br><span class="line">    <span class="function">ProductInfo <span class="title">loadProductInfo</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;ProductInfo&gt; future =</span><br><span class="line">        <span class="keyword">new</span> FutureTask&lt;ProductInfo&gt;(<span class="keyword">new</span> Callable&lt;ProductInfo&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> loadProductInfo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; thread.start(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            Throwable cause = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> DataLoadException)</span><br><span class="line">                <span class="keyword">throw</span> (DataLoadException) cause;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> LaunderThrowable.launderThrowable(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ProductInfo</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataLoadException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​    计数信号量（Counting Semaphore)用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p>
<p>​    Semaphore中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可),并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可（或者直到被中断或者操作超时）。release方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore，</p>
<p>二值信号量可以用做互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。</p>
<p>​    Semaphore可以用于实现资源池，例如数据库连接池。我们可以构造一个固定长度的资源池，当池为空时，请求资源将会失败，但你真正希望看到的行为是阻塞而不是失败，并且当池非空时解除阻塞。如果将semaphore的计数值初始化为池的大小，并在从池中获取一个资源之前首先调用acquire方法获取一个许可，在将资源返回给池之后调用release释放许可，那么acquire将一直阻塞直到资源池不为空。（在构造阻塞对象池时，一种更简单的方法是使用BlockingQueue来保存池的资源。）</p>
<p>​    同样，你也可以使用Semaphore将任何一种容器变成有界阻塞容器，如程序BoundedHashSet所示。信号量的计数值会初始化为容器容量的最大值。add操作在向底层容器中添加一个元素之前，首先要获取一个许可。如果add操作没有添加任何元素，那么会立刻释放许可。同样，remove操作释放一个许可，使更多的元素能够添加到容器中。底层的set实现并不知道关于边界的任何信息，这是由BoundedHashSet来处理的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wasAdded)</span><br><span class="line">                sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">        <span class="keyword">if</span> (wasRemoved)</span><br><span class="line">            sem.release();</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h4><p>​    闭锁是一次性对象，一旦进人终止状态，就不能被重置．栅栏（Barner）类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议，例如几个家庭决定在某个地方集合：“所有人6：00在麦当劳碰头，到了以后要等其他人，之后再讨论下一步要做的事情。”</p>
<p>CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程到达棚栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。如果成功地通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。CyclicBarrier还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，当成功通过栅栏时会（在一个子任务线程中）执行它，但在阻塞线程被释放之前是不能执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellularAutomata</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker[] workers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CellularAutomata</span><span class="params">(Board board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = board;</span><br><span class="line">        <span class="keyword">int</span> count = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">this</span>.barrier = <span class="keyword">new</span> CyclicBarrier(count,</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        mainBoard.commitNewValues();</span><br><span class="line">                    &#125;&#125;);</span><br><span class="line">        <span class="keyword">this</span>.workers = <span class="keyword">new</span> Worker[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            workers[i] = <span class="keyword">new</span> Worker(mainBoard.getSubBoard(count, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Board board;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Board board)</span> </span>&#123; <span class="keyword">this</span>.board = board; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!board.hasConverged()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; board.getMaxX(); x++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board.getMaxY(); y++)</span><br><span class="line">                        board.setNewValue(x, y, computeValue(x, y));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Compute the new value that goes in (x,y)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(workers[i]).start();</span><br><span class="line">        mainBoard.waitForConvergence();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Board</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getMaxX</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getMaxY</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">setNewValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">commitNewValues</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">hasConverged</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">waitForConvergence</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Board <span class="title">getSubBoard</span><span class="params">(<span class="keyword">int</span> numPartitions, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/Java 并发编程实践/5.基础构建模块/19100265-1640685198277.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>6.任务执行</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/6.%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</p>
<p><img src="/2017/Java 并发编程实践/6.任务执行/22123702-1640686184689.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/6.任务执行/22140036-1640686184689.png" alt="img"></p>
<p><img src="/2017/Java 并发编程实践/6.任务执行/22151533-1640686184689.png" alt="img"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。 </li>
<li>当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</li>
<li>通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存。</li>
</ul>
<h4 id="构造线程池方法"><a href="#构造线程池方法" class="headerlink" title="构造线程池方法"></a>构造线程池方法</h4><ul>
<li>newFixedThreadPool将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。</li>
<li>newCachedThreadPool将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。</li>
<li>newSingleThreadExecutor是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSmgleThreadExecutor能确保依照任务在队列中的顺序来串行执行（例如FIFO、LIFO、优先级）</li>
<li>newScheduledThreadPool创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer</li>
</ul>
<h4 id="Executorservice的生命周期"><a href="#Executorservice的生命周期" class="headerlink" title="Executorservice的生命周期"></a>Executorservice的生命周期</h4><p>接口Executorservice的生命周期有3种状态：运行、关闭和已终止。</p>
<p>​    ExecutorService在初始创建时处于运行状态。</p>
<p>​    shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成,包括那些还未开始执行的任务。</p>
<p>​    shutdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>
<p>在ExecutorService关闭后提交的任务将由“拒绝执行处理器(Rejected ExecutionHandler)”来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的Rejected-ExecutionException。等所有任务都完成后，ExecutorService将转人终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止。通常在调用awaitTermination之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果。</p>
<h4 id="携带结果的任务Callable和Future"><a href="#携带结果的任务Callable和Future" class="headerlink" title="携带结果的任务Callable和Future"></a>携带结果的任务Callable和Future</h4><p>Runnable作为Executor框架基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写人到日志文件或者将结果放人某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</p>
<p>Callable 对于许多任务实际上存在延迟的计算，如执行数据库查询，从网络上获取资源，或者计算某个复杂的功能，Callable是一种更好的抽象。它认为主入口点（即call）将返回一个值，并可能抛出一个异常。</p>
<p>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个生命周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。</p>
<p>​    Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。get方法的行为取决于任务的状态（尚未开始、正在运行、已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationExceptiono如果get抛出了ExecutionException，那么可以通过getCause来获得被封装的初始异常。</p>
<p>​    可以通过许多种方法创建一个Future来描述任务。ExecutorService中的所有submit方法都将返回一个Future,从而将一个RunnabIe或CaIIabIe提交给Executor,并得到一个Future用来获得任务的执行结果或者取消任务。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask0。（由于FutureTask实现了Runnable，因此可以将它提交给Executor来执行，或者直接调用它的run方法。）</p>
<p>​    从Java6开始，ExecutorService实现可以改写AbstractExecutorService中的newTaskFor方法，从而根据已提交的Runnable或Callable来控制Future的实例化过程。在默认实现中仅创建了一个新的FutureTask。</p>
<p><img src="/2017/Java 并发编程实践/6.任务执行/30139502-1640686184689.png" alt="img"></p>
<p>Callable和Future有助于表示这些协同任务之间的交互。在程序中创建了一个Callable来下载所有的图像，并将其提交到一个ExecutorService。这将返回一个描述任务执行情况的Future.。当主任务需要图像时，它会等待Future.get的调用结果。如果幸运的话，当开始请求时所有图像就已经下载完成了，即使没有，至少图像的下载任务也已经提前开始了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = <span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos)</span><br><span class="line">                            result.add(imageInfo.downloadImage());</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);<span class="comment">//提交任务，返回一个Future对象</span></span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;ImageData&gt; imageData = future.get();<span class="comment">//调用get方法获取结果</span></span><br><span class="line">            <span class="keyword">for</span> (ImageData data : imageData)</span><br><span class="line">                renderImage(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 重新设置线程的中断状态</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">// 由于不需要结果，所以取消任务</span></span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageData</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageInfo</span> </span>&#123;</span><br><span class="line">        <span class="function">ImageData <span class="title">downloadImage</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderText</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> List&lt;ImageInfo&gt; <span class="title">scanForImageInfo</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderImage</span><span class="params">(ImageData i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CompletionService和BlockingQueue"><a href="#CompletionService和BlockingQueue" class="headerlink" title="CompletionService和BlockingQueue"></a>CompletionService和BlockingQueue</h4><p>​    Completionservice将Executor和BlockingQueue的功能融合在一起。你可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。ExecutorCompletionService实现了Completionservice，并将计算部分委托给一个Executor。</p>
<p>​    ExecutorCompletionService的实现非常简单。在构造函数中创建一个BlockingQueue来保存计算完成的结果。当计算完成时，调用Future-Task中的done方法。当提交某个任务时，该任务将首先包装为一个QueueingFuture,这是FutureTask的一个子类，然后再改写子类的done方法，并将结果放人BlockingQueue中，ake和poll方法委托给了BlockingQueue，这些方法会在得出结果之前阻塞。</p>
<p>​    多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService.因此，CompletionService的作用就相当于一组计算的句柄，这与Future作为单个计算的句柄是非常类似的。通过记录提交给Completionservice的任务数量，并计算出已经获得的已完成结果的数量，即使使用一个共享的Executor，也能知道已经获得了所有任务结果的时间。</p>
<p> <img src="/2017/Java 并发编程实践/6.任务执行/29406687-1640686184696.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">    Renderer(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)</span><br><span class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;ImageData&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>, n = info.size(); t &lt; n; t++) &#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                ImageData imageData = f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageData</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ImageInfo</span> </span>&#123;</span><br><span class="line">        <span class="function">ImageData <span class="title">downloadImage</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderText</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> List&lt;ImageInfo&gt; <span class="title">scanForImageInfo</span><span class="params">(CharSequence s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">renderImage</span><span class="params">(ImageData i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="超时取消任务"><a href="#超时取消任务" class="headerlink" title="超时取消任务"></a>超时取消任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderWithTimeBudget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Ad DEFAULT_AD = <span class="keyword">new</span> Ad();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BUDGET = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET;</span><br><span class="line">        Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">        <span class="comment">// Render the page while waiting for the ad</span></span><br><span class="line">        Page page = renderPageBody();</span><br><span class="line">        Ad ad;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Only wait for the remaining time budget</span></span><br><span class="line">            <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class="line">            ad = f.get(timeLeft, NANOSECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">            f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page.setAd(ad);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Page <span class="title">renderPageBody</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Page(); &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ad</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAd</span><span class="params">(Ad ad)</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchAdTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Ad</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Ad <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h4><p>​    创建n个任务，將其提交到一个线程池，保留n个Future，并使用限时的get方法通过Future串行地获取每一个结果，这一切都很简单，但还有一个更简单的方法—invokeAll</p>
<p>​    invokeAll将多个任务提交到一个Executorservice并获得结果。InvokeAll方法的参数为一组任务，并返回一组Future.这两个集合有着相同的结构。</p>
<p>​    InvokeAll按照任务集合中迭代器的顺序将所有的Future添加到返回的集合中，从而使调用者能将各个Future与其表示的Callable关联起来。当所有任务都执行完毕时，或者调用线程被中断时，又或者超过指定时限时，invokeAll将返回。当经过指定时限后，任何还未完成的任务都会取消·当invokeAll返回后，每个任务要么正常地完成，要么被取消，而客户端代码可以调用get或isCancelled来判断究竟是何种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeBudget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuotes</span><span class="params">(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies,</span></span></span><br><span class="line"><span class="function"><span class="params">            Comparator&lt;TravelQuote&gt; ranking, <span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;QuoteTask&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TravelCompany company : companies)</span><br><span class="line">            tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo));</span><br><span class="line">        List&lt;Future&lt;TravelQuote&gt;&gt; futures = exec.invokeAll(tasks, time, unit);</span><br><span class="line">        List&lt;TravelQuote&gt; quotes =<span class="keyword">new</span> ArrayList&lt;TravelQuote&gt;(tasks.size());</span><br><span class="line">        Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator();</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">            QuoteTask task = taskIter.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                quotes.add(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                quotes.add(task.getFailureQuote(e.getCause()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                quotes.add(task.getTimeoutQuote(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(quotes, ranking);</span><br><span class="line">        <span class="keyword">return</span> quotes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuoteTask</span><span class="params">(TravelCompany company, TravelInfo travelInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.company = company;</span><br><span class="line">        <span class="keyword">this</span>.travelInfo = travelInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TravelQuote <span class="title">getFailureQuote</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TravelQuote <span class="title">getTimeoutQuote</span><span class="params">(CancellationException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> company.solicitQuote(travelInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelCompany</span> </span>&#123;</span><br><span class="line">    <span class="function">TravelQuote <span class="title">solicitQuote</span><span class="params">(TravelInfo travelInfo)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelQuote</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelInfo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>9.避免活跃性危险</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/9.%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9/</url>
    <content><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h4><p>原因：<strong>两个线程试图以不同的顺序来获得相同的锁</strong>。如果按照相同的顺序来请求锁，那么就不会出现循环的加锁依赖性，因此也就不会产生死锁。如果每个需要锁L和锁M的线程都以相同的顺序来获取L和M，那么就不会发生死锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(<span class="keyword">final</span> Account fromAcct,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> Account toAcct,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> DollarAmount amount)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fromAcct.debit(amount);</span><br><span class="line">                    toAcct.credit(amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</span><br><span class="line">        <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (tieLock) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                        <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h4><p>如果在调用某个方法是不需要持有锁，那么这种调用被称为开放调用。依赖于开放调用的类通常能表现出更好的行为，并且与那些在调用方法是需要持有锁的类相比，也更易于编写。<strong>这会使得某个原子操作变为非原子操作。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CooperatingNoDeadlock</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ThreadSafe</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">        <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> location;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> reachedDestination;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.location = location;</span><br><span class="line">                reachedDestination = location.equals(destination);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reachedDestination)</span><br><span class="line">                dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getDestination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> destination;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setDestination</span><span class="params">(Point destination)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.destination = destination;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ThreadSafe</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">        <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">            availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">            availableTaxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Set&lt;Taxi&gt; copy;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</span><br><span class="line">            &#125;</span><br><span class="line">            Image image = <span class="keyword">new</span> Image();</span><br><span class="line">            <span class="keyword">for</span> (Taxi t : copy)</span><br><span class="line">                image.drawMarker(t.getLocation());</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMarker</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><p>例如线程饥饿死锁：正如当多个线程相互持有彼此正在等待的锁而又不释放自己已持有的锁时会发生死锁，当他们在相同的资源集合上等待时，也会发生死锁。</p>
<h3 id="其他活跃性危险"><a href="#其他活跃性危险" class="headerlink" title="其他活跃性危险"></a>其他活跃性危险</h3><p><strong>饥饿</strong> 线程由于无法访问它所需要的资源而不能继续执行时，就发生了”饥饿(Starvation)”</p>
<p><strong>糟糕的响应性</strong></p>
<p><strong>活锁</strong> 该问题尽管不会阻塞线程，但也不能继续执行，因为线程将重复执行相同的操作，而且总会失败。</p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>8.线程池的使用</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/8.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="在任务和执行策略之间的隐形耦合"><a href="#在任务和执行策略之间的隐形耦合" class="headerlink" title="在任务和执行策略之间的隐形耦合"></a>在任务和执行策略之间的隐形耦合</h3><p>虽然Excutor框架为制定和修改执行策略都提供了相当大的灵活性，但并非所有的任务都能使用所有的执行策略。有些类型的任务需要明确地指定执行策略，包括：</p>
<ul>
<li>依赖性任务</li>
<li>使用线程封闭机制的任务</li>
<li>对响应时间敏感的任务</li>
<li>使用ThreadLocal的任务</li>
</ul>
<h3 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h3><p><img src="/2017/Java 并发编程实践/8.线程池的使用/13278461.png" alt="img"></p>
<h3 id="配置ThreadPoolExecutor"><a href="#配置ThreadPoolExecutor" class="headerlink" title="配置ThreadPoolExecutor"></a>配置ThreadPoolExecutor</h3><p>ThreadPoolExecutor为Executor接口的实现类，这些Executor是由Executors中的newCachedThreadPool、newFixedThreadPool和newScheduledThreadExecutor等工厂方法返回的。ThreadPoolExecutor是一个灵活的、稳定的线程池，允许进行各种定制。</p>
<h4 id="1-线程的创建与销毁"><a href="#1-线程的创建与销毁" class="headerlink" title="1.线程的创建与销毁"></a><strong>1.线程的创建与销毁</strong></h4><p>​    newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。newCachedThreadPooI工厂方法将线程池的最大大小设置为Integer.MAXVALUE，而将基本大小设置为零，并将超时设置为1分钟，这种方法创建出来的线程池可以被无限扩展，并且当需求降低时会自动收缩。其他形式的线程池可以通过显式的ThreadPoolExecutor构造函数来构造。</p>
<h4 id="2-管理队列任务"><a href="#2-管理队列任务" class="headerlink" title="2.管理队列任务"></a>2.管理队列任务</h4><p>​     ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有3种：<strong>无界队列、有界队列和同步移交(Synchronous Handoff)。</strong>队列的选择与其他的配置参数有关，例如线程池的大小等。</p>
<p>​    newFixedThreadPool和newSingleThreadExecutor在默认情况下将使用一个<strong>无界的LinkedBlockingQueue</strong>。如果所有工作者线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续快速地到达，并且超过了线程池处理它们的速度，那么队列将无限制地增加。</p>
<p>​    一种更稳妥的资源管理策略是使用<strong>有界队列</strong>，例如ArrayBlockingQueue有界的LinkedBlockingQueue、PriorityBlockingQueue,有界队列有助于避免资源耗尽的情况发生，但它又带来了新的问题：当队列填满后，新的任务该怎么办？（有许多饱和策略[SaturationPolicy]可以解决这个问题）在使用有界的工作队列时，队列的大小与线程池</p>
<p>的大小必须一起调节。如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价是可能会限制吞吐量。</p>
<p>​     对于非常大的或者无界的线程池，可以通过使用<strong>synchronousQueue</strong>来避免任务排队，以及直接将任务从生产者移交给工作者线程。synchronousQueue不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入synchronousQueue中，必须有另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交给执行它的线程，而不是被首先放在队列中。然后由工作者线程从队列中提取该任务。只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有实际价值。在newCachedThreadPooI工厂方法中就使用了SynchronousQueue，从而提供了更好的排队性能。</p>
<p>​    当使用像LinkedBlockingQueue或ArrayBlockingQueue这样的FIFO(先进先出）队列时，任务的执行顺序与它们的到达顺序相同。如果想进一步控制任务执行顺序，还可以使用PriorityBlockingQueue，这个队列将根据优先级来安排任务。任务的优先级是通过自然顺序或Comparator来定义的。</p>
<h4 id="3-饱和策略"><a href="#3-饱和策略" class="headerlink" title="3.饱和策略"></a>3.饱和策略</h4><p>​    当有界队列被填满后，饱和策略开始发挥作用。ThreadPooIExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。（如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略。）JDK提供了几种不同的RejectedExecutionHandIer实现，每种实现都包含有不同的饱和策略：<strong>AbortPolicy</strong>、<strong>CallerRunsPolicy</strong>、<strong>DiscardPolicy</strong>和<strong>DiscardOldestPolicy。</strong></p>
<p>​    “中止（Abort)”策略是默认的饱和策略，该策略将抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。当新提交的任务无法保存到队列中等待执行时，“抛弃（Discard)”策略会悄悄抛弃该任务。</p>
<p>​    “抛弃最旧的（Discard-Oldest)”策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。）</p>
<p>​    “调用者运行（Caller-Runs)”策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。我们可以将webServer示例修改为使用有界队列和“调用者运行”饱和策略，当线程池中的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行。由于执行任务需要一定的时间，因此主线程至少在一段时间内不能提交任何任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中而不是在应用程序的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载时，这种过载情况会逐渐向外蔓延开来,从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that runs the rejected task</span></span><br><span class="line"><span class="comment">     * directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span></span><br><span class="line"><span class="comment">     * unless the executor has been shut down, in which case the task</span></span><br><span class="line"><span class="comment">     * is discarded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Executes task r in the caller's thread, unless the executor</span></span><br><span class="line"><span class="comment">         * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RejectedExecutionException always.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">" rejected from "</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment">     * rejected task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment">     * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment">     * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">         * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">         * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">         * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/8.线程池的使用/2277864.png" alt="img">     </p>
<p>​        当工作队列被填满后，没有预定义的饱和策略来阻塞execute。然而，通过使用Semaphore（信号量）来限制任务的到达率，就可以实现这个功能。在BoundedExecutor中给出了这种方法。该方法使用了一个无界队列（因为不能限制队列的大小和任务的到达率），并设置信号量的上界设置为线程池的大小加上可排队任务的数量，这是因为信号量需要控制正在执行的和等待执行的任务数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedExecutor</span><span class="params">(Executor exec, <span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exec = exec;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitTask</span><span class="params">(<span class="keyword">final</span> Runnable command)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        command.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-线程工厂"><a href="#4-线程工厂" class="headerlink" title="4.线程工厂"></a>4.线程工厂</h4><p>​    当线程池需要创建一个线程时，都是通过线程工厂方法来完成。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。通过指定一个线程工厂方法，可以定制线程池的配置信息。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAppThread(runnable, poolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"MyAppThread"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> debugLifecycle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger created = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger alive = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = Logger.getAnonymousLogger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(r, DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable runnable, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(runnable, name + <span class="string">"-"</span> + created.incrementAndGet());</span><br><span class="line">        setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t,Throwable e)</span> </span>&#123;</span><br><span class="line">                log.log(Level.SEVERE,<span class="string">"UNCAUGHT in thread "</span> + t.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Copy debug flag to ensure consistent value throughout.</span></span><br><span class="line">        <span class="keyword">boolean</span> debug = debugLifecycle;</span><br><span class="line">        <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">"Created "</span> + getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            alive.incrementAndGet();</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            alive.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">"Exiting "</span> + getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> created.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> alive.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debugLifecycle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        debugLifecycle = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-扩展ThreadPoolExecutor"><a href="#5-扩展ThreadPoolExecutor" class="headerlink" title="5.扩展ThreadPoolExecutor"></a>5.扩展ThreadPoolExecutor</h4><p>​    ThreadPoolExecutor是可扩展的，它提供了几个可以在子类化中改写的方法：beforeExecute、afterExecute和terminated，这些方法可以用于扩展ThreadPoolExecutor的行为。在执行任务的线程中将调用beforeExecute和afterExecute等方法，在这些方法中还可以添加日志、计时、监视或统计信息收集的功能。无论任务是从run中正常返回，还是抛出一个异常而返回，afterExecute都会被调用。（如果任务在完成后带有一个Error，那么就不会调用afterExecute。)如果beforeExecute抛出一个RuntimeException，那么任务将不被执行，并且afterExecute也不会被调用。</p>
<p>​    在线程池完成关闭操作时调用terminated，也就是在所有任务都已经完成并且所有工作者线程也已经关闭后。terminated可以用来释放Executor在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志或者收集finalize统计信息等操作。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimingThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = Logger.getLogger(<span class="string">"TimingThreadPool"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong numTasks = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong totalTime = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        log.fine(String.format(<span class="string">"Thread %s: start %s"</span>, t, r));</span><br><span class="line">        startTime.set(System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> taskTime = endTime - startTime.get();</span><br><span class="line">            numTasks.incrementAndGet();</span><br><span class="line">            totalTime.addAndGet(taskTime);</span><br><span class="line">            log.fine(String.format(<span class="string">"Thread %s: end %s, time=%dns"</span>, t, r, taskTime));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(String.format(<span class="string">"Terminated: avg time=%dns"</span>, totalTime.get() / numTasks.get()));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.terminated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>LF will be replaced by CRLF</title>
    <url>/2020/git/LF-will-be-replaced-by-CRLF/</url>
    <content><![CDATA[<p>本文主要写了在 Hexo 博客中 出现 LF will be replaced by CRLF 的原因以及它的解决方式。</p>
<h5 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h5><ol>
<li>windows中的换行符为 CRLF，而在Linux下的换行符为LF，所以在执行add时出现提示 </li>
<li>CRLF和LF是两种不同的换行格式，git工作区默认为CRLF来作为换行符，<br> 所以当我们项目文件里有用的地方使用LF作为换行符，这个时候我们再继续git add<br> 或者git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符 </li>
</ol>
<h5 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h5><ol>
<li>这个只是一个警告，我们直接忽略就好。</li>
<li>在hexo目下的.deploy_git目录下打开git bash 执行git config –global core.autocrlf false //禁用自动转换 </li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitPages搭建博客</title>
    <url>/2021/hexo/Hexo-GitPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>假设：邮箱：<a href="mailto:aaa@163.com" target="_blank" rel="noopener">aaa@163.com</a>  </p>
<p>​            名字: aaa</p>
<p>1.到官网下载git安装包后安装</p>
<p>2.在Windows系统安装git后，配置SSH key </p>
<p>用git bash执行如下命令： windows中在C:\Users\zhangyf.ssh目录</p>
<p><code>$ cd ~/. ssh #检查本机已存在的ssh密钥</code></p>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<p><code>ssh-keygen -t rsa -C &quot;aaa@163.com&quot;</code></p>
<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image002.png" alt="img"></p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<p>3.测试是否成功</p>
<p>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> # 注意邮箱地址不用改</p>
<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p>
<p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<p><code>git config --global user.email &quot;aaa@163.com&quot;</code></p>
<p><code>git config --global user.name &quot;aaa&quot;</code></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>在node.js官网下载安装包安装即可</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image004.jpg" alt="img"></p>
<p>然后在文件夹中右击打开git命令框(我第一次直接在桌面右击，所以命令行无效果)</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image006.jpg" alt="img"></p>
<p>在git命令框中安装hexo命令行工具 ，执行 <code>npm install -g hexo-cli</code> </p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image008.jpg" alt="img"></p>
<p> 初始化 ，执行<code>hexo init zyfblog</code> 加上zyfblog，则全部文件都在zyfblog下</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image010.jpg" alt="img"></p>
<p>执行<code>cd zyfblog</code> 进入zyfblog目录</p>
<p>启动服务，依次执行</p>
<p><code>(npm install --&gt;hexo server)</code></p>
<p>浏览器输入<a href="http://localhost:4000,按理来说应该会出现本地访问页面" target="_blank" rel="noopener">http://localhost:4000,按理来说应该会出现本地访问页面</a></p>
<h2 id="部署到GItPages"><a href="#部署到GItPages" class="headerlink" title="部署到GItPages"></a>部署到GItPages</h2><h3 id="在github上面创建项目"><a href="#在github上面创建项目" class="headerlink" title="在github上面创建项目"></a>在github上面创建项目</h3><p>假设:Owner为: zhangyfzone </p>
<p>​         <strong>Repository name必须为: zhangyfzone.github.io</strong></p>
<p>​         申请的域名：minmax.site</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/image-20210330094423950.png" alt="image-20210330094423950"></p>
<h3 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h3><p>如果没有域名，则只能通过GitPages默认链接访问<a href="https://zhangyfzone.github.io/" target="_blank" rel="noopener">https://zhangyfzone.github.io/</a></p>
<p>如果有域名，可将域名解析到zhangyfzone.github.io，这样比较简洁。</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image016.png" alt="img"></p>
<h3 id="hexo-CNAME设置"><a href="#hexo-CNAME设置" class="headerlink" title="hexo CNAME设置"></a>hexo CNAME设置</h3><p> Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀)</p>
<p>创建方式：右键新建txt文本-&gt;输入你购买的域名minmax.site&gt;保存关闭</p>
<p>然后快捷键F2或者右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image018.jpg" alt="img"></p>
<p>内容如下所示</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image019.png" alt="img"></p>
<h3 id="github上绑定域名"><a href="#github上绑定域名" class="headerlink" title="github上绑定域名"></a>github上绑定域名</h3><p>在设置中的custom domain填入域名minmax.site 保存</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image021.png" alt="img"></p>
<h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image023.jpg" alt="img"></p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image024.png" alt="img"></p>
<p>配置github项目连接(</p>
<p>deploy: </p>
<p>type: git </p>
<p>repos: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:zhangyfzone/zhangyfzone.github.io.git</p>
<p>branch: master):</p>
<p><img src="/2021/hexo/Hexo-GitPages搭建博客/clip_image026.jpg" alt="img"></p>
<h3 id="使用git发布"><a href="#使用git发布" class="headerlink" title="使用git发布"></a>使用git发布</h3><p>执行 <code>npm install hexo-deployer-git --save</code></p>
<p>基本的流程到这里快要结束了</p>
<p>信件一篇博文  <code>hexo new post &#39;第一篇博文&#39;</code>  可在source/post文件夹下面看到，可以编辑内容。</p>
<p>最后执行:<code>(hexo clean --&gt;hexo generate --&gt;hexo deploy)</code></p>
<p><code>hexo generate --&gt;hexo deploy</code> 可简写为 <code>hexo g -d</code></p>
<p>你就可以通过域名看到你的博客了</p>
<p>记住，每次修改配置信息或者其他必须要执行上面的步骤，才可以使得配置信息生效。</p>
<p> 常用命令：</p>
<p><code>hexo new &#39;博文&#39;</code>  默认创建post</p>
<p><code>hexo server</code></p>
<p><code>hexo g -d</code></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>7.取消与关闭</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/7.%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h3 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h3><p>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的(Cancellable),取消某个操作的原因很多：</p>
<ul>
<li>用户请求取消</li>
<li>有时间限制的操作</li>
<li>应用程序事件 比如得到正确结果返回</li>
<li>错误</li>
<li>关闭</li>
</ul>
<p>​    在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。其中一种协作机制能设置某个“已请求取消（Cancellation Requested)”标志，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled; <span class="comment">//设为volatile类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;BigInteger&gt; <span class="title">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PrimeGenerator generator = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">        exec.execute(generator);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            generator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generator.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>​    在使用BlockingQueue.put的生产者-消费者程序中，如果生产者的速度超过了消费者的处理速度，队列将被填满，put方法也会阻塞。当生产者在put方法中阻塞时，如果消费者希望取消生产者任务，那么将发生什么情况？它可以调用cancel方法来设置cancelled标志，但此时生产者却永远不能检查这个标志，因为它无法从阻塞的put方法中恢复过来（因为消费者此时已经停止从队列中取出素数，所以put方法将一直保持阻塞状态）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled = <span class="keyword">false</span>;</span><br><span class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!cancelled)</span><br><span class="line">                queue.put(p = p.nextProbablePrime());<span class="comment">//可导致阻塞，而无法读取cancel的值。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将被设置为true。在Thread中包含了中断线程以及查询线程中断状态的方法，“interrupt方法能中断目标线程，而islnterrupted方法能返回目标线程的中断状态。静态的interrupted方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。<img src="/2017/Java 并发编程实践/7.取消与关闭/7341859.png" alt="img"></p>
<p><strong>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</strong>对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。（这些时刻也被称为取消点）。</p>
<p>如果任务代码能够响应中断，那么可以使用中断作为取消机制，并且利用许多库类中提供中断的支持。<strong>通常，中断时实现取消的最合理方式。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())<span class="comment">//通过中断来取消线程</span></span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">            <span class="comment">/* Allow thread to exit */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h4><p>​    最合理的中断策略是某种形式的线程级(Thread-Level)取消操作或服务级(Service-Level)取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。</p>
<p>​    任务不会在其自己拥有的线程中执行，而是在某个服务（例如线程池）拥有的线程中执行。对于非线程所有者的代码来说（例如，对于线程池而言，任何在线程池实现以外的代码），应该小心地保存中断状态，这样拥有线程的代码才能对中断做出响应，即使“非所有者”代码也可以做出响应。（当你为一户人家打扫房屋时，即使主人不在，也不应该把在这段时间内收到的那件扔掉，而广该把邮件收起来，等主人回来以后再交给他们处理，尽管你可以阅读他们的杂志。）</p>
<p>​    这就是为什么大多数可阻塞的库函数都只是抛出InterruptedException作为中断响应。它们永远不会在某个由自己拥有的线程中运行，因此它们为任务或库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步的操作。</p>
<p>​    当检查到中断请求时，任务并不需要放弃所有的操作．一一它可以推迟处理中断请求，并直到某个更合适的时刻。因此需要记住中断请求，并在完成当前任务后抛出InterruptedException或者表示已收到中断请求。这项技术能够确保在更新过程中发生中断时，数据结构不会被破坏。</p>
<h4 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h4><p>有两种使用策略用于处理InterruptedException:</p>
<ul>
<li>传递异常，利用throws</li>
<li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li>
</ul>
<p>如果不想无法传递InterruptedException（或许通过Runnable来定义任务），那么需要寻找另一种方式来保存中断请求。一种标准的方法就是通过再次调用interrupt来恢复中断状态。你不能屏蔽InterruptedException，例如在catch块中捕获到异常却不做任何处理，除非在你的代码中实现了线程的中断策略。虽然PrimeProducer屏蔽了中断，但这是因为它已经知道线程将要结束，因此在调用栈中已经没有上层代码需要知道中断信息。由于大多数代码并不知道它们将在哪个线程中运行，因此应该保存中断状态。</p>
<h4 id="通过Future来实现取消"><a href="#通过Future来实现取消" class="headerlink" title="通过Future来实现取消"></a>通过Future来实现取消</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedRun</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService taskExec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.get(timeout, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="comment">// task will be cancelled below</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// exception thrown in task; rethrow</span></span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Harmless if task already completed</span></span><br><span class="line">            task.cancel(<span class="keyword">true</span>); <span class="comment">// interrupt if running</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h4><p>​    在Java库中，许多可阻塞的方法都是通过提前返回或者抛出InterruptedException来响应中断请求的，从而使开发人员更容易构建出能响应取消请求的任务。然而，并非所有的可阻塞方法或者阻塞机制都能响应中断；如果一个线程由于执行同步的SocketI/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。</p>
<ul>
<li><strong>Java.io包中的同步Socket I/O</strong>。在服务器应用程序中，最常见的阻塞I/O形式就是对套接字进行读取和写人。虽然InputStream和OutputStream中的read和write等方法都不会响应中断，但通过关闭底层的套接字，可以使得由于执行read或write等方法而被阻塞的线程抛出一个SocketException.</li>
<li><strong>Java.io包中的同步I/O</strong>。当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptException并关闭链路（这还会使得其他在这条链路上阻塞的线程同样抛出ClosedByInterruptException)。当关闭一个InterruptibleChannel时，将导致所有在链路操作上阻塞的线程都抛出AsynchronousCloseException.大多数标准的Channel都实现了InterruptibleChannel。</li>
<li><strong>Selector的异步I/O</strong>。如果一个线程在调用Selector.select方法（在java.nio.channels中）时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedSelectorExceptton并提前返回。</li>
<li><strong>获取某个锁</strong>。如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。但是，在Lock类中提供了locklnterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。</li>
</ul>
<h3 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h3><p>对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。</p>
<h4 id="关闭ExecutorService"><a href="#关闭ExecutorService" class="headerlink" title="关闭ExecutorService"></a>关闭ExecutorService</h4><p>​    我们看到ExecutorService提供了两种关闭方法：使用shutdown正常关闭，以及使用shutdownNow强行关闭。在进行强行关闭时，shutdownNow首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。</p>
<p>​    这两种关闭方式的差别在于各自的安全性和响应性：强行关闭的速度更快，但风险也更大，因为任务很可能在执行到一半时被结束：而正常关闭虽然速度慢，但却更安仝，因为ExecutorService会一直等到队列中的所有任务都执行完成后才关闭。在其他拥有线程的服务中也应该考虑提供类似的关闭方式以供选择。</p>
<h4 id="shutdownNow的局限性"><a href="#shutdownNow的局限性" class="headerlink" title="shutdownNow的局限性"></a>shutdownNow的局限性</h4><p>当通过shutdownNow来强行关ExecutorService时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，从而将这些任务写人日志或者保存起来以便之后进行处理。</p>
<p>然而，我们无法通过常规方法来找出哪些任务已经开始但尚未结束。这意味着我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身会执行某种检查。要知道哪些任务还没有完成，你不仅需要知道哪些任务还没有开始，而且还需要知道当Executor关闭时哪些任务正在执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; tasksCancelledAtShutdown = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Runnable&gt;());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrackingExecutor</span><span class="params">(ExecutorService exec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exec = exec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exec.isShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exec.isTerminated();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exec.awaitTermination(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exec.isTerminated())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="comment">/*...*/</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Runnable&gt;(tasksCancelledAtShutdown);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isShutdown() &amp;&amp; Thread.currentThread().isInterrupted())</span><br><span class="line">                        tasksCancelledAtShutdown.add(runnable);<span class="comment">//跟踪在关闭之后被取消的任务。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理非正常中止的线程"><a href="#处理非正常中止的线程" class="headerlink" title="处理非正常中止的线程"></a>处理非正常中止的线程</h3><p>当一个线程由于未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler异常处理器。如果没有提供任何异常处理器，那么默认的行为是将栈追踪信息输出到System.err。</p>
<p>异常处理器如何处理未捕获异常，取决于对服务质量的需求。最常见的响应方式是将一个错误信息以及相应的栈追踪信息写人应用程序日志中。异常处理器还可以采取更直接的响应，例如尝试重新启动线程，关闭应用程序，或者执行其他修复或诊断等操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">         * given uncaught exception.</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">         * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UEHLogger</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.SEVERE, <span class="string">"Thread terminated with exception: "</span> + t.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​     要为线程池中的所有线程设置一个UncaughtExceptionHandIer,需要为ThreadPooI-Executor的构造函数提供一个ThreadFactory（与所有的线程操控一样，只有线程的所有者能够改变线程的UncaughtExcepoonHandler。）标准线程池允许当发生未捕获异常时结束线程，但由于使用了一个try-finally代码块来接收通知，因此当线程结束时，将有新的线程来代替它。如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致极大的混乱．如果你希望在任务由于发生异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的Runnable或Callable中，或者改写ThreadPoolExecutor的afterExecute方法。</p>
<p>​    令人困惑的是，只有通过execute提交的任务，才能将它抛出的异常交给耒捕获异常处理器，而通过submit提交的任务，无论是抛出的未检查异常还是已检查异常，都将被认为是任务返回状态的一部分。如果一个由submit提交的任务由于抛出了异常而结束，那么这个异常将被Future.get封装在ExecutionException中重新抛出。</p>
<h3 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h3><h4 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h4><p>​    在正常关闭中，JVM首先调用所有已注册的关闭钩子（ShutdownHook）。关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。</p>
<p>在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true．那么JVM将运行终结器，然后再停止。JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。</p>
<p>​    关闭钩子应该是线程安全的：它们在访问共享数据时必须使用同步机制，并且小心地避免发生死锁，这与其他并发代码的要求相同。而且，关闭钩子不应该对应用程序的状态（例如，其他服务是否已经关闭，或者所有的正常线程是否已经执行完成）或者JVM的关闭原因做出任何假设，因此在编写关闭钩子的代码时必须考虑周全。最后，关闭钩子须尽快退出，因为它们会延迟JVM的结束时间，而用户可能希望JVM能尽快终止。</p>
<p>​    关闭钩子可以用于实现服务或应用程序的清理工作，例如删除临时文件，或者清除无法由操作系统自动清除的资源。由于关闭钩子将并发执行，因此在关闭日志文件时可能导致其他需要日志服务的关闭钩子产生问题，为了避免这种情况，关闭钩子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务。实现这种功能的一种方式是对所有服务使用同一个关闭钩子（而不是每个服务使用一个不同的关闭钩子），并且在该关闭钩子中执行一系列的关闭操作。这确保了关闭操作在单个线程中串行执行，从而避免了在关闭操作之间出现竞态条件或死锁等问题。无论是否使用关闭钩子，都可以使用这項技术，通过将各个关闭操作串行执行而不是并行执行，可以消除许多潜在的故障。当应用程序需要维护多个服务之间的显式依赖信息时，这项技术可以确保关闭操作接照正确的顺序执行。</p>
<p><img src="/2017/Java 并发编程实践/7.取消与关闭/3415392.png" alt="img"></p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>​    有时候，你希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍JVM的关闭。在这种情况下就需要使用守护线程（DaemonThread).线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾回收器以及其他执行辅助工作的线程)。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。</p>
<p>​    普通线程与守护线程之间的差异仅在于当线程退出时发生的作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃．一一既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。</p>
<p>​    我们应尽可能少地使用守护线程一一一很少有操作能够在不进行清理的情况下被安全地抛弃生特别是，如果在守护线程中执行可能包含I/0操作的任务，那么将是一种危险的行为。守护线程最好用于执行“内部”任务·例如周期性地从内存的缓存中移除逾期的数据。</p>
<h4 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h4><p>finalize方法，避免使用。</p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署到VPS</title>
    <url>/2021/hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>网上流传的武功秘籍分为两种：</p>
<ul>
<li>将 Hexo 项目上传到 VPS 上面后执行 <code>hexo server</code>，之后配置 Nginx 反向代理，让域名指向 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>。</li>
<li>将 Hexo 在本地通过 <code>hexo generate</code> 生成静态文件，在通过 <code>hexo deploy</code> 部署到 VPS 上面，使用 Nginx 直接做 Web 服务器。</li>
</ul>
<p>相比第二种方式，第一种每次写博客与更新博客时候的操作会很繁琐。所以我们使用第二种方式进行部署，这样既可以将静态文件 deploy 到 VPS 上，也可以上传到 Github 上用作备份，操作性和安全性上都要胜于前者。</p>
<p>而对于第二种方式而言，常用的又有 <code>git hook</code> 和 <code>rsync</code> 两种自动部署解决方案。</p>
<p>本文主要介绍 <code>git hook</code> 部署过程，过程为：</p>
<p>我们在本地编辑文本，然后使用 Git 远程部署到 VPS 的 Git 仓库。<code>hexo d</code> 命令实际上只 deploy 了本地的 public 文件夹，Git Hooks 实际上就是当 Git 仓库收到最新的 push 时，将 Git 仓库接受到的内容复制到 VPS 上的网站目录内。相当于完成了手动将 public 文件夹复制到 VPS 的网站根目录里。</p>
<p>在vps上搭建hexo博客需要下面这些工具：</p>
<ol>
<li>Nginx: 用于博客展示</li>
<li>SSH：用于Git 推送</li>
<li>Git: 用于将生成的静态文件推送到vps上</li>
</ol>
<p>本文服务器环境为CentOS 7.6</p>
<p>之前本地已经搭建好Hexo博客，之前是提交到Github进行更新</p>
<h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>查看C:\Users\用户名\.ssh 下是否存在私钥文件<code>id_rsa</code>和公钥文件<code>id_rsa.pub</code></p>
<p>如果没有，则需要通过<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code> 生成</p>
<h2 id="VPS端配置"><a href="#VPS端配置" class="headerlink" title="VPS端配置"></a>VPS端配置</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>ssh连接到VPS后，执行如下指令进行Git的安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update &amp;&amp; upgrade -y</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install git-core</span><br></pre></td></tr></table></figure>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx -y</span><br><span class="line">service nginx start  #启动nginx</span><br></pre></td></tr></table></figure>
<p>如果开启了防火墙，还要在防火墙上开启响应端口，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">启动： systemctl start firewalld</span><br><span class="line">关闭： systemctl stop firewalld</span><br><span class="line">查看状态： systemctl status firewalld </span><br><span class="line">开机禁用 ： systemctl disable firewalld</span><br><span class="line">开机启用 ： systemctl enable firewalld</span><br></pre></td></tr></table></figure>
<p>安装完Nginx后，最好设置Nginx为开机自启动，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h3 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h3><ol>
<li>新建git用户，在终端输入如下指令以新建账户，专门用于提交git</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">adduser git #创建新用户，名为git</span><br></pre></td></tr></table></figure>
<p>接下来修改git账户的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>在<code>root ALL=(ALL) ALL</code>下面新建一段字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git ALL=(ALL) install</span><br></pre></td></tr></table></figure>
<p>接着保存退出，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 440 /etc/sudoers</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建git仓库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git                 # 操作转到git用户</span><br><span class="line">cd                     # 定位到Home目录</span><br><span class="line">mkdir .ssh &amp;&amp; cd .ssh  # 创建.ssh文件夹并进入</span><br><span class="line">vi authorized_keys     # 创建密钥文件</span><br></pre></td></tr></table></figure>
<p>此时，将本地<code>id_rsa.pub</code>文件内的内容粘贴到新建的<code>authorized_keys</code>文件中。接下来执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">mkdir hexo.git &amp;&amp; cd hexo.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<p>此时，在本地终端中输入<code>ssh git@VPS_ip</code>查看收否能连接，如果提示要密码，则需要在VPS内设置一下git用户的密码，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd git</span><br></pre></td></tr></table></figure>
<p>接着设置git用户的密码，并在本地终端中重新连接，输入密码，应该就可以连接了。</p>
<p>如果部署时还是需要密码，则是authorized_keys 文件权限设置有问题，请查看博客里的另一篇文章 <a href="http://www.minmax.site/2021/03/25/authorized-keys不生效解决办法/" target="_blank" rel="noopener">authorized_keys不生效解决办法</a></p>
<ol start="3">
<li>接下来要创建网站的目录，并赋予权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">cd /var/www</span><br><span class="line">mkdir hexo</span><br><span class="line">chown git:git -R /var/www/hexo</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置Git Hooks</li>
</ol>
<p>【注意】这一步在git用户下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">cd /home/git/hexo.git/hooks</span><br><span class="line">vi post-receive</span><br></pre></td></tr></table></figure>
<p>输入如下内容后保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">GIT_REPO=/home/git/hexo.git       #git仓库路径</span><br><span class="line">TMP_GIT_CLONE=/tmp/hexo</span><br><span class="line">PUBLIC_WWW=/var/www/hexo          #hexo网站目录</span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;/*</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>
<p>接着赋予权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
<h3 id="Nginx相关配置"><a href="#Nginx相关配置" class="headerlink" title="Nginx相关配置"></a>Nginx相关配置</h3><p>【注意】本操作在root用户下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">vim /etc/nginx/conf.d/hexo.conf</span><br></pre></td></tr></table></figure>
<p>插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80 ;</span><br><span class="line">    root /var/www/hexo; //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">    server_name example.com www.example.com;   //这里输入你的域名或IP地址</span><br><span class="line">    access_log  /var/log/nginx/hexo_access.log;</span><br><span class="line">    error_log   /var/log/nginx/hexo_error.log;</span><br><span class="line">    location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">            root /var/www/hexo;</span><br><span class="line">            access_log   off;</span><br><span class="line">            expires      1d;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">        root /var/www/hexo;</span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      10m;</span><br><span class="line">    &#125;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/hexo;      //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">        if (-f $request_filename) &#123;</span><br><span class="line">            rewrite ^/(.*)$  /$1 break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<h2 id="本地Hexo配置修改"><a href="#本地Hexo配置修改" class="headerlink" title="本地Hexo配置修改"></a>本地Hexo配置修改</h2><p>在本地<code>hexo</code>博客文件下，编辑配置文件<code>\_config.yml</code>，修改<code>deploy</code>选项，可同时发布到github和vps</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:zhangyfzone/zhangyfzone.github.io.git  #gitHub上用作备份</span><br><span class="line">    branch: master</span><br><span class="line">  - type: git</span><br><span class="line">    repo: ssh://git@VPSIP:端口号/~/hexo.git   #部署到VPS上</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>保存修改后，便可以使用<code>hexo g</code>,<code>hexo d</code>等指令进行博客更新了。</p>
<h2 id="gitHub配置更改"><a href="#gitHub配置更改" class="headerlink" title="gitHub配置更改"></a>gitHub配置更改</h2><p>如果之前部署到github上时设置了域名，则再setting里把custom domain 之前设置的域名清除。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>authorized_keys不生效解决办法</title>
    <url>/2021/hexo/authorized-keys%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>​        在Linux中部署git服务器时，window客户端 执行ssh-keygen在目录<code>C:\Users\zhangyf \.ssh</code> 生成 id_rsa和id_rsa.pub。</p>
<p>将id_rsa.pub内容上传到Linux的/home/git/.ssh/authorized_keys 时， <code>service sshd restart</code> 命令重启了SSH服务， </p>
<p>在windows 打开cmd执行ssh git@VPSIP  -p 28094 需要输入密码。</p>
<p>解决方案：</p>
<p>linux 目录结构为 /home/git/.ssh/authorized_keys  用户和组都为git</p>
<p>/home/git目录必须是 755权限 即drwxr-xr-x  </p>
<p>/home/git/.ssh目录必须是700权限(也就是drwx——)</p>
<p>/home/git/.ssh/authorized_keys 文件必须是600权限(也就是-rw——-)或者644</p>
<p>缺一不可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo本地图片不显示</title>
    <url>/2020/hexo/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li><p>修改文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
</li>
<li><p>修改之后，再使用<code>hexo new post &quot;hexo本地图片不显示&quot;</code>时，目录的样子是</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">├── 01.jpg</span><br><span class="line">├── 02.jpg</span><br><span class="line">└── 03.jpg</span><br><span class="line">...</span><br><span class="line">hexo本地图片不显示.md</span><br></pre></td></tr></table></figure>
<h3 id="安装插件hexo-asset-image"><a href="#安装插件hexo-asset-image" class="headerlink" title="安装插件hexo-asset-image"></a>安装插件hexo-asset-image</h3><ul>
<li>GitHub地址 <a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a></li>
<li>npm安装 (需要提前安装Node.js)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p><img src="/2020/hexo/hexo本地图片不显示/1.png" alt="图片描述"><br><strong>注意</strong> 不要使用<code>npm install hexo-asset-image --save</code>这个命令安装,<strong>版本号不对</strong><br><img src="/2020/hexo/hexo本地图片不显示/2.png" alt="图片描述"></p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h4 id="0-0-5版本"><a href="#0-0-5版本" class="headerlink" title="0.0.5版本"></a>0.0.5版本</h4><p><img src="/2020/hexo/hexo本地图片不显示/3.png" alt="图片描述"></p>
<h4 id="1-0-0版本"><a href="#1-0-0版本" class="headerlink" title="1.0.0版本"></a>1.0.0版本</h4><p><img src="/2020/hexo/hexo本地图片不显示/4.png" alt="图片描述"></p>
<h3 id="在md中书写格式（相对路径）"><a href="#在md中书写格式（相对路径）" class="headerlink" title="在md中书写格式（相对路径）"></a>在md中书写格式（相对路径）</h3><p>在md使用如下形式引用图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 这里要使用<code>&quot;/&quot;</code></p>
<h3 id="md文件名称和图片存放文件夹名称不同时"><a href="#md文件名称和图片存放文件夹名称不同时" class="headerlink" title="md文件名称和图片存放文件夹名称不同时"></a>md文件名称和图片存放文件夹名称不同时</h3><p><strong>注意</strong> <code>重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</code></p>
<p><img src="/2020/hexo/hexo本地图片不显示/5.png" alt="图片描述"></p>
<ul>
<li><code>文件和文件夹以url中的名称保持一致</code></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>检查<code>_config.yml</code> 文件的<code>post_asset_folder:</code>选项是否为<code>true</code></li>
<li>检查创建文件之后的目录结构</li>
<li>检查<code>hexo-asset-image</code>插件的版本</li>
<li>检查路径引用图片的路径使用<code>/</code></li>
<li>检查md文件的文件名称和图片存放文件夹名称是否相同</li>
</ul>
<p>转载于：<a href="https://blog.csdn.net/Strong997/article/details/97767929" target="_blank" rel="noopener">https://blog.csdn.net/Strong997/article/details/97767929</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>14.原子变量与非阻塞同步机制</title>
    <url>/2017/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/14.%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​    近年来，在并发算法领域的大多数研究都侧重于非阻塞算法，这种算法用底层的原子机器指令（例如比较并交换指令）代替锁来确保数据在并发访问中的一致性。非阻塞算法被广泛地用于在操作系统和JVM中实现线程/进程调度机制、垃圾回收机制以及锁和其他并发数据结构。</p>
<p>​    与基于锁的方案相比，非阻塞算法在设计和实现上都要复杂得多，但它们在可伸缩性和活跃性上却拥有巨大的优势·由于非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大地减少调度开销。而且，在非阻塞算法中不存在死锁和其他活跃性问题。在基于锁的算法中，如果一个线程在休眠或自旋的同时持有一个锁，那么其他线程都无法执行下去，而非阻塞算法不会受到单个线程失败的影响。从Java5．0开始，可以使用原子变量类（例如Atomiclnteger和AtomicReference)来构建高效的非阻塞算法。</p>
<p>​    即使原子变量没有用于非阻塞算法的开发，它们也可以用做一种“更好的volatile类型变量”。原子变量提供了与volatile类型变量相同的内存语义，此外还支持原子的更新操作，从而使它们更加适用于实现计数器、序列发生器和统计数据收集等，同时还能比基于锁的方法提供更高的可伸缩性。</p>
<h2 id="锁的劣势"><a href="#锁的劣势" class="headerlink" title="锁的劣势"></a>锁的劣势</h2><p>​    通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都能采用独占方式来访问这些变量，并且对变量的任何修改对随后获得这个锁的其他线程都是可见的。</p>
<p>​     现代的许多JVM都对非竞争锁获取和锁释放等操作进行了极大的优化，但如果有多个线程同时请求锁，那么JVM就需要借助操作系统的功能“如果出现了这种情况，那么一些线程将被挂起并且在稍后恢复运行：当线程恢复执行时，必须等待其他线程执行完它们的时间片以后，才能被调度执行·在挂起和恢复线程等过程中存在着很大的开销，并且通常存在着较长时间的中断。如果在基于锁的类中包含有细粒度的操作（例如同步容器类，在其大多数方法中只包含了少量操作），那么当在锁上存在着激烈的竞争时，调度开销与工作开销的比值会非常高。</p>
<p>​    与锁相比，volatile变量是一种更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换或线程调度等操作。然而，volatile变量同样存在一些局限：<strong>虽然它们提供了相似的可见性保证，但不能用于构建原子的复合操作</strong>。因此，当一个变量依赖其他的变量时，或者当变量的新值依赖于旧值时，就不能使用volatile变量。这些都限制了volatile变量的使用，因此它们不能用来实现一些常见的工具，例如计数器或互斥体(mutex)。例如，虽然自增操作（++i）看起来像一个原子操作，但事实上它包含了3个独立的操作：获取变量的当前值，将这个值加1，然后再写人新值。为了确保更新操作不被丢失，整个的读一改一写作须是原子的。到目前为止，我们实现这种原子操作的唯一方式就是使用锁定方法。</p>
<p>​    锁定还存在其他一些缺点。<strong>当一个线程正在等待锁时，它不能做任何其他事情</strong>。如果一个线程在持有锁的情况下被延迟执行（例如发生了缺页错误、调度延迟，或者其他类似情况），那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，那么这将是一个严重的问题一一也被称为优先级反转（PnorityInversion).</p>
<p>​    即使高优先级的线程可以抢先执行，但仍然需要等待锁被释放，从而导致它的优先级会降至低优先级线程的级别。如果持有锁的线程被永久地阻塞（例如由于出现了无限循坏，死锁，活锁或者其他的活跃性故障),所有等待这个锁的线程就永远无法执行下去。即使忽略这些风险，锁定方式对于细粒度的操作（例如递增计数器）来说仍然是一种高开销的机制。在管理线程之间的竞争时应该有一种粒度更细的技术，类似于volatile变量的机制，同时还要支持原子的更新作。幸运的是，在现代的处理器中提供了这种机制。</p>
<h2 id="硬件对并发的支持"><a href="#硬件对并发的支持" class="headerlink" title="硬件对并发的支持"></a>硬件对并发的支持</h2><p>​    独占锁是一项悲观技术，它假设最坏的情况〈如果你不锁门，那么捣蛋鬼就会闯人并搞得一团糟),并且只有在确保其他线程不会造成干扰（通过获取正确的锁）的情况下才能执行</p>
<p>下去。</p>
<p>​    对于细粒度的操作，还有另外一种更高效的方法，也是一种乐观的方法，通过这种方法可以在不发生干扰的情况下完成更新操作。这种方法需要借助冲突检查机制来判断在更新过程中是否存在来自其他线程的干扰，如果存在，这个操作将失败，并且可以重试（也可以不重试)。这种乐观的方法就好像一句谚语：“原谅比准许更容易得到”，其中“更容易”在这里相当于“更高效”。</p>
<p>​    在针对多处理器操作而设计的处理器中提供了一些特殊指令，用于管理对共享数据的并发访问。在早期的处理器中支持原子的试并设置（Test-and-set)，获取并递增(Fetch-and-Increment)以及交换(Swap)等指令，这些指令足以实现各种互斥体，而这些互斥体又可以实现一些更复杂的并发对象。现在，几乎所有的现代处理器中都包含了某种形式的原子读-改-写指令，例如比较并交换（Compare-and-Swap）或者关联加载/条件存储(Load-Linked/Store-Conditional)。操作系统和JVM使用这些指令来实现锁和并发的数据结构，但在Java5.0之前，在Java类中还不能直接使用这些指令。</p>
<h3 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h3><p>​    CAS包含了3个操作数一需要读写的内存位置V、进行比较的值A和拟写人的新值B.当且仅当v的值等于A时，CAS才会通过原子方式用新值B来更新v的值，否则不会执行任何操作。无论位置V的值是否等于A，都将返回V原有的值。（这种变化形式被称为比较并设置，无论操作是否成功都会返回。）CAS的含义是：“我认为V的值应该为A，如果是，那么将V的值更新为B,否则不修改并告诉V的值实际为多少”。CAS是一项乐观的技术，它希望能成功地执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么CAS能检测到这个错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Simulated CAS operation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue,<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue)</span><br><span class="line">            value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue,<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (expectedValue== compareAndSwap(expectedValue, newValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当多个线程尝试使用同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败。然而，失败的线程并不会被挂起（这与获取锁的情况不同：当获取锁失败时，线程将被挂起而是被告知在这次竞争中失败，并可以再次尝试。由于一个线程在竞争CAS时失败不会阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，也或者不执行任何擬作。而这种灵活性就大大减少了与锁相关的活跃性风险（尽管在一些不常见的情况下仍然存在活锁风险）。</p>
<p>​    CAS的典型使用模式是：首先从V中读取值A，并根据A计算新值B,然后再通过CAS以原子方式将v中的值由A变成B（只要在这期间没有任何线程将V的值修改为其他值）。由于CAS能检测到来自其他线程的干扰，因此即使不使用锁也能罅实现原子的读一改一写操作序列。  </p>
<h3 id="非阻塞的计数器"><a href="#非阻塞的计数器" class="headerlink" title="非阻塞的计数器"></a>非阻塞的计数器</h3><p>​    CasCounter使用CAS实现了一个线程安全的计数器。递增操作采用了标准形式一一读取旧的值，根据它计算出新值（加1)，并使用CAS来设置这个新值．如果CAS失败，那么该操作将立即重试。通常，反复地重试是一种合理的策略，但在一些竞争很激烈的情况下，更好的方式是在重试之前首先等待一段时间或者回退，从而避免造成活锁问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nonblocking counter using CAS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SimulatedCAS value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = value.get();</span><br><span class="line">        &#125; <span class="keyword">while</span> (v != value.compareAndSwap(v, v + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    初看起来，基于CAS的计数器似乎比基于锁的计数器在性能上更差一些，因为它需要执行更多的操作和更复杂的控制流，并且还依赖看似复杂的CAS作。但实际上，当竟争程度不高时，基于CAS的计数器在性能上远远超过了基于锁的计数器，而在没有竞争时甚至更高。如果要快速获取无竞争的锁，那么至少需要一次CAS操作再加上与其他锁相关的操作，因此基于的计数器即使在最好的情况下也会比基于的计数器在一般情况下能执行更多的操作。由于CAS在大多数情况下都能成功执行（假设竞争程度不高），因此硬件能够正确地预测while循环中的分支，从而把复杂控制逻辑的开销降至最低。</p>
<p>​    虽然Java语言的锁定语法比较简洁，但JVM和操作在管理锁时需要完成的工作却并不简单。在实现锁定时需要遍历JVM中一条非常复杂的代码路径，并可能导致操作系统级的锁定、线程挂起以及上下文切换等操作。在最好的情况下，在锁定时至少需要一次CAS，因此虽然在使用锁时没有用到CAS，但实际上也无法节约任何执行开销。另一方面，在程序内部执行CAS时不需要执行JVM代码、系统调用或线程调度作。在应用级上看起来越长的代码路径，如果加上JVM和作系统中的代码调用，那么事实上却变得更短。CAS的主要缺点是，它将使调用者处理竞争问题（通过重试、回退、放弃），而在锁中能自动处理竞争问题（线程在获得锁之前将一直阻塞).</p>
<p>​    CAS的性能会随着处理器数量的不同而变化很大。在单CPU系统中，CAS通常只需要很少的时钟周期，因为不需要处理器之间的同步。在编写本书时，非竞争的CAS在多CPU系统中需要10到150个时钟周期的开销。CAS的执行性能不仅在不同的体系架构之间变化很大，甚至在相同处理器的不同版本之间也会发生改变。生产厂商迫于竞争的压力，在接下来的几年内还会继续提高CAS的性能。一个很管用的经验法则是：<strong>在大多数处理器上，在无竞争的锁获取和释放的“快速代码路径”上的开销，大约是CAS开销的两倍。</strong></p>
<h3 id="JVM对CAS的支持"><a href="#JVM对CAS的支持" class="headerlink" title="JVM对CAS的支持"></a><strong>JVM对CAS的支持</strong></h3><p>​    那么，Java代码如何确保处理器执行CAS操作？在Java5.0之前，如果不编写明确的代码，那么就无法执行CAS。在Java5．0中引人了底层的支持，在Int、long和对象的引用等类型上都公开了CAS操作，并且JVM把它们编译为底层硬件提供的最有效方法。在支持CAS的平台上，运行时把它们编译为相应的（多条）机器指令。在最坏的情况下，如果不支持CAS指令，那么JVM将使用自旋锁。在原子变量类（例如java.utll.concurrent.atomic中的Atomicxxx）中使用了这些底层的JVM支持为数字类型和引用类型提供一种高效的CAS操作，而在java-util.concurrent中的大多数类在实现时则直接或间接地使用了这些原子变量类。</p>
<h2 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类 "></a>原子变量类<img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/11529175.png" alt="img"> <img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/11537974.png" alt="img"></h2><h3 id="原子变量是一种更好的”volatile”"><a href="#原子变量是一种更好的”volatile”" class="headerlink" title="原子变量是一种更好的”volatile”"></a>原子变量是一种更好的”volatile”</h3><h3 id="性能比较：锁与原子变量"><a href="#性能比较：锁与原子变量" class="headerlink" title="性能比较：锁与原子变量"></a>性能比较：锁与原子变量<img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/21527950.png" alt="img"></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PseudoRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateNext</span><span class="params">(<span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">        prev ^= prev &lt;&lt; <span class="number">6</span>;</span><br><span class="line">        prev ^= prev &gt;&gt;&gt; <span class="number">21</span>;</span><br><span class="line">        prev ^= (prev &lt;&lt; <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockPseudoRandom</span> <span class="keyword">extends</span> <span class="title">PseudoRandom</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Random number generator using ReentrantLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seed;</span><br><span class="line">    ReentrantLockPseudoRandom(<span class="keyword">int</span> seed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.seed = seed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> s = seed;</span><br><span class="line">            seed = calculateNext(s);</span><br><span class="line">            <span class="keyword">int</span> remainder = s % n;</span><br><span class="line">            <span class="keyword">return</span> remainder &gt; <span class="number">0</span> ? remainder : remainder + n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicPseudoRandom</span> <span class="keyword">extends</span> <span class="title">PseudoRandom</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Random number generator using AtomicInteger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger seed;</span><br><span class="line">    </span><br><span class="line">    AtomicPseudoRandom(<span class="keyword">int</span> seed) &#123;</span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicInteger(seed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = seed.get();</span><br><span class="line">            <span class="keyword">int</span> nextSeed = calculateNext(s);</span><br><span class="line">            <span class="keyword">if</span> (seed.compareAndSet(s, nextSeed)) &#123;</span><br><span class="line">                <span class="keyword">int</span> remainder = s % n;</span><br><span class="line">                <span class="keyword">return</span> remainder &gt; <span class="number">0</span> ? remainder : remainder + n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/21639943.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/21711719.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/21743700.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/21787084.png" alt="img"></p>
<h2 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h2><p> <img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/28808143.png" alt="img"> </p>
<h3 id="非阻塞的栈"><a href="#非阻塞的栈" class="headerlink" title="非阻塞的栈"></a>非阻塞的栈</h3><p><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/2510851.png" alt="img"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Treiber算法(Treiber 1986)构造的非阻塞栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class="keyword">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; newHead = <span class="keyword">new</span> Node&lt;E&gt;(item);</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            newHead.next = oldHead;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        Node&lt;E&gt; newHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            <span class="keyword">if</span> (oldHead == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            newHead = oldHead.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</span><br><span class="line">        <span class="keyword">return</span> oldHead.item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> E item;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;E&gt; next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞的链表"><a href="#非阻塞的链表" class="headerlink" title=" 非阻塞的链表"></a><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/2592471.png" alt="img"> 非阻塞的链表<img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/7249990.png" alt="img"></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Michael-Scott(Michael and Scott 1996)非阻塞短发中的插入算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E item;</span><br><span class="line">        <span class="keyword">final</span> AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, LinkedQueue.Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">new</span> AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedQueue.Node&lt;E&gt; dummy = <span class="keyword">new</span> LinkedQueue.Node&lt;E&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; head = <span class="keyword">new</span> AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; tail = <span class="keyword">new</span> AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        LinkedQueue.Node&lt;E&gt; newNode = <span class="keyword">new</span> LinkedQueue.Node&lt;E&gt;(item, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            LinkedQueue.Node&lt;E&gt; curTail = tail.get();</span><br><span class="line">            LinkedQueue.Node&lt;E&gt; tailNext = curTail.next.get();</span><br><span class="line">            <span class="keyword">if</span> (curTail == tail.get()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tailNext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Queue in intermediate state, advance tail</span></span><br><span class="line">                    tail.compareAndSet(curTail, tailNext);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// In quiescent state, try inserting new node</span></span><br><span class="line">                    <span class="keyword">if</span> (curTail.next.compareAndSet(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                        <span class="comment">// Insertion succeeded, try advancing tail</span></span><br><span class="line">                        tail.compareAndSet(curTail, newNode);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/7910826.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/7933259.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/7949358.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/7975129.png" alt="img"> </p>
<h3 id="原子的域更新器"><a href="#原子的域更新器" class="headerlink" title="原子的域更新器"></a>原子的域更新器</h3><p> <img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/8472523.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/8480744.png" alt="img"> </p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p> <img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/8840311.png" alt="img"><img src="/2017/Java 并发编程实践/14.原子变量与非阻塞同步机制/8870092.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java 并发编程实践</category>
      </categories>
      <tags>
        <tag>Java 并发编程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>CollectionUtils工具类</title>
    <url>/2020/java/CollectionUtils%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>这篇讲的CollectionUtils工具类是在<code>apache下</code>的, 而不是springframework下的CollectionUtils。</p>
<p>个人觉得CollectionUtils在真实项目中,可以使你的代码更加简洁和安全。</p>
<p>所以需要倒入相关jar包,目前从maven找到最新jar包如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="API常用方法"><a href="#API常用方法" class="headerlink" title="API常用方法"></a>API常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、除非元素为null，否则向集合添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.addIgnoreNull(personList,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b, Comparator&lt;? <span class="keyword">super</span> O&gt; c)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、返回该个集合中是否含有至少有一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.containsAny(Collection&lt;?&gt; coll1, T... coll2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&lt;&gt;()）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.emptyIfNull(Collection&lt;T&gt; collection)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6、空安全检查指定的集合是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、 空安全检查指定的集合是否为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isNotEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8、反转给定数组的顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.reverseArray(Object[] array);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 9、差集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.subtract(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10、并集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.union(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 11、交集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.intersection(Collection a, Collection b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *12、 交集的补集（析取）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.disjunction(Collection a, Collection b)</span><br></pre></td></tr></table></figure>
<h2 id="非对象集合交、并、差处理"><a href="#非对象集合交、并、差处理" class="headerlink" title="非对象集合交、并、差处理"></a>非对象集合交、并、差处理</h2><p>对于集合取交集、并集的处理其实有很多种方式,这里就介绍3种</p>
<ul>
<li>第一种 是CollectionUtils工具类</li>
<li>第二种 是List自带方法</li>
<li>第三种 是JDK1.8 stream 新特性</li>
</ul>
<h3 id="CollectionUtils工具类"><a href="#CollectionUtils工具类" class="headerlink" title="CollectionUtils工具类"></a>CollectionUtils工具类</h3><p>下面对于基本数据(包扩String)类型中的集合进行demo示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">       String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">       List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">       List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1、并集 union</span></span><br><span class="line">       System.out.println(CollectionUtils.union(listA, listB));</span><br><span class="line">       <span class="comment">//输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、交集 intersection</span></span><br><span class="line">       System.out.println(CollectionUtils.intersection(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//3、交集的补集（析取）disjunction</span></span><br><span class="line">       System.out.println(CollectionUtils.disjunction(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4、差集（扣除）</span></span><br><span class="line">       System.out.println(CollectionUtils.subtract(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="List自带方法"><a href="#List自带方法" class="headerlink" title="List自带方法"></a>List自带方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、交集</span></span><br><span class="line">    List&lt;String&gt;  jiaoList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    jiaoList.retainAll(listB);</span><br><span class="line">    System.out.println(jiaoList);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、差集</span></span><br><span class="line">    List&lt;String&gt;  chaList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    chaList.removeAll(listB);</span><br><span class="line">    System.out.println(chaList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、并集 (先做差集再做添加所有）</span></span><br><span class="line">    List&lt;String&gt;  bingList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    bingList.removeAll(listB); <span class="comment">// bingList为 [1, 2]</span></span><br><span class="line">    bingList.addAll(listB);  <span class="comment">//添加[3,4,5,6]</span></span><br><span class="line">    System.out.println(bingList);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>注意</code> : <strong>intersection和retainAll的差别</strong></p>
<p>要注意的是它们的返回类型是不一样的,<code>intersection</code>返回的是一个新的List集合，而<code>retainAll</code>返回是Bollean类型那就说明retainAll方法是对原有集合进行处理再返回原有集合,会改变原有集合中的内容。</p>
<p><code>个人观点</code>：1、从性能角度来考虑的话,List自带会高点,因为它不用再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使用就不适合用retainAll。</p>
<p><code>注意</code>: Arrays.asList将数组转集合不能进行add和remove操作。</p>
<p><code>原因</code>：调用Arrays.asList()生产的List的add、remove方法时报异常，这是由<strong>Arrays.asList() 返回的市Arrays的内部类ArrayList， 而不是java.util.ArrayList</strong>。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重新了这些方法而Arrays的内部类ArrayList没有重新，所以会抛出异常。</p>
<p>所以正确做法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">arrList.add(<span class="string">"6"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="JDK1-8-stream-新特性"><a href="#JDK1-8-stream-新特性" class="headerlink" title="JDK1.8 stream 新特性"></a>JDK1.8 stream 新特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    List&lt;String&gt; intersection = listA.stream().filter(item -&gt; listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(intersection);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 差集 (list1 - list2)</span></span><br><span class="line">    List&lt;String&gt; reduceList = listA.stream().filter(item -&gt; !listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(reduceList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并集 （新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。</span></span><br><span class="line">    List&lt;String&gt; listAll = listA.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = listB.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(listAll);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重并集 </span></span><br><span class="line">    List&lt;String&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    list.addAll(listB);</span><br><span class="line">    List&lt;String&gt; listAllDistinct = list.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(listAllDistinct);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>总结</code> ： 这三种我还是<code>最喜欢第一种方式</code>，因为第二种还需要确定该集合是否被多次调用。第三种可读性不高。</p>
<h2 id="对象集合交、并、差处理"><a href="#对象集合交、并、差处理" class="headerlink" title="对象集合交、并、差处理"></a>对象集合交、并、差处理</h2><p>因为对象的equels比较是比较两个对象的内存地址，所以除非是同一对象，否则equel返回永远是false。</p>
<p>但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法。</p>
<p><code>说明</code> :String为什么可以使用equels方法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode方法，比较的是值。</p>
<h3 id="Person对象"><a href="#Person对象" class="headerlink" title="Person对象"></a>Person对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么重写equals方法一定要重写hashCode方法下面也会讲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = name + age;</span><br><span class="line">        <span class="keyword">return</span> result.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法 根据name和age都相同那么对象就默认相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Person u = (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里根据name和age都相同那么就默认相同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; personList = Lists.newArrayList();</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    personList.add(person1);</span><br><span class="line">    personList.add(person2);</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; person1List = Lists.newArrayList();</span><br><span class="line">    Person person3 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    Person person4 = <span class="keyword">new</span> Person(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    person1List.add(person3);</span><br><span class="line">    person1List.add(person4);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.subtract(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.union(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='中中', age=4&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.intersection(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='中中', age=4&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、交集的补集（析取）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.disjunction(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它两种方式就不在测了，因为都一样。</p>
<h2 id="为什么重写equels方法一定要重写hashCode方法"><a href="#为什么重写equels方法一定要重写hashCode方法" class="headerlink" title="为什么重写equels方法一定要重写hashCode方法"></a>为什么重写equels方法一定要重写hashCode方法</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>其实上面的Person类我可以只重写equels方法而不写hashCode方法,一样能达到上面的效果。但为什么还是建议写上呢？官方的说法是:<code>对象的equals方法被重写，那么对象的hashCode()也尽量重写</code>。</p>
<p>重写equals()方法就必须重写hashCode()方法的原因，从源头Object类讲起就更好理解了。</p>
<p>先来看Object关于hashCode()和equals()的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line">      </span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">         return (this == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>光从代码中我们可以知道，<code>hashCode()方法是一个本地native方法</code>，返回的是对象引用中存储的对象的内存地址。而equals方法是利用==来比较的也是对象的内存地址。从上边我们可以看出，hashCode方法和equals方法是一致的。还有最关键的一点，我们来看Object类中关于hashCode()方法的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。    </span><br><span class="line">2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。    </span><br><span class="line">3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。</span><br><span class="line">   但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</span><br></pre></td></tr></table></figure>
<p><code>整理</code> : hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode可以不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。</p>
<p>假设两个对象，重写了其equals方法，其相等条件是某属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。</p>
<h3 id="HashSet和Map集合类型"><a href="#HashSet和Map集合类型" class="headerlink" title="HashSet和Map集合类型"></a>HashSet和Map集合类型</h3><p>重写equals()方法就必须重写hashCode()方法主要是针对HashSet和Map集合类型,而对于List集合倒没什么影响。</p>
<p><code>原因</code>： 在向HashSet集合中存入一个元素时，HashSet会调用该对象（存入对象）的hashCode()方法来得到该对象的hashCode()值，然后<code>根据该hashCode值决定该对象在HashSet中存储的位置</code>。简单的说：<code>HashSet集合判断两个元素相等的标准是：两个对象通过equals()方法比较相等，并且两个对象的HashCode()方法返回值也相等</code>。如果两个元素通过equals()方法比较返回true，但是它们的hashCode()方法返回值不同，HashSet会把它们存储在不同的位置，依然可以添加成功。</p>
<p><code>这就是问题所在</code>：就是如果你只重写equals()方法，而不重写hashCode(),如果equals()为true,而它们的hashCode()方法返回值肯定不一样，因为它们都不是同一对象所以内存地址肯定不一样，所以它还是添加成功了，那么其实你写的equals()方法根本没啥软用。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>1、People类</strong></p>
<p>重写equals方法,但并没有hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        People u = (People) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;People&gt; hashSet = Sets.newHashSet();</span><br><span class="line">    People people1 = <span class="keyword">new</span> People(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    People people2 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people3 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people4 = <span class="keyword">new</span> People(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    hashSet.add(people1);</span><br><span class="line">    hashSet.add(people2);</span><br><span class="line">    hashSet.add(people3);</span><br><span class="line">    hashSet.add(people4);</span><br><span class="line"></span><br><span class="line">    System.out.println(hashSet);</span><br><span class="line">    <span class="comment">//输出:[People&#123;name='小小', age=3&#125;, People&#123;name='中中', age=4&#125;, People&#123;name='大大', age=5&#125;, People&#123;name='中中', age=4&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显,我重写了equals方法,那么people2和people3的equals应该相同，所以不能放入HashSet,但它们的hashCode()方法返回不同，所以导致同样能放入HashSet。</p>
<p><code>重点</code>：对于Set集合必须要同时重写这两个方法，要不然Set的特性就被破坏了。</p>
<p>转载自：<a href="https://www.cnblogs.com/qdhxhz/p/10787130.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/10787130.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/2021/java/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p>
<p>什么是泛型？为什么要使用泛型？</p>
<blockquote>
<p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<h1 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h1><p>一个被举了无数次的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，程序的运行结果会以崩溃结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String1</span><br></pre></td></tr></table></figure>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错123</span></span><br></pre></td></tr></table></figure>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>泛型只在编译阶段有效。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<code>D/泛型测试: 类型相同</code>。</p>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个最普通的泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericString.getKey());<span class="number">12345678</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is <span class="number">123456</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is key_vlaue12</span><br></pre></td></tr></table></figure>
<p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<p>看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());</span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is false1234</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li><ol>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
</ol>
</li>
<li><ol>
<li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&gt;      &#125; <span class="number">12</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p>
<blockquote>
<p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p>
</blockquote>
<p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h3><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h3><p>再看一个泛型方法和可变参数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p>
<p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p>
<blockquote>
<p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法</p>
</blockquote>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？无界通配符</h3><p>先从一个小例子看起，我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>但是老板的想法确实这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="comment">// 不会报错</span></span><br><span class="line">    countLegs( dogs );</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 countLegs1 时，就会报错。所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 <code>&lt;?&gt;</code>），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上界：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2)&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    //.....</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</span><br><span class="line">    for (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">    new Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line">// Dog 是 Animal 的子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//指定集合元素只能是T类型</span><br><span class="line">List&lt;T&gt; list =new ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">//集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</span><br><span class="line">List&lt;?&gt; list =new ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line">// 不可以</span><br><span class="line">?car = operate();</span><br></pre></td></tr></table></figure>
<p>简单总结下：</p>
<blockquote>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
</blockquote>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过 T 来 确保 泛型参数的一致性</span><br><span class="line">public &lt;T extends Number&gt; void</span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure>
<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure>
<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiLimit</span> <span class="keyword">implements</span> <span class="title">MultiLimitInterfaceA</span>,<span class="title">MultiLimitInterfaceB</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 使用 &amp; 符号设定多重边界</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends MultiLimitInterfaceA &amp; MultiLimitInterfaceB&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MultiLimitInterfaceA</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MulitLimitInterfaceB</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>
<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>
<h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt; T &gt; 和 Class&lt; ? &gt; 区别"></a>Class&lt; T &gt; 和 Class&lt; ? &gt; 区别</h2><p>前面介绍了 ？和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？</p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射的方式生成  multiLimit </span><br><span class="line">// 对象，这里比较明显的是，我们需要使用强制类型转换</span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Ttest3&#123;</span><br><span class="line">	public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws Exception&#123;</span><br><span class="line">		return clazz.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		A a = createInstance(A.class);</span><br><span class="line">		B b = createInstance(B.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line">class B&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">public Class&lt;?&gt; clazz;</span><br><span class="line">// 不可以，因为 T 需要指定类型</span><br><span class="line">public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个<code>Class&lt;?&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3&lt;T&gt; &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    // 不会报错</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程</title>
    <url>/2021/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%9B%E5%BB%BAThread%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ThreadDemo threadDemo=<span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line">        threadDemo.start();<span class="comment">//调用Thread类的start方法启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ThreadDemo ThreadDemo=<span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="comment">//调用Thread的构造方法public Thread(Runnable target)创建Thread类，将Runable实现类传入，</span></span><br><span class="line">        <span class="comment">//然后调用Thread类的start方法启动线程，Runable的实现类是没有start方法的。</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ThreadDemo).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ThreadDemo threadDemo=<span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1=ser.submit(threadDemo);</span><br><span class="line">        <span class="comment">//获取结构</span></span><br><span class="line">        <span class="keyword">boolean</span> rs1=r1.get();</span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程测试"><a href="#多线程测试" class="headerlink" title="多线程测试"></a>多线程测试</h3><p>新建100个线程进行进行模拟多用户操作，获取单号。</p>
<h4 id="使用lambda创建线程测试"><a href="#使用lambda创建线程测试" class="headerlink" title="使用lambda创建线程测试"></a>使用lambda创建线程测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">HdGetBillNo hdGetBillNo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBillNoService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String billNo=	hdGetBillNo.nextUserBillNo(<span class="string">"MATIN"</span>,<span class="string">"00"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">" "</span>+HdDateUtils.dateToStr(<span class="keyword">new</span> Date(),<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) +<span class="string">"线程获取单号为"</span>+billNo);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用线程类创建线程测试"><a href="#使用线程类创建线程测试" class="headerlink" title="使用线程类创建线程测试"></a>使用线程类创建线程测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">HdGetBillNo hdGetBillNo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String billNo=	hdGetBillNo.nextUserBillNo(<span class="string">"MATIN"</span>,<span class="string">"00"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+ <span class="string">" "</span>+HdDateUtils.dateToStr(<span class="keyword">new</span> Date(),<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) +<span class="string">"线程获取单号为"</span>+billNo);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBillNoService</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程线程</title>
    <url>/2021/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><p>java能真正开启一个线程吗？不能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用本地方法，底层为C++，操作硬件开启一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h3><p>并发：多个线程操作一个资源，CPU一个核心，模拟多核心。</p>
<p>并行：多个线程同时执行，CPU多核心。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取计算机CPU核心数</span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure></p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//新生</span><br><span class="line">NEW,</span><br><span class="line"></span><br><span class="line">//运行</span><br><span class="line">RUNNABLE,</span><br><span class="line"></span><br><span class="line">//阻塞</span><br><span class="line">BLOCKED,</span><br><span class="line"></span><br><span class="line">//等待，死死的等</span><br><span class="line">WAITING,</span><br><span class="line"></span><br><span class="line">//超时等待</span><br><span class="line">TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">//终止</span><br><span class="line">TERMINATED;</span><br></pre></td></tr></table></figure>
<h3 id="wait-sleep"><a href="#wait-sleep" class="headerlink" title="wait/sleep"></a>wait/sleep</h3><p><strong>1.来自不同的类</strong></p>
<p>wait =&gt; Object   </p>
<p>sleep =&gt; Thread</p>
<p><strong>2.关于所得释放</strong></p>
<p>wait会释放锁</p>
<p>sleep睡觉，不会释放锁</p>
<p><strong>3.使用范围是不同的</strong></p>
<p>wait必须在同步代码块中</p>
<p>sleep可以在任何地方</p>
<p><strong>4.是否需要捕获异常</strong></p>
<p>wait不需要捕获异常</p>
<p>sleep必须捕获异常</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2020/java/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="对称性加密算法"><a href="#对称性加密算法" class="headerlink" title="对称性加密算法"></a>对称性加密算法</h2><p><img src="/2020/java/加密算法/1.jpg" alt="加密流程图"></p>
<p>对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。</p>
<p>对称加密算法的优点是：算法公开、计算量小、加密速度快、加密效率高。用途：对称加密算法用来对敏感数据等信息进行加密</p>
<p>对称加密算法的缺点是：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p><strong>DES</strong>：全称为Data Encryption Standard数据加密标准，速度较快，适用于加密大量数据的场合。</p>
<p><strong>3DES</strong>（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>
<p><strong>AES</strong>：全称为Advanced Encryption Standard高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES 适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。</p>
<h2 id="非对称性算法"><a href="#非对称性算法" class="headerlink" title="非对称性算法"></a>非对称性算法</h2><p><img src="/2020/java/加密算法/2.jpg" alt="img"></p>
<p><strong>既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</strong></p>
<p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密与有点是：安全性更好；对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p>
<p>非对称加密的缺点是：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p><strong>RSA</strong>：全称为Digital Signature Algorithm，是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p>
<p><strong>DSA</strong>：全称为Digital Encryption Standard，是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到。</p>
<p><strong>ECC</strong>：全称为Elliptic Curves Cryptography,，也叫椭圆加密算法，是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p>
<blockquote>
<p>ECC和RSA相比，在许多方面都有对绝对的优势，主要体现在以下方面：</p>
<ol>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。</li>
<li>计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。</li>
<li>存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。</li>
</ol>
</blockquote>
<h2 id="散列算法（签名算法）"><a href="#散列算法（签名算法）" class="headerlink" title="散列算法（签名算法）"></a>散列算法（签名算法）</h2><p><img src="/2020/java/加密算法/sl.png" alt="img"></p>
<p>散列算法，又称哈希函数，是一种单向加密算法。在信息安全技术中，经常需要验证消息的完整性，散列(Hash)函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的”散列”或”消息摘要”(Message digest)。散列算法不算加密算法，因为其结果是不可逆的，既然是不可逆的，那么当然不是用来加密的，而是签名。</p>
<p>用途：主要用于验证，防止信息被修。具体用途如：文件校验、数字签名、鉴权协议</p>
<p><strong>MD5</strong>：MD5是一种不可逆的加密算法，目前是最牢靠的加密算法之一，尚没有能够逆运算的程序被开发出来，它对应任何字符串都可以加密成一段唯一的固定长度的代码。</p>
<p><strong>SHA1</strong>：全称为Secure Hash Algorithm，即安全哈希算法，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。有SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法，其中SHA-1已经不安全。而SHA-1基于MD5，MD5又基于MD4。</p>
<p><strong>HMAC</strong>：全称为Hash Message Authentication Code，即散列消息鉴别码，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。一般的，消息鉴别码用于验证传输于两个共 同享有一个密钥的单位之间的消息。HMAC 可以与任何迭代散列函数捆绑使用。MD5 和 SHA-1 就是这种散列函数。HMAC 还可以使用一个用于计算和确认消息鉴别值的密钥。</p>
<p><strong>建议：</strong> AES采用128为即可，RSA建议采用1024位的数字，ECC建议采用160位。RSA加密字符长度有限制，一般采用AES+RSA方式组合使用。</p>
<h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>Base64 加密算法是最常见的用于传递 8bit <strong>字节码的编码方式之一</strong></p>
<p>计算机任何数据都是按 ascii 码存储的，而 ascii 码的 128～256 之间的值是不可见字符，由于不同设备对字符处理方式有不同，可能会导致错误，不利于传输，所以把数据作为一个 Base64 编码，统统变成可见字符，出错可能性就降低了</p>
<p>Base64 是取 6 个比特为一组，计算它的 ascii 值，得到一个可见字符，在解码时按 6 个比特进行解码并读取，如 01010101101 等比特流，取 010110 计算它的 ascii 码，转化为可见字符，因此 Base64 <strong>还具备了数据压缩能力</strong></p>
<p>其实不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种可逆的编码方式。编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(26 + 26 + 10 + 1 + 1 = 64，其实是65个字符，“=”是填充字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节(3<em>8 = 4</em>6 = 24)，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。原文的字节最后不够3个的地方用0来补足，转换时Base64编码用=号来代替。这就是为什么有些Base64编码会以一个或两个等号结束的原因，中间是不可能出现等号的，但等号最多只有两个。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。)<br>Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”， 对应GB2312格式的Base64编码是”yc/N+A==”。<br>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。<br>为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“<em>”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。<br>另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。<br>此外还有一些变种，它们将“+/”改为“</em>-”或“.<em>”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“</em>:”（用于XML中的Name）。</p>
<h2 id="AES-RSA组合应用"><a href="#AES-RSA组合应用" class="headerlink" title="AES+RSA组合应用"></a>AES+RSA组合应用</h2><p>RSA与AES加密算法所产生的密钥数不一样，它们是如何进行加密的呢？</p>
<p>接收方生成RSA密钥对，将其中的RSA公钥传递给发送方(接收方与发送方建立连接是需要认证的，SSL/TLS协议可以确保RSA公钥的安全完整)，然后用RSA公钥对AES密钥进行加密，加密后的结果传递给接收方，接收方用RSA私钥解密后，得到AES密钥，最后使用AES密钥解密，从而达到安全互通数据的目的。(如下图所示)</p>
<p><img src="/2020/java/加密算法/3.png" alt="3"></p>
<p><img src="/2020/java/加密算法/4.jpg" alt="img"></p>
<h2 id="项目应用总结"><a href="#项目应用总结" class="headerlink" title="项目应用总结"></a>项目应用总结</h2><ol>
<li>加密算法是可逆的，用来对敏感数据进行保护。散列算法(签名算法、哈希算法)是不可逆的，主要用于身份验证。</li>
<li>对称加密算法使用同一个密匙加密和解密，速度快，适合给大量数据加密。对称加密客户端和服务端使用同一个密匙，存在被抓包破解的风险。</li>
<li>非对称加密算法使用公钥加密，私钥解密，私钥签名，公钥验签。安全性比对称加密高，但速度较慢。非对称加密使用两个密匙，服务端和客户端密匙不一样，私钥放在服务端，黑客一般是拿不到的，安全性高。</li>
<li>Base64不是安全领域下的加解密算法，只是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，特别适合在http，mime协议下的网络快速传输数据。UTF-8和GBK中文的Base64编码结果是不同的。采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到，但这种方式很初级，很简单。Base64可以对图片文件进行编码传输。</li>
<li>大量数据加密建议采用对称加密算法，提高加解密速度；小量的机密数据，可以采用非对称加密算法。在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</li>
<li>MD5标准密钥长度128位（128位是指二进制位。二进制太长，所以一般都改写成16进制，每一位16进制数可以代替4位二进制数，所以128位二进制数写成16进制就变成了128/4=32位。16位加密就是从32位MD5散列中把中间16位提取出来）；sha1标准密钥长度160位(比MD5摘要长32位)，Base64转换后的字符串理论上将要比原来的长1/3。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES 加密方法，是对称的密码算法(加密与解密的密钥一致)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得一个 密钥长度为 128 位的 AES 密钥，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回经 BASE64 处理之后的密钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStrKeyAES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是 128、192、256、越大越安全</span></span><br><span class="line">        keyGen.init(<span class="number">128</span>, secureRandom);</span><br><span class="line">        SecretKey secretKey = keyGen.generateKey();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(secretKey.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将使用 Base64 加密后的字符串类型的 secretKey 转为 SecretKey</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">strKey2SecretKey</span><span class="params">(String strKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteArr = base64_str2ByteArr(strKey);</span><br><span class="line">        SecretKeySpec secretKey = <span class="keyword">new</span> SecretKeySpec(byteArr, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 加密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的密文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 加密 返回Base64编码的字符串密文</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 解密 传入Base64编码的字符串密文，返回解密后的字符串</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] messageByteArr = AESUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(messageByteArr, aesKey);</span><br><span class="line">        String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> descyptAes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待解密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 解密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的明文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA 是非对称的密码算法，密钥分公钥和私钥，公钥用来加密，私钥用于解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">RSAUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对：密钥对中包含公钥和私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含 RSA 公钥与私钥的 keyPair</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是1024、2048 初始化一个密钥对</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">2048</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥 (并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的公钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥(并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的私钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成 PublicKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PublicKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(pubStr);</span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey publicKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成 PrivateKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PrivateKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(priStr);</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);</span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 加密所需的公钥对象 PublicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrypt(<span class="keyword">byte</span>[] content, PublicKey publicKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密并返回Base64编码的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String publicKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">        <span class="keyword">return</span> encryptMsgBase64Str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content    待解密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 解密需要的私钥对象 PrivateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] privateDecrypt(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密,返回字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String privateKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptMsgByteArr = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//用私钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgByteArr, privateKey);</span><br><span class="line">        String decryptmsgStr = <span class="keyword">new</span> String(decryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> decryptmsgStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key = AESUtil.getStrKeyAES();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String sourceFilePath = <span class="string">"E:\\打印\\JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D:\\1583915786661_html_2f4d5dc.png";</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// String destFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        FileEncryptUtil.encryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sourceFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">      <span class="comment">//  String destFilePath = "E://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"E://test//JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String destFilePath="E:\\11.png";</span></span><br><span class="line">        FileEncryptUtil.decryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            System.out.println(<span class="string">"明文数据为："</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">            String aesKeyBase64Str = AESUtil.getStrKeyAES();</span><br><span class="line">            System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptAESBase64Str = AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">            System.out.println(<span class="string">"加密并Base64编码的结果："</span> + encryptAESBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############   网络上传输的内容有Base64编码后的秘钥 和 Base64编码加密后的内容    #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKeyFromNet = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArrFromNet = AESUtil.base64_str2ByteArr(encryptAESBase64Str);</span><br><span class="line">            <span class="comment">//解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(encryptAESByteArrFromNet, aesKeyFromNet);</span><br><span class="line">            String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + descyptAes);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(descyptAes)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=AESUtil.encrypt(message,aesKeyBase64Str);</span><br><span class="line">            System.out.println(miwen);</span><br><span class="line">            String minwen=AESUtil.decrypt(miwen,aesKeyBase64Str);</span><br><span class="line">            System.out.println(minwen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            encryptFile();</span><br><span class="line">            decryptFile();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.err.println(<span class="string">"耗时："</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">            <span class="comment">//生成RSA公钥和私钥，并Base64编码</span></span><br><span class="line">            KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">            String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">            String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">            System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">            PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">            <span class="comment">//用公钥加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">            System.out.println(<span class="string">"公钥加密并Base64编码的结果："</span> + encryptMsgBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############    网络上传输的内容有Base64编码后的公钥 和 Base64编码后的公钥加密的内容     #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">            PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptMsgFromNet = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">            <span class="comment">//用私钥解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] privateDecryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgFromNet, privateKey);</span><br><span class="line">            String privateDecrypmsgtStr = <span class="keyword">new</span> String(privateDecryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + privateDecrypmsgtStr);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(privateDecrypmsgtStr)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=RSAUtil.encrypt(message,publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"密文: "</span> + miwen);</span><br><span class="line">            String mingwen=RSAUtil.decrypt(miwen,privateKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"明文: "</span> + mingwen);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESAndRSATest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试RSA与AES的结合。</span></span><br><span class="line">    <span class="comment">//客户端：AES秘钥加密明文得到密文，然后用从服务器获取的RSA公钥加密AES秘钥，网络传输密文和RSA加密后的AES秘钥到服务器</span></span><br><span class="line">    <span class="comment">//服务端：用RSA私钥解密AES秘钥，解密后的AES秘钥再用来解密密文，得到明文。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKey = RSAUtil.publicEncrypt(aesKeyStr.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容Base64编码</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.base64_byteArr2Str(publicEncryptAESKey);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyStr);</span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.base64_byteArr2Str(encryptAES);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############   网络上传输的内容有Base64编码后的公钥加密AES秘钥的结果 和 Base64编码后的AES秘钥加密实际内容的结果   #################</span></span><br><span class="line">        <span class="comment">//##############   即publicEncryptAESKeyStr和encryptAESStr  ###################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKeyFromNet = RSAUtil.base64_str2ByteArr(publicEncryptAESKeyStr);</span><br><span class="line">        <span class="comment">//用私钥解密,得到aesKey</span></span><br><span class="line">        <span class="keyword">byte</span>[] aesKeyStrBytes = RSAUtil.privateDecrypt(publicEncryptAESKeyFromNet, privateKey);</span><br><span class="line">        <span class="comment">//解密后的aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = <span class="keyword">new</span> String(aesKeyStrBytes,<span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey2 = AESUtil.strKey2SecretKey(aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES2 = AESUtil.base64_str2ByteArr(encryptAESStr);</span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAES = AESUtil.decryptAES(encryptAES2, aesKey2);</span><br><span class="line">        String decryptAESStr=<span class="keyword">new</span> String(decryptAES,<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装方法测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.encrypt(aesKeyStr,publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.encrypt(message, aesKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//用RSA私钥解密,得到aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = RSAUtil.decrypt(publicEncryptAESKeyStr, privateKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        String decryptAESStr = AESUtil.decrypt(encryptAESStr, aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"AES解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//test();</span></span><br><span class="line">            testSimple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>DNF-包管理器</title>
    <url>/2020/Linux/%E9%9B%86%E9%94%A6/DNF-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DNF(Dandified Yum)是新一代的RPM软件包管理器。<br>DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。</p>
<h3 id="安装DNF"><a href="#安装DNF" class="headerlink" title="安装DNF"></a>安装DNF</h3><p>DNF并未默认安装在RHEL或CentOS7系统中，但可以在使用YUM的同时使用DNF。</p>
<ol>
<li>安装epel-release依赖：<code>yum install epel-release</code> 或者 <code>yum install epel-release -y</code></li>
<li>安装DNF包：<code>yum install dnf</code> 或者 <code>yum install dnf -y</code></li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/dnf/dnf.conf</p>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>Add the following settings in [main] section of /etc/dnf/dnf.conf, and save the file.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy=http://&lt;ip address&gt;:&lt;port&gt;</span><br><span class="line">proxy_username=&lt;username&gt;</span><br><span class="line">proxy_password=&lt;password&gt;</span><br></pre></td></tr></table></figure>
<h3 id="DNF命令"><a href="#DNF命令" class="headerlink" title="DNF命令"></a>DNF命令</h3><p>与YUM基本保持一致，少数用法有区别。<br><a href="http://man.linuxde.net/dnf" target="_blank" rel="noopener">常用dnf命令</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##### 版本</span></span><br><span class="line">dnf –version  <span class="comment"># 查看DNF包管理器版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 帮助</span></span><br><span class="line">dnf <span class="built_in">help</span>  <span class="comment"># 查看所有的DNF命令及其用途</span></span><br><span class="line">dnf <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;  <span class="comment"># 获取命令的使用帮助</span></span><br><span class="line">dnf <span class="built_in">history</span>  <span class="comment"># 查看 DNF 命令的执行历史</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 信息查看</span></span><br><span class="line">dnf repolist  <span class="comment"># 查看系统中可用的DNF软件库</span></span><br><span class="line">dnf search &lt;package&gt;  <span class="comment"># 搜索软件库中的RPM包</span></span><br><span class="line"></span><br><span class="line">dnf list installed  <span class="comment"># 列出所有安装的RPM包</span></span><br><span class="line">dnf list available  <span class="comment"># 列出所有可安装的RPM包</span></span><br><span class="line">dnf info &lt;package&gt;  <span class="comment"># 查看软件包详情</span></span><br><span class="line"></span><br><span class="line">dnf provides &lt;file&gt;  <span class="comment"># 查找某一文件的提供者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 软件包操作</span></span><br><span class="line">dnf install &lt;package&gt;  <span class="comment"># 安装软件包及其所需的所有依赖</span></span><br><span class="line">dnf update &lt;package&gt;  <span class="comment"># 升级软件包</span></span><br><span class="line">dnf remove &lt;package&gt;  <span class="comment"># 删除软件包</span></span><br><span class="line">dnf reinstall &lt;package&gt;  <span class="comment"># 重新安装特定软件包</span></span><br><span class="line">dnf distro-sync  <span class="comment"># 更新软件包到最新的稳定发行版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 系统软件包</span></span><br><span class="line">dnf check-update  <span class="comment"># 检查系统所有软件包的更新</span></span><br><span class="line">dnf update  <span class="comment"># 升级所有系统软件包</span></span><br><span class="line">dnf clean all  <span class="comment"># 删除缓存的无用软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 组</span></span><br><span class="line">dnf grouplist</span><br><span class="line">dnf groupinstall <span class="string">'xxx'</span></span><br><span class="line">dnf groupupdate <span class="string">'xxx'</span></span><br><span class="line">dnf groupremove</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>集锦</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>DNF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>chsh修改登录shell为zsh</title>
    <url>/2016/Linux/%E9%9B%86%E9%94%A6/chsh%E4%BF%AE%E6%94%B9%E7%99%BB%E5%BD%95shell%E4%B8%BAzsh/</url>
    <content><![CDATA[<p><strong>1 我想知道我机器安装了哪些shell？</strong></p>
<p>两种方法可以查看：</p>
<p>第一种：</p>
<p>[rocrocket@wupengchong ~]$ chsh -l<br>/bin/sh<br>/bin/bash<br>/sbin/nologin<br>/bin/zsh</p>
<p>第二种：</p>
<p>[rocrocket@wupengchong ~]$ cat /etc/shells<br>/bin/sh<br>/bin/bash<br>/sbin/nologin<br>/bin/zsh</p>
<p>其实chsh -l也是来查看这个文件。</p>
<p>2 我想知道我当前正在使用的shell是哪个阿？</p>
<p>[rocrocket@wupengchong ~]$ echo $SHELL<br>/bin/bash</p>
<p>注意SHELL一定要是大写。可以看到，我目前使用的shell是/bin/bash</p>
<p><strong>3 执行了zsh之后，我查看当前shell类型仍然是/bin/bash呢？</strong></p>
<p>请注意，我们虽然执行了zsh，但是所谓“当前的shell”是一个大环境的概念，是针对一个已登录的用户而言的。而我们执行zsh只是启动了一个zsh的解释器程序而已，并没有改变大环境。如果想改变“当前的shell”，那么还是要使用chsh才可以。</p>
<p><strong>4 我想把我的shell改成zsh！</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[rocrocket@wupengchong ~]$ chsh -s /bin/zsh</span><br><span class="line">Changing shell for rocrocket.</span><br><span class="line">Password:</span><br><span class="line">Shell changed.</span><br><span class="line">[rocrocket@wupengchong ~]$</span><br></pre></td></tr></table></figure></p>
<p>使用chsh加选项-s就可以修改登录的shell了！</p>
<p>你会发现你现在执行echo $SHELL后仍然输出为/bin/bash，这是因为你需要重启你的shell才完全投入到zsh怀抱中去。</p>
<p><strong>5 chsh -s到底是修改了哪里？</strong></p>
<p>秘密告诉你吧。chsh -s其实修改的就是/etc/passwd文件里和你的用户名相对应的那一行。现在我来查看下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[rocrocket@wupengchong ~]$ cat /etc/passwd|grep ^rocrocket</span><br><span class="line">rocrocket:x:500:500:rocrocket,China:/rocrocket/PSB/home:/bin/zsh</span><br></pre></td></tr></table></figure></p>
<p>看！你可以发现输出内容的最后部分已经变成了/bin/zsh了！下次你重启的时候，linux就会读取这一命令来启动你的shell了！</p>
<p>好了，我要恢复正常工作，把shell修改会我熟悉的/bin/bash了！</p>
<p>[rocrocket@wupengchong ~]$ chsh -s /bin/bash<br>Changing shell for rocrocket.<br>Password:<br>Shell changed.</p>
<p>over~</p>
<p>来源： <a href="http://roclinux.cn/?p=739" target="_blank" rel="noopener">http://roclinux.cn/?p=739</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>集锦</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议介绍</title>
    <url>/2021/Linux/%E9%9B%86%E9%94%A6/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>网上看到一篇对开原协议讲述的比较通俗易懂的文章，感谢原作者。</p>
<p>世界上的开源许可证（Open Source License）大概有上百种，今天我们来介绍下几种我们常见的开源协议。大致有GPL、BSD、MIT、Mozilla、Apache和LGPL等。</p>
<p><img src="/2021/Linux/集锦/开源协议介绍/0.604344791375343.png" alt="img"></p>
<h3 id="Apache-License"><a href="#Apache-License" class="headerlink" title="Apache License"></a>Apache License</h3><p>Apache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。</p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：</p>
<ul>
<li>需要给代码的用户一份Apache Licence。</li>
<li>如果修改了代码，需要再被修改的文件中说明。</li>
<li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li>
<li>Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</li>
</ul>
<p>使用这个协议的好处是:</p>
<ul>
<li>永久权利 一旦被授权，永久拥有。</li>
<li>全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li>
<li>授权免费 无版税， 前期、后期均无任何费用。</li>
<li>授权无排他性 任何人都可以获得授权</li>
<li>授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码</li>
</ul>
<h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>BSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。</p>
<p>BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL （GNU General Public License） ：GNU通用公共许可协议。</p>
<p><strong>Linux 采用了 GPL</strong>。</p>
<p>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p>
<h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p>
<h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<p>MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<h3 id="MPL-Mozilla-Public-License-1-1"><a href="#MPL-Mozilla-Public-License-1-1" class="headerlink" title="MPL (Mozilla Public License 1.1)"></a>MPL (Mozilla Public License 1.1)</h3><p>MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p>
<h3 id="EPL-Eclipse-Public-License-1-0"><a href="#EPL-Eclipse-Public-License-1-0" class="headerlink" title="EPL (Eclipse Public License 1.0)"></a>EPL (Eclipse Public License 1.0)</h3><p>EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。</p>
<p>使用EPL协议，需要遵守以下规则：</p>
<ul>
<li>当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；</li>
<li>EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；</li>
<li>当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；</li>
<li>4.独立的模块(Separate Module),不需要开源。</li>
</ul>
<h3 id="Creative-Commons-知识共享协议"><a href="#Creative-Commons-知识共享协议" class="headerlink" title="Creative Commons 知识共享协议"></a>Creative Commons 知识共享协议</h3><p>Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介：</p>
<ul>
<li>署名 作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</li>
<li>相同方式共享 作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。</li>
<li>非商业用途 作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。</li>
<li>禁止衍生作品</li>
</ul>
<p>CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。</p>
<p>CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。</p>
<hr>
<h3 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h3><p><img src="/2021/Linux/集锦/开源协议介绍/0.806442015465004.png" alt="img"></p>
<p><img src="/2021/Linux/集锦/开源协议介绍/0.7893948360872438.png" alt="img"></p>
<p><img src="/2021/Linux/集锦/开源协议介绍/0.03694453917716278.png" alt="img"></p>
<p>来源： <a href="https://www.jianshu.com/p/36c1cd4aaeae" target="_blank" rel="noopener">https://www.jianshu.com/p/36c1cd4aaeae</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>集锦</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux打印</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/Linux%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<p>打印包括：</p>
<p>  打印作业</p>
<p>  打印队列</p>
<p>  打印服务  常见打印服务有CUPS和LPRng，现在CUPS（Common UNIX Printing System）是主流，常见的打印机能识别的格式为Postscript 及 Ghostscript。</p>
<p>CUPS 支持的常见的打印机联机分享方式：</p>
<p>  socket</p>
<blockquote>
<p>数据透过 internet socket(端口口)来传送，一般为 port 9100 或 35。如果想要进行数据的传输</p>
<p>与打印，可以透过在浏觅器上面输入： socket://host-printer:9100/ 来进行。不过，这种模式不常用就是了。</p>
</blockquote>
<p>  LPD (Line Pritner Daemon)</p>
<blockquote>
<p>LPD 是较早之前的打印服务，LPRng 就是使用这种方式的联机啦！ LPD 主要是</p>
<p>利用串行端口来达成打印的需求，打印机名称就是 LPT1/LPT2… 等等。 目前还是可以在比较早期的 Linux distributions 看到这种打印方式。</p>
</blockquote>
<p>  IPP (Internet Printing Protocol)</p>
<blockquote>
<p>这是目前比较流行的打印机打印协议， CUPS预设也是支持这种协议啊！当启动 IPP </p>
<p>时，打印机会启动 port 631 ，打印的数据就是透过这个 port 来进行传送的。另外，如果你的</p>
<p>打印机或者 Linux 主机启动了 ipp 之后， 嘿嘿！你可以直接使用浏觅器，输入：</p>
<p>ipp://printer_IP/printername，或者是： http:/printer_IP:631 就能够直接在线处理打印机的设定。</p>
</blockquote>
<p>  SMB (Server Message Block)</p>
<p>​      这家伙就是网络上的芳邻啦！协议使用的是： smb://user:password@host/printer 。</p>
<p> /etc/cups/printers.conf：打印机的设定值，都写在这个档案中；（设定打印机地址等信息） /etc/cups/cupsd.conf：CUPS 的主要配置文件，包括做为服务器之用途的设定。 /etc/cups/ppd/*.ppd：就是各个打印机的驱动程序 (PPD 配置文件)；</p>
<p>>/etc/init.d/cups restart  –启动CUPS服务</p>
<p>>netstat -tlunp | grep 631  –查询是否启动CUPS服务</p>
<h3 id="lpadmin-打印机建立与删除"><a href="#lpadmin-打印机建立与删除" class="headerlink" title="lpadmin 打印机建立与删除"></a><strong>lpadmin 打印机建立与删除</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/853a8341-07ab-4cfe-ac67-b78666530f05.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/1f2d6143-fe7b-439f-b13f-ebc223048d1f.png" alt="img"></p>
<h3 id="lpstatus-查看打印机状态"><a href="#lpstatus-查看打印机状态" class="headerlink" title="lpstatus 查看打印机状态"></a><strong>lpstatus 查看打印机状态</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/12408597-c8d8-4b31-8ac7-b9dc7716465b.png" alt="img"></p>
<h3 id="lp和lpr打印"><a href="#lp和lpr打印" class="headerlink" title="lp和lpr打印"></a><strong>lp和lpr打印</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/b16e1f60-eee6-4671-a225-9bf36857e995.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/1c3ae070-8125-4859-bc66-b59bf829444d.png" alt="img"></p>
<h3 id="打印作业的观察-lpq"><a href="#打印作业的观察-lpq" class="headerlink" title="打印作业的观察 (lpq)"></a><strong>打印作业的观察 (lpq)</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/35ac25c0-0f5f-4d6f-a030-46aa2eefaecd.png" alt="img"></p>
<h3 id="打印作业的删除-lprm"><a href="#打印作业的删除-lprm" class="headerlink" title="打印作业的删除 (lprm)"></a><strong>打印作业的删除 (lprm)</strong></h3><p><img src="/2015/Linux/鸟哥的Linux私房菜/Linux打印/2dee6621-92a0-4aba-93c0-769df5ebf984.png" alt="img"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Tarball安装（源代码安装）<br>1.解压到 /usr/local/src<br>2.到软件目录下执行 ./configure 检测平台环境变量，生成Makefile<br>3.执行make命令，编译成目标文件并连接库函数，生成二进制文件 其实是替代了gcc的一步步编译，make自动去找Makefile文件，Makefile文件中写了很多gcc编译的配置。当前目录下生成objs文件夹<br>4.执行make install 将编译后的文件放到安装目录下</p>
<table>
<thead>
<tr>
<th>distribution 代表</th>
<th>软件管理机制</th>
<th>使用命令</th>
<th>在线升级机制(命令)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Red Hat/Fedora</td>
<td>RPM</td>
<td>rpm, rpmbuild</td>
<td>YUM (yum)</td>
</tr>
<tr>
<td>Debian/Ubuntu</td>
<td>DPKG</td>
<td>dpkg</td>
<td>APT (apt-get)</td>
</tr>
</tbody>
</table>
<p>虽然RPM与DPKG有效的解决的软体的安装，移除与查询的需求，但是在Linux上的套件管理还有一个很大的问题必须解决，就是各软体间的相依性(dependency)。 <strong>RPM与DPKG只能做到检查相依性，在安装或移除时告知相依性的不满足，皆下来就需要使用者自行去找出所需的套件来安装。 这样的确是有点不方便，因此产生了前端工具软体- APT及YUM。</strong></p>
<p>安装/更新</p>
<p> -h用#(hash)符显示rpm安装过程  -v详述安装过程<br>rpm -ivh fds.rpm –force –prefix /usr/local<br>rpm -Uvh fds.rpm  后面接的软件，如果原本未安装，则直接安装，原本已安装时，则直接升级；<br>rpm -Fvh fds.rpm  后面接的软件，如果原本未安装，则不安装，原本已安装时，则直接升级；</p>
<p>查询<br>rpm -qa<br>rpm -qlicdR 已安装package<br>rpm -qf 文件名  –查询文件属于哪个软件<br>rpm -qplicdR 未安装package</p>
<p>rpm -qa|grep ^a|wc -l 以a开头的软件个数</p>
<p>验证<br>rpm -Va<br>rpm -V 已安装软件<br>rpm -Vf 文件名</p>
<p>卸载<br>rpm -ev 已安装软件</p>
<p>重建数据库<br>rpm –rebuilddb</p>
<p>SRPM(source RPM)方式<br>rpmbuild –rebuild  aaa.src.rpm 编译打包<br>rpmbuild –recompile aaa.src.rpm 编译打包安装<br>rpmbuild -ba aaa.spec 编译并同时产生RPM与SRPM档案<br>rpmbuild -bb aaa.spec 仅编译成RPM档案</p>
<p>yum线上安装<br>yum search raid<br>yum list pam*  =rpm -qa<br>yum list updates 查询可升级软件<br>yum info raid  =rpm -qi<br>yum provides passwd  =rpm -qf</p>
<p>yum -y install pam-devel –installroot=/path<br>yum update pam 整个系统都升级不加软件名<br>yum remove pam-devel</p>
<p><strong>更改repository地址</strong><br><img src="/2014/Linux/鸟哥的Linux私房菜/Linux软件安装/11394328.png" alt="img"></p>
<p><strong>新建repository地址</strong></p>
<p>>vim /etc/yum.repos.d/drbl.repo</p>
<p> [drbl]</p>
<p> name = this is DRBL site</p>
<p> baseurl=<a href="http://free.nchc.org.tw/drbl-core/i386/RPMS.drbl-stable/" target="_blank" rel="noopener">http://free.nchc.org.tw/drbl-core/i386/RPMS.drbl-stable/</a></p>
<p> enable =1</p>
<p> gpgcheck=0</p>
<p>>yum search drbl</p>
<p>>yum repolist all</p>
<p>yum clean [packages|headers|all] 清除原来的软件列表<br>yum [grouplist|groupinfo|groupinstall|groupremove] 群组软件名</p>
<p>  yum grouplist 显示所有可以安装的群组</p>
<p>  yum grouplist | grep Development</p>
<p>  yum groupinfo “Development tools”</p>
<p>  <strong>yum -y groupinstall “Development tools” 如果报错，先执行 yum clean all</strong></p>
<p>yum -y update  系统升级</p>
<p>安装</p>
<p>dpkg -i pkgfile.deb</p>
<p>在Debian使用alien处理RPM套件</p>
<blockquote>
<p>alien 可处理.deb、.rpm、.slp、.tgz 等档案格式, 进行转档或安装.<br>于Debian安装非Debian套件时,可使用<strong>alien</strong>进行安装.<br>安装alien套件: apt-get install alien</p>
</blockquote>
<ul>
<li>在Debian安装RPM套件: alien -i quota-3.12-7.i386.rpm</li>
<li>制作成deb的套件格式: alien -d quota-3.12-7.i386.rpm</li>
<li>制作成rpm的套件格式: alien -r quota_3.12-6_i386.deb</li>
</ul>
<p>查询</p>
<p>dpkg -l(小写L)        显示所有安装套件</p>
<p>dpkg -l softwarename (小写L,只列出简洁资讯) </p>
<p>dpkg -s softwarename (显示详细资讯)<br>dpkg -p softwarename (显示详细资讯</p>
<p>dpkg -L softwarename  显示套件包含的所有档案</p>
<p>dpkg -S /path/to/file    显示特定档案所属套件名称</p>
<p>dpkg -I pkgfile.deb (大写i) 查询安装软件包资讯</p>
<p>dpkg -c pkgfile.deb   查询安装软件包资讯</p>
<p>卸载</p>
<p>dpkg -r softwarename (会留下套件设定档)<br>dpkg -P softwarename (完全移除)</p>
<p>apt-get线上安装  </p>
<p>  aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。</p>
<p>举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。功能参数差不多。</p>
<p>apt-get install softname</p>
<p>apt-get update             更新软件包索引</p>
<p>apt-get upgrade            软件升级，执行前须执行update</p>
<p>apt-get remove softwarename 移除软体(保留设定档）</p>
<p>apt-get  –purge remove softwarename 移除软体(不保留设定档）</p>
<p><strong>软件包: build-essential 安装方法：sudo apt-get install build-essential</strong></p>
<p> 软件库地址文件/etc/apt/souces.list</p>
<p>apt-cache search softwarename   列出所有sofrwarename的套件</p>
<p>apt-cache show packageName   显示更多描述细节</p>
<p>apt-get clean(autoclean)         删除系统暂存的deb(autoclean只会将比目前系统旧版的套件删除)</p>
<p>apt-get dist-upgrade            转换系统的版本（需在/etc/apt/sources.list指定stable，testing或unstable）</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>X Window System</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/X-Window-System/</url>
    <content><![CDATA[<p>X Client 应用程序会将所想要呈现的画面告知 X Server ，最后由 X server 来将结果透过他所管理的硬件绘制出来</p>
<p>X Server 管理的是显示适配器、屏幕分辨率、鼠标按键对应等等</p>
<p>每部客户端主机都需要安装 X Server，而服务器端则是提供 X Client 软件， 以提供客户端绘图所需要的数据windows客户端 &lt;————服务器————&gt;mac客户端提供X Server管理         提供X Client     提供X Server管理<br>X window system 主要分为 X server 和 X client ，其中 ：X Server 在管理硬件（包括鼠标，键盘，显示器等）和图形绘制。 X Client 则 是应用程序，可提供数据给X Server来绘制图形。<br>每一支 X client 都不知道对方得存在，必须要透过特殊的 X client ，称为 Window Manager 的， 来管理各窗口的重迭、移动、最小化等工作。</p>
<p>startx 获取参数调用xinit启动窗口</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RAID</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/RAID/</url>
    <content><![CDATA[<p>Quota 磁盘配额，用于多账户中的系统管理员分配各账号资源。</p>
<p><strong>LVM</strong> （Logical Volume Manager） 逻辑卷管理</p>
<p>LVM 的重点在于『可以弹性的调整 filesystem 的容量！』而并非在于效能不数据保全上面。 </p>
<p>RAID（Redundant Arrays of Inexpensive Disks） 独立冗余磁盘阵列   </p>
<h1 id="标准RAID"><a href="#标准RAID" class="headerlink" title="标准RAID"></a>标准RAID</h1><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID-0"></a><strong>RAID-0</strong></h2><p><strong>RAID-0</strong> (等量模式,stripping)：效能最佳，没有备份，100M文件， 2个磁盘写入各50M</p>
<p>RAID 0亦称为带区集。它将两个以上的磁盘串联起来，成为一个大容量的磁盘。在存放数据时，分段后分散存储在这些磁盘中，因为读写时都可以并行处理，所以在所有的级别中，RAID 0的速度是最快的。但是RAID 0既没有冗余功能，也不具备容错能力，如果一个磁盘（物理）损坏，所有数据都会丢失，危险程度与JBOD相当。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/2bbb9dd0-c098-46fb-aeeb-9afd0de7220a.png" alt="RAID 0"></p>
<h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID-1"></a>RAID-1</h2><p><strong>RAID-1</strong> (映像模式, mirror)：完全备份，100M文件，2个磁盘写入各100M，利用率仅为50%。</p>
<p>两组以上的N个磁盘相互作<a href="http://zh.wikipedia.org/wiki/磁碟鏡像" target="_blank" rel="noopener">镜像</a>，在一些多线程操作系统中能有很好的读取速度，理论上读取速度等于硬盘数量的倍数，另外写入速度有微小的降低。只要一个磁盘正常即可维持运作，可靠性最高。RAID 1就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以RAID 1的数据安全性在所有的RAID级别上来说是最好的。但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中磁盘利用率最低的一个级别。如果用两个不同大小的磁盘建RAID 1，可用空间为较小的那个磁盘，较大的磁盘多出来的空间也可以分区成一个区来使用，不会造成浪费。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/8b7e5fc2-ba0d-4a2c-9c7d-dd1eff8df40b.png" alt="RAID 1"></p>
<h2 id="RAID-2"><a href="#RAID-2" class="headerlink" title="RAID 2"></a><strong>RAID 2</strong></h2><p>这是RAID 0的改良版，以<a href="http://zh.wikipedia.org/wiki/汉明码" target="_blank" rel="noopener">汉明码</a>（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID2最少要三台磁盘驱动器方能运作。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/db3a9069-0974-4644-bddb-8a44feccc7be.png" alt="RAID 2"></p>
<h2 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h2><p>采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/6bb794a3-5b0d-47c2-bf38-da668a8c3f0b.png" alt="RAID 3"></p>
<h2 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h2><p>它与RAID 3不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（块交织技术，Block interleaving）</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/2ab89468-1641-4c9d-9470-e97708a2230b.png" alt="RAID 4"></p>
<h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a><strong>RAID 5</strong></h2><p>至少三个磁盘才能组成，每个循环的写入过程中，在每颗磁盘还加入一个同位检查数据 (Parity) ，这个数据会记录其他磁盘的备份数据， 用于当有磁盘损毁时的救援。由于有同位检查码，因此 RAID 5 的总容量会是整体磁盘数量减一颗。 原本的 3 颗磁盘只会剩下 (3-1)=2 颗磁盘的容量。而且当损毁的磁盘数量大于等于两颗时，这整组 RAID 5 的资料就损毁了。 因为 RAID 5 预设仅能支持一颗磁盘的损毁情况。RAID 5读取很快，写入时由于要计算同位检查码 (parity) 的关系，尤其当使用软件磁盘阵列时，同位检查码是通过 CPU 去计算而非与职的磁盘阵列卡， 因此效能方面还需要评估。</p>
<p>RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。RAID 5至少需要三块硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的<a href="http://zh.wikipedia.org/wiki/奇偶校验" target="_blank" rel="noopener">奇偶校验</a>信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。RAID 5可以理解为是RAID 0和RAID 1的折衷方案。RAID 5可以为系统提供数据安全保障，但保障程度要比<a href="http://zh.wikipedia.org/wiki/鏡像" target="_blank" rel="noopener">镜像</a>低而磁盘空间利用率要比镜像高。RAID 5具有和RAID 0相近似的数据读取速度，只是因为多了一个奇偶校验信息，写入数据的速度相对单独写入一块硬盘的速度略慢，若使用“回写缓存”可以让性能改善不少。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较便宜。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/image-20210707223414969.png" alt="image-20210707223414969"></p>
<h2 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h2><p>与RAID 5相比，RAID 6增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。但RAID 6需要分配给奇偶校验信息更大的磁盘空间，相对于RAID 5有更大的“写损失”，因此“写性能”非常差。较差的性能和复杂的实作方式使得RAID 6很少得到实际应用。同一数组中最多容许两个磁盘损坏。更换新磁盘后，数据将会重新算出并写入新的磁盘中。依照设计理论，RAID 6必须具备四个以上的磁盘才能生效。</p>
<p>可使用的容量为硬盘总数减去2的差，乘以最小容量，公式为：</p>
<p>同理，数据保护区域容量则为最小容量乘以2。RAID 6在硬件磁盘阵列卡的功能中，也是最常见的磁盘阵列等级。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/e30a8ade-d986-4deb-a5e4-ad983645a557.png" alt="RAID 6"></p>
<h1 id="混合RAID"><a href="#混合RAID" class="headerlink" title="混合RAID"></a>混合RAID</h1><h3 id="JBOD"><a href="#JBOD" class="headerlink" title="JBOD"></a>JBOD</h3><p> JBOD（ Just a Bunch Of Disks）在分类上，JBOD并不是RAID的等级。由于并没有规范，市场上有两类主流的做法</p>
<ol>
<li>使用单独的链接端口如SATA、USB或1394同时控制多个各别独立的硬盘，使用这种模式通常是较高级的设备，还具备有RAID的功能，不需要依靠JBOD达到合并逻辑扇区的目的。</li>
<li>只是将多个硬盘空间合并成一个大的逻辑硬盘，没有错误备援机制。</li>
</ol>
<p>数据的存放机制是由第一颗硬盘开始依序往后存放，即操作系统看到的是一个大硬盘（由许多小硬盘组成的）。但如果硬盘损毁，则该颗硬盘上的所有数据将无法救回。若第一颗硬盘损坏，通常无法作救援（因为大部分文件系统将磁盘分区表（partition table）‎存在磁盘前端，即第一颗），失去磁盘分区表即失去一切数据，若遭遇磁盘阵列数据或硬盘出错的状况，危险程度较RAID 0更剧。它的好处是不会像RAID，每次访问都要读写全部硬盘。</p>
<h3 id="RAID-10-01"><a href="#RAID-10-01" class="headerlink" title="RAID 10/01"></a>RAID 10/01</h3><p>RAID 0+1，RAID 1+0 ，先4个磁盘中分两组raid0，这两组在raid1，叫raid0+1,如果先组成raid1，再组成raid0，叫raid1+0。</p>
<p>RAID 10是先镜射再分区数据，再将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。</p>
<p>RAID 01则是跟RAID 10的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成RAID 1的最低组合，而将两组硬盘各自视为RAID 0运作。</p>
<p>当RAID 10有一个硬盘受损，其余硬盘会继续运作。RAID 01只要有一个硬盘受损，同组RAID 0的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。如果以六个硬盘建RAID 01，镜射再用三个建RAID 0，那么坏一个硬盘便会有三个硬盘脱机。因此，RAID 10远较RAID 01常用，零售<a href="http://zh.wikipedia.org/wiki/主機板" target="_blank" rel="noopener">主板</a>绝大部份支持RAID 0/1/5/10，但不支持RAID 01。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/4afa441d-a59b-4df3-a2b8-2f1ea339451d.png" alt="RAID 1+0"><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/23ce5c96-7129-460f-b58c-3ed80e073d07.png" alt="RAID 0+1"></p>
<h3 id="RAID-50"><a href="#RAID-50" class="headerlink" title="RAID 50"></a>RAID 50</h3><p>RAID 5与RAID 0的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5彼此构成Stripe访问。由于RAID 50是以RAID 5为基础，而RAID 5至少需要3台硬盘，因此要以多组RAID 5构成RAID 50，至少需要6台硬盘。以RAID 50最小的6台硬盘配置为例，先把6台硬盘分为2组，每组3台构成RAID 5，如此就得到两组RAID 5，然后再把两组RAID 5构成RAID 0。</p>
<p>RAID 50在底层的任一组或多组RAID 5中出现1台硬盘损坏时，仍能维持运作，不过如果任一组RAID 5中出现2台或两台以上硬盘损毁，整组RAID 50就会失效。</p>
<p>RAID 50由于在上层把多组RAID 5构成Stripe，性能比起单纯的RAID 5高，容量利用率比RAID5要低。比如同样9块硬盘，RAID 50则3个RAID 5组成RAID 0，每个RAID 5会浪费一块硬盘，利用率为(1-3/9)，RAID 5则为(1-1/9)。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/99f0884d-f3a2-4368-90e1-9e27d470a7ce.png" alt="img"></p>
<h3 id="RAID-53"><a href="#RAID-53" class="headerlink" title="RAID 53"></a>RAID 53</h3><p>它拥有一个镜射条带数组，硬盘里其中一个条带就是一个是由3组以上的RAID 5组成RAID 3硬盘阵列。</p>
<h3 id="RAID-60"><a href="#RAID-60" class="headerlink" title="RAID 60"></a>RAID 60</h3><p>RAID 6与RAID 0的组合：先作RAID 6，再作RAID 0。换句话说，就是对两组以上的RAID 6作Stripe访问。RAID 6至少需具备4台硬盘，所以RAID 60的最小需求是8台硬盘。由于底层是以RAID 6组成，所以RAID 60可以容许任一组RAID 6中损毁最多2台硬盘，而系统仍能维持运作；不过只要底层任一组RAID 6中损毁3台硬盘，整组RAID 60就会失效，当然这种情况的机率相当低。比起单纯的RAID 6，RAID 60的上层通过结合多组RAID 6构成Stripe访问，因此性能较高。不过使用门槛高，而且容量利用率低是较大的问题。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/RAID/92f4b141-e6e9-464a-87de-2ab9d900c88c.jpg" alt="img"><br><strong>Spare Disk：</strong>一颗或多颗没有包含在原本磁盘阵列等级中的磁盘，这颗磁盘平时并不会被磁盘阵列所使用， 当磁盘阵列有任何磁盘损毁时，则这颗 spare disk 会被主动的拉近磁盘阵列中，并将坏掉的那颗硬盘移出磁盘阵列！ 然后立即重建数据系统。</p>
<p>RAID2、3、4较少实际应用，因为RAID5已经涵盖了所需的功能，因此RAID2、3、4大多只在研究领域有实现，而实际应用上则以RAID5为主。</p>
<p>RAID4有应用在某些商用机器上，像是NetApp公司设计的NAS系统就是使用RAID4的设计概念。</p>
<p>10个250G的磁盘组成RAID5，去掉一个Spare Disk剩9颗（9-1）*250=2000G</p>
<p><strong>hardware RAID</strong> 透过磁盘阵列卡来达成数组的目的。 磁盘阵列卡上面有一块专门的芯片在处理 RAID 的任务，因此在效能方面会比较好。在很多任务(例如 RAID 5 的同位检查码计算) 磁盘阵列并不会重复消耗原本系统的 I/O 总线，理论上效能会较佳。此外目前一般的中高阶磁盘阵列卡都支持热拔插， 亦即在不关机的情况下抽换损坏的磁盘，对于系统的复原与数据的可靠性方面非常的好用，但价格昂贵。</p>
<p><strong>Software RAID</strong> 透过软件来仿真数组的任务， 因此会损耗较多的系统资源，比如说 CPU 的运算不 I/O 总线的资源等。分类有二种：  纯软件磁盘阵列（Pure Software RAID）：只需要主板支持即可，不需要任何磁盘阵列卡。若主板损坏，可能难以购买同款主板重建RAID。<br>  硬件辅助磁盘阵列（Hardware-Assisted RAID）：需要一张RAID卡，以及厂商所提供的<a href="http://zh.wikipedia.org/wiki/驅動程式" target="_blank" rel="noopener">驱动程序</a>。这款RAID较易迁移到其他电脑。</p>
<h2 id="磁盘阵列比较表"><a href="#磁盘阵列比较表" class="headerlink" title="磁盘阵列比较表"></a>磁盘阵列比较表</h2><table>
<thead>
<tr>
<th><strong>RAID**</strong>等级**</th>
<th><strong>最少硬盘</strong></th>
<th><strong>最大容错</strong></th>
<th><strong>可用容量</strong></th>
<th><strong>读取性能</strong></th>
<th><strong>写入性能</strong></th>
<th><strong>安全性</strong></th>
<th><strong>目的</strong></th>
<th><strong>应用产业</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>单一硬盘</td>
<td>(参考)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>无</td>
<td></td>
<td></td>
</tr>
<tr>
<td>JBOD</td>
<td>1</td>
<td>0</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td>无（同RAID 0）</td>
<td>增加容量</td>
<td>个人（暂时）存储备份</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
<td>2</td>
<td>n-2</td>
<td>n-2</td>
<td>n-2</td>
<td>安全性较RAID 5高</td>
<td>同RAID 5，但较安全</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>1</td>
<td>n-1</td>
<td>n-1</td>
<td>n-1</td>
<td>高</td>
<td>追求最大容量、最小预算</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>10</td>
<td>4</td>
<td>n/2</td>
<td>n/2</td>
<td>n</td>
<td>n/2</td>
<td>安全性高</td>
<td>综合RAID 0/1优点，理论速度较快</td>
<td>大型数据库、服务器</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>n-1</td>
<td>1</td>
<td>n</td>
<td>1</td>
<td>最高，一个正常即可</td>
<td>追求最大安全性</td>
<td>个人、企业备份</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>0</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>一个硬盘异常，全部硬盘都会异常</td>
<td>追求最大容量、速度</td>
<td>视频剪接缓存用途</td>
</tr>
</tbody>
</table>
<p>\1. n代表硬盘总数<br>\2. JBOD可接到现有硬盘，直接增加容量</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>例行性工作排程</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="仅执行一次的工作排程"><a href="#仅执行一次的工作排程" class="headerlink" title="仅执行一次的工作排程"></a>仅执行一次的工作排程</h2><p><strong>启动一次工作排程服务的damon程序atd</strong></p>
<p>>/etc/init.d/atd  restart</p>
<p>>chkconfig atd  on 设定开机启动这个服务</p>
<p><strong>at执行流程</strong></p>
<p>我们使用 at 这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了。</p>
<p>\1.  先找寻 /etc/at.allow 这个档案，写在这个档案中的使用者才能使用 at ，没有在这个档案中的使用者则不能使用 at (即使没有写在 at.deny 当中)；</p>
<p>\2.  如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个档案，若写在这个 at.deny 得使用者则不能使用 at ，而没有在这个 at.deny 档案中得使用者，就可以使用 at 咯；</p>
<p>\3.  如果两个档案都不存在，那么只有 root 可以使用 at 这个指令。</p>
<p>at的执行与终端机环境无关，而所有 standard output/standard error output 都会传送到执行者的 mailbox 去啦！所以在终端机当然看不到任何信息。</p>
<p><strong>at [-mldv] TIME</strong></p>
<p><strong>at  -c  工作号码</strong></p>
<p>-m  ：当 at 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。</p>
<p>-l   ：at -l 相当于 atq，列出目前系统上面的所有该用户的 at 排程；</p>
<p>-d  ：at -d 相当于 atrm ，可以取消一个在 at 排程中的工作；</p>
<p>-v  ：可以使用较明显的时间格式栏出 at 排程中的任务栏表；</p>
<p>-c  ：可以列出后面接的该项工作的癿实际指令内容。</p>
<p>TIME：  HH:MM     ex&gt; 04:00  </p>
<p>​        HH:MM YYYY-MM-DD    ex&gt; 04:00 2009-03-17</p>
<p>​       HH:MM[am|pm] [Month] [Date]   ex&gt; 04pm March 17</p>
<p>​        HH:MM[am|pm] + number [minutes|hours|days|weeks]    ex&gt; now + 5 minutes    ex&gt; 04pm + 3 days</p>
<p>[root@www ~]# at 23:00 2009-03-17  设定一次排程任务</p>
<p>at&gt; /bin/sync</p>
<p>at&gt; /bin/sync</p>
<p>at&gt; /sbin/shutdown -h now</p>
<p>at&gt; <eot>  <strong>–输入ctrl +Ｄ出现<eot>，代表结束。</eot></strong></eot></p>
<p>job 5 at 2009-03-17 23:00　<strong>–自动生成</strong></p>
<p>[root@www ~]# at -c 4     –查询4号job的内容</p>
<p>#!/bin/sh   </p>
<p># atrun uid=0 gid=0</p>
<p># mail root 0</p>
<p>umask 22 </p>
<p><strong>atq  –查询所有at任务</strong></p>
<p><strong>atrm [jobnumber]  –删除at任务</strong></p>
<p><strong>batch  –在 CPU 工作负载小于 0.8 癿时候，才进行你所下达的工作任务
</strong></p>
<p>[root@www ~]# batch 23:00 2009-3-17</p>
<p>at&gt; sync</p>
<p>at&gt; sync</p>
<p>at&gt; shutdown -h now</p>
<p>at&gt; <eot></eot></p>
<p>job 6 at 2009-03-17 23:00</p>
<h2 id="循环执行的例行性工作排程"><a href="#循环执行的例行性工作排程" class="headerlink" title="循环执行的例行性工作排程"></a>循环执行的例行性工作排程</h2><p><strong>启动循环执行服务的damon程序crond(cron有的系统叫这个)，一般默认启动</strong></p>
<p>>/etc/init.d/crond restart</p>
<p>  /etc/cron.allow：将可以使用 crontab 得账号写入其中，若不在这个档案内得使用者则不可使用 crontab；优先级高于deny。</p>
<p>  /etc/cron.deny： 将不可以使用 crontab 得账号写入其中，若未记录到这个档案当中的使用者，就可以使用crontab 。</p>
<p>当用户使用 crontab 这个指令来建立工作排程之后，该项工作就会被记录到 /var/spool/cron/ 里面去了，而且是以账号来作为判别。</p>
<p> <strong>crontab [-u username] [-l|-e|-r]</strong> crontab名利为/etc/contab的文本文件，但可执行。</p>
<blockquote>
<p>-u  ：只有 root 才能进行这个任务，亦即帮其他使用者建立/移除 crontab 工作排程；</p>
<p>-e  ：编辑 crontab 的工作内容</p>
<p>-l  ： 查阅 crontab 的工作内容</p>
<p>-r  ：移除所有的crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</p>
</blockquote>
<p>[dmtsai@www ~]$ crontab -e</p>
<p># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</p>
<p> 0  12  <em>  </em>  *  mail dmtsai -s “at 12:00” &lt; /home/dmtsai/.bashrc</p>
<p>#分 时 日 月 周 |&lt;==============指令串========================&gt;|</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/例行性工作排程/2702d4a7-b61d-41ba-ac79-400d3b1b3c0a.png" alt="img"></p>
<p>  <strong>crontab -l  –查询所有</strong></p>
<p>  <strong>crontab -r  –删除所有
</strong></p>
<p> <strong>anacron
</strong></p>
<p>anacron处理非24小时启动的Linux系统的 crontab 的执行！anacron 并不能指定何时执行某项任务， 而是以天 为单位或者是在开机后立刻进行 anacron 的动作，他会去侦测停机期间应该进行但是并没有进行的 crontab任务，并将该任务执行一遍后， anacron 就会自动停止了。</p>
<p>>anacron [-sfn] [job]<br>>anacron -u [job]<br>  -s ：开始一连续的执行各项工作 (job)，会依据时间记录文件的数据判断是否进行；<br>  -f ：强制进行，而不去判断时间记录文件的时间戳；<br>  -n ：立刻进行未进行的仸务，而不延迟 (delay) 等待时间；<br>  -u ：仅更新时间记录文件的时间戳，不迚行仸何工作。<br>  job ：由 /etc/anacrontab 定义的各项工作名称。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>系统安装开关机流程</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%BC%80%E5%85%B3%E6%9C%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>磁盘的第一个扇区主要记录了两个重要的信息，分别是：</p>
<ul>
<li>主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes。</li>
<li>分割表(partition table)：记录整颗硬盘分割的状态，有 64 bytes。</li>
<li>由于分割表就只有 64 bytes 而已，最多只能容纳四笔分割的记录， 这四个分割的记录被称为主分区(Primary)和扩展分区(Extended)。</li>
<li>其实所谓的『分区』叧是针对那个 64 bytes的分割表进行设定而已！</li>
<li>硬盘的分割表仅能写入四组分割信息盘默认</li>
<li>这四组分割信息我们称为主(Primary)和扩展(Extended)分区</li>
<li>分区的最小单位为磁柱(cylinder)</li>
<li>当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分割槽进行数据的处理</li>
<li>主分区和扩展分区最多可以有四笔(硬盘的限制)</li>
<li>扩展分区最多只能有一个(操作系统的限制)</li>
<li>逻辑分区（Logical）是由扩展分区持续切割出来的分割槽；</li>
<li>能够被格式化后，作为数据存取的分割槽为主分区和逻辑分区。扩展分区无法格式化；</li>
<li>逻辑分区数量依操作系统而不同，在 Linux 系统中，IDE 硬盘最多有 59 个逻辑分区(5 号到63 号)， SATA 硬盘则有 11 个逻辑分区(5 号到 15 号)。 </li>
</ul>
<h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a><strong>开机流程</strong></h3><p>BIOS（加载CMOS中存储信息，INT13中断）——&gt;MBR(包含boot loader)——&gt;开机管理程序（boot loader）——&gt;kernal(/boot/vmlinuz)+initrd( Initial RAM Disk /boot/initrd)——&gt;/sbin/init(设置/etc/inittab)</p>
<ol>
<li>grub可以访问磁盘，加载kernal和intrd。</li>
<li>在kernal访问磁盘时，如果是非IDE接口的例如SATA接口，那么kernal没有硬盘驱动，kernal无法识别和访问SATA 磁盘。但是 SATA 的驱动程序在磁盘中的 /lib/modules 内，你根本无法访问磁盘又怎么读取到 /lib/modules/ 内的驱动程序呢。</li>
</ol>
<p>虚拟文件系统 (Initial RAM Disk) 一般使用的档名为 /boot/initrd ，这个档案的特色是，他也能够透过 boot loader 来加载到内存中，然后这个档案会被解压缩并且在内存当中仿真成一个根目录， 且此仿真在内存当中的文件系统能够提供一支可执行的程序，透过该程序来加载开机过程中所最需要的核心模块， 通常这些模块就是 USB, RAID, LVM, SCSI 等文件系统与磁盘接口的驱动程序啦。</p>
<p>一般来说，需要 initrd 的时刻为：</p>
<ul>
<li>根目录所在磁盘为 SATA、USB 或 SCSI 等连接接口；</li>
<li>根目录所在文件系统为 LVM, RAID 等特殊格式；</li>
<li>根目录所在文件系统为非传统 Linux 认识的文件系统时；</li>
<li>其他必须要在核心加载时提供的模块。 </li>
</ul>
<h4 id="init执行流程"><a href="#init执行流程" class="headerlink" title="init执行流程"></a><strong>init执行流程</strong></h4><ol>
<li>先取得 runlevel 亦即默认执行等级的相关等级 (以鸟哥的测试机为例，为 5 号)；</li>
<li>使用 /etc/rc.d/rc.sysinit 进行系统初始化，调用 /etc/sysconfig里面脚本，设定好整个系统环境，准备软件执行的作业环境 (如网络、时区等)。</li>
<li>根据/etc/rc.d/rc，根据运行级别调用/etc/rc.d/rc5.d来启动和停止服务 连接到/etc/rc.d/init.d里面的程序 ，然后调用/etc/rc.d/rc.local ， 启动自定义服务。</li>
<li>设定好 [ctrl]+[alt]+[del] 这组的组合键功能</li>
<li>设定不断电系统的 pf, pr 两种机制；</li>
<li>启动 mingetty 的六个终端机 (tty1 ~ tty6)</li>
<li>最终以 /etc/X11/perfdm -nodaemon 启动图形接口啦！<br>开机管理程序除了可以安装在 MBR 之外， 还可以安装在每个分割槽的启动扇区(boot sector)中，提供以下功能：</li>
<li>提供选单</li>
<li>载入核心档案</li>
<li>转交其他loader</li>
</ol>
<h4 id="GRUB启动的两个阶段"><a href="#GRUB启动的两个阶段" class="headerlink" title="GRUB启动的两个阶段"></a><strong>GRUB启动的两个阶段</strong></h4><p>MBR 是整个硬盘的第一个 sector 内的一个区块，整个大小也才 446 bytes 而已。 我们的 loader 功能这么强，光是程序代码于设定数据不止 446 bytes 。</p>
<p>为了解决这个问题，所以 Linux 将 boot loader 的程序代码执行与设定值加载分成两个阶段 (stage) 来执行：</p>
<ul>
<li>Stage 1：执行 boot loader 主程序：<br>第一阶段为执行 boot loader 的主程序，这个主程序必须要被安装在开机区，亦即是 MBR 或者<br>是 boot sector 。但如前所述，因为 MBR 实在太小了，所以，MBR 或 boot sector 通常仅安<br>装 boot loader 的最小主程序，并没有安装 loader 的相关配置文件；</li>
<li>Stage 2：主程序加载配置文件：<br>第二阶段为透过 boot loader 加载所有配置文件与相关的环境参数档案 (包括文件系统定义与主<br>要配置文件 /boot/menu.lst)， 一般来说，配置文件都在 /boot 底下。<br>重新启动 X Window 的快速按钮</li>
<li>直接注销，然后再重新登入卲可；</li>
<li>在 X 的画面中直接按下[Alt] + [Ctrl] + [Backspace]；</li>
</ul>
<p>X window 与文本模式的切换</p>
<ul>
<li>[Ctrl] + [Alt] + [F1] ~ [F6]  ：文字接口登入 tty1 ~ tty6 终端机；  run level 3</li>
<li>[Ctrl] + [Alt] + [F7]       ：图形接口桌面。                 run level 5</li>
</ul>
<p>etc/issue   显示文本模式登录前的系统提示信息</p>
<p>etc/inittab 显示运行模式</p>
<p>[vbird@www ~]$ date +%Y/%m/%d<br>2009/08/17</p>
<p>[vbird@www ~]$ date +%H:%M</p>
<p>17:04</p>
<p>Ctrl+c  中断当前执行的指令</p>
<p>Ctrl+z  是把当前的程序挂起，暂停执行这个程序。用fg返回执行的指令，当然，配合bg和fg命令进行前后台切换会非常方便。</p>
<p>Ctrl+d  =exit 退出当前用户</p>
<p>[Tab][Tab] 两个tab键显示有多少Linux命令</p>
<h3 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h3><ul>
<li>man date</li>
</ul>
<p>DATE(1)   NULL(4)</p>
<p>man man 可查询指令等级</p>
<p>代号                 代表内容</p>
<p> 1      用户在 shell 环境中可以操作的指令或可执行文件</p>
<p> 2      系统核心可呼叫的凼数或工具等</p>
<p> 3      一些常用的凼数(function)与凼式库(library)，大部分为 C 的凼式库(libc)</p>
<p> 4      装置档案的说明，通常在/dev 下的档案</p>
<p> 5      配置文件或者是某些档案的格式</p>
<p> 6      游戏(games)</p>
<p> 7      惯例与协议等，例如 Linux 文件系统、网络协议、ASCII code 等等的说明</p>
<p> 8      系统管理员可用的管理指令</p>
<p> 9      跟 kernel 有关的文件</p>
<p>指令查找：</p>
<p>man -f man= whatis man 查找指令名为man的或包含man指令 。whatis指令需建立whatis数据库 makewhatis(无空格)</p>
<p>man -k man=apropos man 查找命令的描述信息中含有man的指令。</p>
<ul>
<li>info date</li>
<li>/usr/share/doc</li>
</ul>
<p>nano vim 编辑器</p>
<h3 id="关机步骤"><a href="#关机步骤" class="headerlink" title="关机步骤"></a>关机步骤</h3><ol>
<li>查看状态<br>who 谁在线<br>netstat -a 网络状态<br>ps aux  进程状态</li>
<li>sync  内存回写硬盘</li>
<li>shutdown -h now 立刻关机<br> shutdown -h 20:35 在20:35关机<br> shutdown -h +10  ‘I will shutdown after 10 mins’= shutdown -h 10  ‘I will shutdown after 10 mins<br> shutdown -r now  立刻重启<br> shutdown -k now ‘This system will reboot’ 发出警告<br> reboot   重启<br> halt     关机<br> poweroff 关机<br> init 0    关机<br> init 6    重启</li>
</ol>
<h3 id="RUN-LEVEL"><a href="#RUN-LEVEL" class="headerlink" title="RUN LEVEL"></a>RUN LEVEL</h3><ul>
<li>0 - halt (系统直接关机)</li>
<li>1 - single user mode (单人维护模式，用在系统出问题时的维护)</li>
<li>2 - Multi-user, without NFS (类似底下的 runlevel 3，但无 NFS 服务)</li>
<li>3 - Full multi-user mode (完整含有网络功能的纯文本模式)</li>
<li>4 - unused (系统保留功能)</li>
<li>5 - X11 (与runlevel 3 类似，但加载使用 X Window)</li>
<li>6 - reboot (重新启动)</li>
</ul>
<h3 id="CentOS7-更新"><a href="#CentOS7-更新" class="headerlink" title="CentOS7 更新"></a>CentOS7 更新</h3><p><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7429718.png" alt="img"><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7450031.png" alt="img"><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7469375.png" alt="img"><img src="/2014/Linux/鸟哥的Linux私房菜/系统安装开关机流程/7529968.png" alt="img"></p>
<p>更新驱动模块之间的相依性</p>
<p>modep [-A] 不加任何参数时, depmod 会主动的去分析目前核心的模块,并且重新写入/lib/modules/$(uname -r)/modules.dep 当中。</p>
<p>​      若加入 -A 参数时,则depmod会去搜寻比 modules.dep 内还要新的模块,如果真找到新模块,才会更新。</p>
<p>modprobe [-r]驱动名  自动搜寻modules.dep，加载驱动,删除驱动</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>chgrp users install.log</p>
<p>chgrp -R users  /etc/usr   -R递归</p>
<p>chown root  install.log</p>
<p>chown root:root  install.log</p>
<p>chown -R users  /etc/usr   -R递归</p>
<p>chmod 755  .bashrc  权限为-rwxr-xr-x  -R与目录配合递归</p>
<p>chmod  u=rwx,go=rx   .bashrc</p>
<p>chmod  a+x  .bashrc   a包括owner group others全部</p>
<p>chmod  a-x  .bashrc </p>
<h3 id="档案与目录"><a href="#档案与目录" class="headerlink" title="档案与目录"></a>档案与目录</h3><p><strong>档案</strong>是实际含有数据的地方，包括一般文本文件、数据库内容文件、二进制可执行文件(binary program)等等。 因此，权限对于档案来说，他的意义是这样的：</p>
<p> r (Read)：  可读取此档案内包含的内容，如读取文本文件的文字内容等；</p>
<p> w (Write)：可以新增、删除或修改此档案里面包含的内容(<strong>但不能删除该档案</strong>)；</p>
<p> x (eXecute)：该档案具有可以被系统执行的权限。</p>
<p>Windows 底下一个档案是否具有执行的能力是藉由『 扩展名 』来判断的， 例如：.exe, .bat, .com 等等，</p>
<p>但是在 Linux 底下，我们的档案是否能被执行，则是藉由是否具有『x』这个权限来决定的！跟档名是没有绝对的关系的！</p>
<p><strong>目录</strong>主要的内容在记录文件名列表，文件名与目录有强烈的关连啦！ r (read contents in directory)：</p>
<blockquote>
<p>表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！</p>
</blockquote>
<p> w (modify contents of directory)：</p>
<blockquote>
<p>这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目录结构列表的权限，也就是底下这些权限：</p>
<p>o  建立新的档案与目录；</p>
<p>o  删除已经存在的档案与目录(不论该档案的权限为何！)</p>
<p>o  将已存在的档案或补录进行更名；</p>
<p>o  搬移该目录内的档案、目录位置。</p>
<p>总之，目录的 w 权限就与该目录底下的文件名异动有关就对了啦！</p>
</blockquote>
<p> x (access directory)：</p>
<blockquote>
<p>目录的 x 代表的是用户能否进入该目录成为工作目录的用途！ 所谓的工作目录(work directory)就是你目前所在的目录啦！</p>
<p>举例来说，当你登入 Linux 时， 你所在的家目录就是你当下的工作目录。而变换目录的指令是『cd』(change directory)啰。</p>
</blockquote>
<p>例题：</p>
<blockquote>
<p>假如有个账号名称为 dmtsai，他的家目录在/home/dmtsai/，dmtsai 对此目录具有[rwx]的权限。 </p>
<p>若在此目彔下有个名为 the_root.data 的档案，该档案的权限如下： </p>
<p>-rwx—— 1 root root 4365 Sep 19 23:20 the_root.data</p>
<p>请问 dmtsai 对此档案的权限为何？可否删除此档案？ </p>
</blockquote>
<p>答：</p>
<blockquote>
<p>由于 dmtsai 对此档案来说是『others』的身份，因此这个档案他无法读、无法编辑也无法执行， 也就是说，他无法变动这个档案的内容就是了。</p>
<p>但是由于这个档案在他的家目录下，他在此目录下具有 rwx 的完整权限，因此对于the_root.data 这个『档名』来说，他是能够『删除』的！ </p>
<p>结果就是，dmtsai 这个用户能够删除 the_root.data 这个档案！</p>
</blockquote>
<p><strong>r=4,w=2,x=1</strong></p>
<p><strong>umask –默认值需要减掉的权限</strong></p>
<p>>umask </p>
<p>0022</p>
<p>>umask -S</p>
<p>u=rwx,g=rx,o=rx</p>
<p>>umask 002  设置umask为002，同组人可读写该文件。</p>
<p>档案默认权限666 -rw-rw-rw-  ; 目录默认权限777 drwxrwxrwx</p>
<p>  建立档案时：(-rw-rw-rw-) - (—–w–w-) ==&gt; -rw-r–r–</p>
<p>  建立目录时：(drwxrwxrwx) - (d—-w–w-) ==&gt; drwxr-xr-x</p>
<p>umask 为 003 ，所以拿掉的权限为 ——–wx，</p>
<p>因此：</p>
<p>档案： (-rw-rw-rw-) - (——–wx) = -rw-rw-r–</p>
<p>目录： (drwxrwxrwx) - (——–wx) = drwxrwxr–</p>
<p>先将umask转换成rwx符号，用符号相减，不能用666-003=663=rw-rw-wx,不对。</p>
<p><strong>档案的隐藏属性 –</strong>在Ext2/Ext3 的文件系统中</p>
<p><strong>chattr</strong></p>
<p> +  ：增加某一个特殊参数，其他原本存在参数则不动。</p>
<p> -  ：移除某一个特殊参数，其他原本存在参数则不动。</p>
<p> =  ：设定一定，且仅有后面接的参数</p>
<p> a  ：当设定 a 之后，这个档案将只能增加数据，而不能删除也不能修改数据，只有 root才能设定这个属性。</p>
<p>  i  ：这个 i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法写入或新增资料！』对于系统安全性有相当大的帮助！只有 root 能设定    此属性。</p>
<p>>chattr +i attrtest</p>
<p>>chattr -i  attrtest</p>
<p><strong>lsattr (显示档案隐藏属性)</strong></p>
<blockquote>
<p>-a ：将隐藏文件的属性也秀出来；</p>
<p>-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；</p>
<p>-R ：连同子目录的数据也一并列出来！</p>
</blockquote>
<p>> chattr +aij attrtest</p>
<p>>lsattr attrtest</p>
<p>—-ia—j— attrtest</p>
<p><strong>档案特殊权限： SUID, SGID, SBIT</strong></p>
<p><strong>Set UID（档案，不能是shell script 和目录）</strong></p>
<p>s 这个标志出现在档案拥有者的 x 权限上时，为Set UID,简称为SUID的特殊权限。</p>
<p>-rw<strong>s</strong>r-xr-x 1 root root 22984 Jan 7 2007 /usr/bin/passwd</p>
<p>SUID作用：</p>
<blockquote>
<p>  SUID 权限仅对二进制程序(binary program)有效；</p>
<p>  执行者对于该程序需要具有 x 的可执行权限；</p>
<p>  本权限仅在执行该程序的过程中有效 (run-time)；</p>
<p>  执行者将具有该程序拥有者 (owner) 的权限。</p>
</blockquote>
<p>一般用户改密码</p>
<ol>
<li><p>/usr/bin/passwd为二进制程序。</p>
</li>
<li><p>vbird具有执行权限</p>
</li>
<li><p>vbird在执行passwd时</p>
</li>
</ol>
<p>4.具有该程序的拥有者root的权限，vbird暂时变成该程序拥有者root，故vbird执行passwd，相当于root执行passwd，passwd会修改/etc/shadow(该程序只能由root读写)的内容来修改用户的密码。</p>
<p><strong>Set GID</strong></p>
<p>s 在群组的 x 时则称为 Set GID，SGID</p>
<p>-rwx–<strong>s</strong>–x 1 root slocate  23856 Mar 15 2007 /usr/bin/locate</p>
<p>-rw-r—–  1 root slocate 3175776 Sep 28 04:02 /var/lib/mlocate/mlocate.db  </p>
<p>对档案来说， SGID 有如下的功能：</p>
<p>  SGID 对二进制程序有用；</p>
<p>  程序执行者对于该程序来说，需具备 x的权限；</p>
<p>  执行者在执行的过程中将会获得该程序群组的支持！变为群组的一员。</p>
<p>vbird对locate这个二进制程序有执行权限，故执行时，获得群组支持，暂时成为slocate一员，能够读取mlocate.db的内容。</p>
<p>对目录设定了 SGID 的权限后，他将具有如下的功能：</p>
<p>  用户若对于此目录具有 r 与x 的权限时，该用户能够进入此目录；</p>
<p>  用户在此目录下的有效群组(effective group)将会变成该目录的群组；</p>
<p>  用途：若用户在此目录下具有 w 的权限(可以新建档案)，则使用者所建立的新档案，该新档案的群组与此目录的群组相同。</p>
<p>auser（群组agroup，project）buser(群组bgroup,project) 在devp目录下（drwxrwx— 2 root project）,目录未加SGID时，auser在devp内新建文件</p>
<p>-rw-rw-r– 1 auser agroup 0 Sep 29 22:46 abcd，此文件buser只能删除不能编辑，加上SGID后，当user新建文件时</p>
<p>-rw-rw-r– 1 auser project  0 Sep 29 22:53 1234  群组变为devp的群组project,由于两人都属于project群组,umask为002，所以两人可以互相修改对方的文件。</p>
<p><strong>Sticky Bit（只对目录有效）</strong></p>
<p>SBIT 对于目录的作用是：</p>
<p> 当用户对于此目录具有 w, x 权限，亦即具有写入的权限时；</p>
<p>  当用户在该目录下建立档案或目录时，仅有自己与 root 才有权力删除该档案</p>
<p>换句话说：当甲这个用户于 A 目录是具有群组或其他人的身份，并且拥有该目录 w 的权限， 这表示『甲用户对该目录内任何人建立的目录活档案均可进行 “删除/更名/搬移” 等动作。』 不过，如果将 A 目录加上了 SBIT 得权限项目时， 则甲只能够针对自己建立的档案或目录进行删除/更名/移动等动作，而无法删除他人的案。</p>
<p> 举例来说，我们的 /tmp 本身的权限是『drwxrwxrw<strong>t</strong>』， 在这样的权限内容下，任何人都可以在/tmp 内新增、修改档案，但仅有该档案/目录建立者与 root 能够删除自己的目录或档案。没有t时，对目录拥有w权限，能删目录下的全部档案，加上t后，自己只能删自己的，不能删别人的。</p>
<p><strong>4 为 SUID 2 为 SGID 1 为 SBIT</strong></p>
<p> >chmod 4755 test</p>
<p>-rwsr-xr-x 1 root root 0 Sep 29 03:06 test  加入SUID</p>
<p>>chmod 6755 test</p>
<p>-rwsr-sr-x 1 root root 0 Sep 29 03:06 test  加入SUID/SGID</p>
<p>>chmod 1755 test</p>
<p>-rwxr-xr-t 1 root root 0 Sep 29 03:06 test  加入SBIT</p>
<p>>chmod 7666</p>
<p>-rwSrwSrwT 1 root root 0 Sep 29 03:06 test  加入空的SUID/SGID</p>
<p>7666,没有执行权限了，只有rw权限，拥有者都不能执行，故没有特殊权限了</p>
<p>>chmod u=rwxs,go=x test -rws–x–x 1 root root 0 Aug 18 23:47 test&gt; chmod g+s,o+t test -rws–s–t 1 root root 0 Aug 18 23:47 test</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>正规档案（regular file） （-）</p>
<p>   文本文档(ASCII)</p>
<p>   二进制文件(binary)</p>
<p>   数据格式文件(data)</p>
<p>目录（directory）（d）<br>链接档（link）（l）<br>设备与装置文件（device）</p>
<p>   区块设备（b）</p>
<p>   字符设备（c）</p>
<p>资料接口文件（sockets）（s）</p>
<p>数据输送文件（FIFO,pipe）（p）</p>
<p>有五个目录不可与根目录放在不同的 partition，分别为/etc, /bin, /lib, /dev, /sbin 五个。</p>
<p>Linux 档名的限制为：单一档案或目录的最大容讲文件名为 255 个字符；包含完整路径名称及目录(/) 之完整档名为 4096 个字符</p>
<p> FHS 订定出来的四种目彔特色为： shareable, unshareable, static, variable 等四类；<br> FHS 所定义的三层主目彔为： /, /var, /usr 三层而已；</p>
<h3 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h3><p>cd(Change Directory)  </p>
<p>​    cd ~  =  cd  进入家目录</p>
<p>​    cd -  进入上一工作目录</p>
<p>pwd(Print Working Directory )</p>
<p>   pwd  -P  ：显示出确实的路径，而非使用链接 (link) 路径。</p>
<p>mkdir</p>
<p>​    mkdir -p test1/test2/test3/test4  连续建立子目录。</p>
<p>​    mkdir -m 711 test2             建立711的test2目录，不挂吧umask。 </p>
<p>rmdir</p>
<p>​    rmdir  /test4  仅能删除空目录</p>
<p>​    </p>
<p> PATH=”$PATH”:/root    将/root加入到PATH中</p>
<p>-————————</p>
<h3 id="档案相关命令"><a href="#档案相关命令" class="headerlink" title="档案相关命令"></a>档案相关命令</h3><p><strong>ls</strong></p>
<p>  -a：显示隐藏文件和 .  ..目录</p>
<p>  -l ：长数据串输出，包括档案的属性和权限</p>
<p>  -d : 仅列出目录本身，而不是列出目录内的癿档案数据</p>
<p>  -h : 将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来；</p>
<p>  -n : 列出 UID  与 GID 而非使用者与群组的名称 </p>
<p>  -i  :  列出 inode 号码。</p>
<p>  ls -al /tmp</p>
<p><strong>cp(copy)</strong></p>
<p>   -a : 相当于-pdr ，复制文件 的权限，子目录，和源文件一样。</p>
<p>   -d  ：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非档案本身；</p>
<p>   -f  ：为强制(force)的意思，若目标档案已经存在且无法开启，则移除后再尝试一次；</p>
<p>   -i  ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</p>
<p>   -l  ：进行硬式连结(hard link)的连结档建立，而非复制档案本身；</p>
<p>   -s  ：复制成为符号链接文件 (symbolic link)，亦即『忚捷方式』档案；</p>
<p>   -p  ：连同档案的属性一起复制过去，而非使用默认属性(备份常用)；</p>
<p>   -r  ：递归持续复制，用于目录复制行为；(常用)</p>
<p>cp -a /var/log/wtmp /tmp/vbird_wtmp</p>
<p>cp -r /etc/ /tmp  -r复制目录单权限改变，可用 -a备份</p>
<p>cp -s bashrc bashrc_slink  建立符号链接文件。</p>
<p>cp -l bashrc bashrc_hlink  建立硬式连接文件。</p>
<p><strong>rm(remove)</strong></p>
<p>   -f 强制。</p>
<p>   -i 交互提示，需要确认。</p>
<p>   -r 递归删除，删除目录。</p>
<p>rmdir  /tmp/etc rmdir只能删除空目录</p>
<p>rm -r /tmp/etc 可以删除</p>
<p><strong>mv(move)</strong></p>
<p>   -f 强制。</p>
<p>   -i 交互提示，需要确认。</p>
<p>mv file1 file2 dir1 将file1 file2 移动到dir1中</p>
<p>mv dir1  dir2 改名</p>
<p>-————————————————————————————</p>
<h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><p><strong>cat(concatenate)</strong></p>
<p>  -A 显示全部特殊符号</p>
<p>  -n 显示行号 </p>
<p>  -b  显示行号，空白行不加</p>
<p>cat  -n /etc/issue</p>
<p><strong>tac  –将内容反序显示，最后一行按第一行显示</strong></p>
<p><strong>nl</strong> </p>
<p><strong>more</strong></p>
<p>   对管线不能向前翻页</p>
<p><strong>less</strong>  </p>
<p>   可以前后翻页</p>
<p><strong>head</strong></p>
<p>   默认显示前10行</p>
<p>head -n  20 /etc/man.config   显示前20行</p>
<p>head -n -100 /etc/man.config 后面的100行不显示</p>
<p><strong>tail</strong> </p>
<p>  默认显示后10行</p>
<p>tail -n  20   /etc/ man.config  显示后面的20行</p>
<p>tail -n +100  /etc/man.config  前面的100行不显示</p>
<p>head -n 20 /etc/man.config|tail -n 10  显示10-20行</p>
<p><strong>od</strong></p>
<p><strong>modification time (mtime)： 档案内容改变时间。默认
</strong></p>
<p><strong>status time (ctime)： 权限或属性被改变时间
</strong></p>
<p><strong>access time (atime)：档案被访问时间</strong></p>
<p>ll bashrc; ll –time=atime bashrc; ll –time=ctime bashrc 显示bashrc的三个时间</p>
<p><strong>touch bbb 建立一个BBB空档案</strong></p>
<p><strong>touch -t  1401010709 bashrc  将bashrc时间改为2014-01-01 07:09  mtime和atime改变，ctime为当前时间。</strong></p>
<p><strong>file 查看文件类型</strong></p>
<p><strong>which 二进制命令  按PATH路径进行搜索 命令</strong></p>
<p>  -a将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到得命令名称</p>
<p><strong>whereis 档案或目录  搜索文件 在文件索引数据库中</strong></p>
<p><strong>locate  文件名</strong></p>
<blockquote>
<p>-i  ：忽略大小写的差异；</p>
<p>-r  ：后面可接正则表示法的显示方式</p>
</blockquote>
<p>搜索 /var/lib/mlocate数据库 可用updatedb指令更新数据。</p>
<p><strong>find（直接查找硬盘）</strong></p>
<p>find /var -mtime -4  4天内更改的文件（含四天本身）</p>
<p>find /var -mtime +4 4天前更改的文件（不含四天本身）</p>
<p>find /var -mtime  4  4天前的那一天更改的文件</p>
<p>find / -mtime 0   24小时内更改的文件</p>
<p>find /etc -newer /etc/passwd</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/文件系统/9608dc1a-b8cf-4deb-bb92-25093864d1b7.png" alt="img"></p>
<p>find /var  -uid n</p>
<p>find /var  -gid n</p>
<p>find /var  -user  vbird       find /var  -nouser</p>
<p>find /var  -group  ugroup    find /var  -nogroup   </p>
<p>find / -name passwd</p>
<p>find / -size  +50k   find / -size  -50c   c为byte</p>
<p>find /var -type s   一般正规档案 (f),装置档案 (b, c), 目录 (d), 连结档 (l), socket (s),及 FIFO (p) 等属性。</p>
<p>find / -perm 4755 根目录下权限等于 -rwsr-xr-x的文件</p>
<p>find / -perm -0744 根目录下权限大于-rwsr-xr-x的文件，即全部囊括-rwsr-xr-x   –最小权限</p>
<p>find / -perm +7000根目录下包含任意—s–s–t的文件，即只要含有 s 或 t 的就列出 –最大权限</p>
<p>find / -perm -7000 根目录下包含—s–s–t所有三个特殊权限的文件</p>
<p>find / -perm +7000 -exec ls -l {} \;</p>
<p>find /etc -size +50k -a ! -user root -type f -exec ls -l {} \   -a=and</p>
<p>find /etc -size +1500k -o -size 0                       -o=or</p>
<p>find /etc -name ‘<em>httpd</em>‘</p>
<p>  superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</p>
<p>  inode：记录档案的属性，一个档案占用一个 inode，同时记录此档案的数据所在的 block 号码；</p>
<p>  block：实际记录档案的内容，若档案太大时，会占用多个 block 。 </p>
<p>linux通过VFS((Virtual Filesystem Switch)进行管理和读取各个 partition 上头的 filesystem。</p>
<p><strong>df  –查询superblock</strong></p>
<p>  -a  ：列出所有的文件系统，包括系统特有的 /proc（内存里程序） 等文件系统；  /dev/shm为内存虚拟的磁盘空间。</p>
<p>  -h  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</p>
<p>  -T  ：连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</p>
<p>  -i  ：不用硬盘容量，而以 inode的数量来显示</p>
<p>>df -ahT</p>
<p>>df -i</p>
<p><strong>du</strong></p>
<p>  -a  ：列出所有的档案与目录容量，因为默认仅统计目录底下的档案量而已。</p>
<p>  -h  ：以人们较易读的容量格式 (G/M) 显示；<br>   -s  ：列出总量而已，而不列出每个各别得目录占用容量；</p>
<p>   -S  ：不包括子目录下得总计，不 -s 有点差别。</p>
<p>>du -ah</p>
<p><strong>ln</strong>   详见P260</p>
<p>hard link :目录a指向数据，新增一个目录b指向a链接的数据。b直接访问数据。</p>
<p>soft  link : 目录a指向数据，新增一个目录b指向a。通过a访问数据。</p>
<p>>ln passwd passwd-hd</p>
<p>>ln -s passwd passwd-so   加s为软连接，不加默认为硬链接</p>
<p>> ls -li passwd*</p>
<p>586361 -rw-r–r– 2 root root 1945 Sep 29 02:21 passwd</p>
<p>586361 -rw-r–r– 2 root root 1945 Sep 29 02:21 passwd-hd</p>
<p>586401 lrwxrwxrwx 1 root root  6 Oct 22 14:18 passwd-so -&gt; passwd</p>
<p><strong>fdisk  （分区命令）</strong></p>
<p>   -l 显示分区表</p>
<p>fdisk 硬盘名（不是分区名）  不加硬盘名时扫描整个系统，显示全部硬盘的信息</p>
<p>>fdisk  /dev/hda</p>
<p>>partprobe  &lt;==强制让核心重新捉一次 partition table</p>
<p><strong>mkfs（</strong>make filesystem<strong>）（格式化命令）</strong></p>
<p>>mkfs -t ext3 /dev/hdc6</p>
<p><strong>mke2fs</strong> 不用，麻烦</p>
<p>>mke2fs -j -L “vbird_logical” -b 2048 -i 8192 /dev/hdc6</p>
<p><strong>mount</strong> 装置文件名 挂载点</p>
<p>mount /dev/hdc6   /mnt/hdc6  将/dev/hdc6挂载到/mnt/hdc6下</p>
<p>mount -l                    显示系统已挂载的文件系统 -l显示label name</p>
<p>mount -o remount,rw,auto /    重新挂载根目录</p>
<p><strong>umount</strong> 装置文件名或挂载点</p>
<p>umount /dev/hdc6 </p>
<p>umount /mnt/hdc6</p>
<p>dumpe2fs -h /dev/hdc6            查询label name</p>
<p>mount -L “vbird_logical” /mnt/hdc6  根据label name 进行挂载</p>
<p><strong>e2label</strong> 更改labelname</p>
<p>dumpe2fs -h /dev/hdc6            查询label name</p>
<p>e2label /dev/hdc6 “my_test”         将label name 改为my_test</p>
<p><strong>在/etc/fstab 中设定挂载文件系统</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>程序管理和SELinux</title>
    <url>/2021/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E5%92%8CSELinux/</url>
    <content><![CDATA[<p>程序 (program)：通常为 binary program ，放置在储存媒体中 (如硬盘、光盘、软盘、磁带等)， 为实体档案的型态存在；</p>
<p>程序 (process)  ：程序被觉发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载内存中， 操作系统并给予这个内存内的单元一个标识符 (PID)，可以说，程序就是一个正在运作中的程序。</p>
<p><strong>fork and exec</strong>：过程调用的流程</p>
<p>(1)系统先以 fork 的方式复制一个与父程序相同的暂存程序，这个程序与父程序唯一的差别就是 PID 不同！ 但是这个暂存程序还会多一个 PPID的参数，PPID 就是父程序的程序标识符！</p>
<p>(2)暂存程序开始以 exec 的方式加载实际要执行的程序，以标来讲，新的程序名称为 qqq ，最终子程序的程序代码就会变成 qqq 了！</p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/7fc10055-b1c9-460b-a341-d3d0375918ff.png" alt="img"></p>
<h2 id="工作管理（Job-Control）"><a href="#工作管理（Job-Control）" class="headerlink" title="工作管理（Job Control）"></a>工作管理（Job Control）</h2><p>进行工作管理的行为中， 其实每个工作都是<strong>目前 bash（单一终端机接口） 的子**</strong>程序**，亦即彼此之间是有相关性的。 我们无法以 job control 的方式由 tty1的环境去管理 tty2 的bash ！</p>
<p><strong>扔背景中执行 &amp;</strong></p>
<p>>tar -zcv -f /tmp/etc.tar.gz  /etc &gt; /tmp/log.txt  2&gt;&amp;1  &amp;</p>
<p>[1] 8429  &lt;== [job number] PID </p>
<p> 放到背景后，[ctrl]+c 也无法停止执行。</p>
<p><strong>将目前工作扔到背景中暂停  [ctrl]-z</strong></p>
<p> <img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/ad650d36-ec41-42af-b5fc-b7f1dfa4d301.jpg" alt="img"></p>
<p><strong>观察目前的背景工作状态  jobs</strong>  </p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/372581b9-3e6d-4b1b-9a58-db3fca54cee7.png" alt="img"></p>
<p><strong>将背景工作拿到前景来处理：fg (foreground)</strong> </p>
<p>fg %jobnumber  –jobnumber 为工作号码(数字)。注意，那个 % 是可有可无的</p>
<p>>fg     –预设取出那个 + 的工作，亦即2。</p>
<p>>fg %1  –取出1号工作。</p>
<p><strong>将背景中的暂停改为背景中的执行：bg（background）</strong></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/6908739e-386d-404d-ae0a-28e41929c6bb.png" alt="img"></p>
<p><strong>管理背景当中的工作： kill</strong>  </p>
<p><strong>kill -l</strong></p>
<p>-l     ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？</p>
<p>signal ：代表给予后面接的那个工作什么样的指示！用 man 7 signal 可知：</p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/f34c3c39-f539-4b36-9c60-f0ba03ae7a3a.jpg" alt="img"></p>
<p><strong>kill -signal  %jobnumber  –signal可以使代号或者名称</strong></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/afeecb68-eec1-4fd4-8357-7ae1b81866a1.jpg" alt="img"></p>
<p>15为默认值，kill 可以帮我们将这个 signal 传送给某个工作 (%jobnumber) 或者是某个 PID (直接输入数字)，管理bash的工作控制时，要加上%。</p>
<p><strong>kill -signal PID</strong></p>
<p>获取syslog程序的PID,并利用kill -1 PID掉。</p>
<p>>ps aux | grep ‘syslog’ | grep -v ‘grep’| awk ‘{print $2}’</p>
<p>>kill -SIGHUP $(ps aux|grep ‘syslog’|grep -v ‘grep’|awk ‘{print $2}’)</p>
<p><strong>killall -signal 指令名称</strong></p>
<p>killall [-iIe] [command name]</p>
<blockquote>
<p>-i  ：interactive 的意思，交互式的，若需要删除时，会出现提示字符给用户；</p>
<p>-e  ：exact 的意思，表示『后面接的 command name 要一致』，但整个完整的指令不能超过 15 个字符。</p>
<p>-I  ：指令名称(可能含参数)忽略大小写。 </p>
</blockquote>
<p>>killall -1 syslogd</p>
<p>>killall -9 httpd</p>
<p>>killall -i -9 bash –要用户确认</p>
<p><strong>nohup –在脱机或注销系统后，还能够将工作继续进行</strong></p>
<p>nohup [指令与参数]   &lt;==在终端机前景中工作nohup [指令与参数] &amp; &lt;==在终端机背景中工作<br><strong>程序管理**</strong>ps ：将某个时间点的程序运作情况取下来**<br>>ps -l   –列出与你的操作环境 (bash) 有关的程序而已， 亦即最上层的父程序会是你自己的 bash 而没有延伸到 init 这支程序。&gt;ps -lA  –列出全部程序情况&gt;ps aux  –列出目前所有的正在内存当中的程序，没有 “-” </p>
<p>>ps axjf  –列出类似程序树的程序显示，没有 “-” </p>
<p><strong>top：动态观察程序的变化</strong></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/fc01de5e-5a7c-48db-b488-ada58b4e14fe.png" alt="img"></p>
<p>>top       –默认五秒刷新一次</p>
<p>>top -d  2   –两秒刷新一次</p>
<p>>top -b -n 2 &gt; /tmp/top.txt  –将 top 的信息进行 2 次，然后将结果输出到 /tmp/top.txt</p>
<p>>echo $$  –获取当前程序PID</p>
<p>4574</p>
<p>>top -p 4574  –只显示当前程序的信息</p>
<p><strong>pstree</strong><br>-A ：各程序树之间的连接以 ASCII 字符来连接；<br>-U ：各程序树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误。<br>-p ：并同时列出每个 process 的 PID；<br>-u ：并同时列出每个 process 的所属账号名称。<br>>ps -A</p>
<p>>ps -Aup  –显示各个程序的拥有者和PID</p>
<p><strong>程序执行优先级</strong></p>
<p>PRI(new) = PRI(old) + nice  PRI值越小优先级越高</p>
<p>  nice 值可调整的范围为 -20 ~ 19 ；  root 可随意调整自己或他人程序的 Nice 值，范围为 -20 ~ 19 ；  一般用户仅可调整自己程序的 Nice 值，范围仅为 0 ~ 19 (避免一般用户抢占系统资源)；  一般使用者仅可将 nice 值越调越高，例如本来 nice 为 5 ，则未来仅能调整到大于 5；<strong>nice ：新执行的指令即给予新的nice 值</strong><br>nice [-n 数字] command<br>>nice -n -5 vi &amp;<br><strong>renice ：已存在程序的 nice 重新调整</strong><br>renice [number] PID<br>>renice 10 18625系统资源的观察<strong>​free ：观察内存使用情况</strong><br>free [-b|-k|-m|-g]  –默认以Kbytes显示，加上-b bytes， -k Kbytes，-m Mbytes，-g Gbytes显示&gt;free -m<br><strong>uname：查阅系统与核心相关信息</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/efee98ef-b3d0-431f-81bc-998c4bc65647.png" alt="img"><br>>uname -a<br><strong>netstat ：追踪网络或插槽文件</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/04ffb359-95e5-4392-b8a0-d2355b15d0e9.png" alt="img"><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/665908ac-9476-4ff5-92ec-a8525150605d.png" alt="img"><br>>netstat -rn =route -n&gt;netstat  –显示网络和本机相关程序的相关性&gt;netstat -tlnp  –找出目前系统上已在监听的网络联机及其 PID&gt;netstat -tulnp  –秀出目前已经启动的网络服务<br><strong>nmap –[**</strong>Network exploration tool and security<strong> </strong>port scanner<strong>**]:侦测别的主机开放的端口</strong><br>nmap [扫瞄类型] [扫瞄参数] [hosts 地址与范围]选项与参数：[扫瞄类型]：主要的扫瞄类型有底下几种：</p>
<blockquote>
<p>-sT：扫瞄 TCP 封包已建立的联机 connect() ！</p>
<p>-sS：扫瞄 TCP 封包带有 SYN 卷标的数据 -sU：以 UDP 的封包格式进行扫瞄</p>
<p>-sP：以 ping 的方式进行扫瞄</p>
<p>-sO：以 IP 的协议 (protocol) 进行主机的扫瞄</p>
</blockquote>
<p>[扫瞄参数]：主要的扫瞄参数有几种：</p>
<blockquote>
<p>-PT：使用 TCP 里头的 ping 的方式来进行扫瞄，可以获知目前有几部计算机存活(较常用)</p>
<p>-PI：使用实际的 ping (带有 ICMP 封包的) 来进行扫瞄</p>
<p>-p ：这个是 port range ，例如 1024-, 80-1023, 30000-60000 等等的使用方式</p>
</blockquote>
<p>[Hosts 地址与范围]：这个有趣多了，有几种类似的类型</p>
<blockquote>
<p>192.168.1.100  ：直接写入 HOST IP 而已，仅检查一部；</p>
<p>192.168.1.0/24 ：为 C Class 的型态，</p>
<p>192.168.<em>.</em>  ：嘿嘿！则变为 B Class 的型态了！扫瞄的范围变广了！</p>
<p>192.168.1.0-50,60-100,103,200 ：这种是变形的主机范围啦！很好用吧！</p>
</blockquote>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/7cd58a0b-b19b-4210-abdb-186d03c25bd2.png" alt="img"></p>
<p><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/ca747a34-fa8e-476d-9c86-aa0dad411822.png" alt="img"><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/24394921.png" alt="img"></p>
<p><strong>vmstat ：侦测系统资源变化</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/174122ca-ef3d-4183-a723-17aed3baa8f9.png" alt="img"><strong>
</strong>&gt;vmstat 1 3&gt;vmstat -d <strong>dmesg ：分析核心开机侦测系统的硬件和系统运行中产生的讯息<br>>dmesg|more&gt;dmesg|grep -i hd
</strong>fuser：藉由档案(或文件系统)找出正在使用该档案的程序<strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/607e1e1e-474a-4500-8310-97655f0947b4.png" alt="img">
</strong>&gt;fuser -uv .&gt;fuser -mvu /proc<br><strong>lsof ：列出被程序所开启的档案文件名</strong><br><img src="/2021/Linux/鸟哥的Linux私房菜/程序管理和SELinux/f83c4b26-d59c-47e0-afd3-5bd2f6373b86.png" alt="img"><br><strong>&gt;lsof  – 列出目前系统上面所有已经被开启的档案与装置&gt;lsof -u root -a -U   –仅列出关于 root 的所有程序开启的 socket 档案&gt; lsof +d /dev   –列出目前系统上面所有的被启动的周边装置
</strong>pidof ：找出某支正在执行的程序的 PID<br>pidof [-sx] program_name</p>
<blockquote>
<p>-s  ：仅列出一个 PID 而不列出所有得 PID</p>
<p>-x  ：同时列出该 program name 可能的 PPID 那个程序的 PID</p>
</blockquote>
<p>>pidof syslogd</p>
<hr>
<h2 id="SELinux-Security-Enhanced-Linux"><a href="#SELinux-Security-Enhanced-Linux" class="headerlink" title="SELinux(Security Enhanced Linux )"></a><strong>SELinux(</strong>Security Enhanced Linux <strong>)</strong></h2><p>DAC（Discretionary Access Control）自主式访问控制</p>
<p>MAC (Mandatory Access Control) 委任式访问控制  –SELinux</p>
<p>>getenforce  –查看SELinux模式</p>
<p>> sestatus –查看SELinux 的政策 (Policy) </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>系统服务和日志分析</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>service  系统提供的一些基本服务（不管是系统本身还是网络方面）  </p>
<p>daemon 提供服务的程序</p>
<p>crond程序为daemon，启动后提供 循环型例行性工作排程服务 (service)。</p>
<p>daemon分类</p>
<p>1.<strong>stand_alone</strong>  自行启动而不必透过其他机制的管理，常驻内存中提供服务，响应速度快。常见有WWW 的 daemon (httpd) FTP 的 daemon (vsftpd)</p>
<p>2.<strong>super daemon</strong> 服务的启动方式是藉由一个统一的 daemon 来负责唤起服务，被称为 super daemon 。 早期的 super daemon 是 inetd 这一个，后来则被 xinetd 所取代了。当没有客户端的要求时，各项服务都是未启动的情况，等到有来自客户端的要求时， super daemon 才唤醒相对应的服务。 当客户端的要求结束后，被唤醒的这个服务也会关闭并释放系统资源。具有安全控管的机制，不会一直占用系统资源， 服务的反应时间会比较慢一些。分为multi-threaded (多重线程)和single-threaded (单个线程)处理模式，常见有telnet。</p>
<p><strong>stand alone 启动</strong></p>
<p>启动的脚本放置到 /etc/init.d/ 这个目录中</p>
<p>直接启动<br>>/etc/init.d/atd  [start|stop|status|restart]</p>
<p>service命令启动</p>
<p>>service atd (start|stop|restart|)<br>> service –status-all  –显示所有服务的状态</p>
<p><strong>super daemon 启动</strong></p>
<p>super daemon 的配置文件在 /etc/xinetd.d/* 内<br><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/f41f4be5-475b-46fe-b882-783b16693cdf.png" alt="img"></p>
<p><strong>chkconfig</strong><br>透过 chkconfig 来管理 super daemon 的服务喔！另外， chkconfig 仅是设定开机时预设会启动的服务而已， 所以该服务目前的状态如何是不知道的。<br><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/554fa55a-2a1f-4a49-a890-5a06993d39ce.png" alt="img"></p>
<hr>
<p>系统一般日志保存目录：/var/log/*</p>
<p>日志服务相关daemon:</p>
<blockquote>
<p>  syslogd：主要登录系统与网络等服务的讯息；</p>
<p>  klogd：主要登录核心产生的各项信息；</p>
<p>  logrotate：主要在进行登录文件的轮替功能；</p>
</blockquote>
<p><strong>syslogd ：记录登录文件的服务</strong></p>
<p>启动： /etc/init.d/syslog restart</p>
<p>syslogd配置文件：/etc/syslog.conf   主要设置什么服务在大于什么等级记录日志到什么地方 利用<strong>man 3 syslog</strong>查询相关信息</p>
<p>内容：mail.info    /var/log/maillog_info  mail  服务产生的大于等于 info 等级的讯息，都记录到 # /var/log/maillog_info 档案中的意思。</p>
<p><strong>服务名称</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/81ea47fc-f5dc-462b-9361-74aef330f4e7.png" alt="img"></p>
<p><strong>讯息等级</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/087fc452-0371-4ba2-b13d-d2cec23d2cc3.png" alt="img"></p>
<p><strong>logrotate：日志轮替（将原日志建成一个旧档，新建一个空的档案给日志服务使用）</strong></p>
<p>syslog 利用的是 super daemon 的方式来启动的， 当有需求的时候立刻就会被执行的。</p>
<p>logrotate 却是在规定的时间到了之后才来进行登录档的轮替， 所以logrotate 程序是挂在 cron 底下得。/etc/cron.daily/logrotate</p>
<p>配置文件</p>
<p>/etc/logrotate.conf  主要配置文件，一般通用配置<br>/etc/logrotate.d/    被logrotate.conf调用执行，对特定文件的配置</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/系统服务和日志分析/def3861c-45c1-4225-a32f-a92d8bd9516d.png" alt="img"><br>o prerotate：在启动 logrotate 之前进行的指令，例如修改登录文件的属性等动作；<br>o postrotate：在做完 logrotate 之后启动的指令，例如重新启动 (kill -HUP) 某个服务！</p>
<p>o Prerotate 与 postrotate 对于已加上特殊属性的档案处理上面，是相当重要的执行程序！</p>
<p><strong>logrotate [-vf] logfile</strong></p>
<p>-v ：启动显示模式，会显示 logrotate 运作的过程喔！<br>-f ：不论是否符合配置文件的数据，强制每个登录档都进行rotate的动作！<br>>logrotate -v /etc/logrotate.conf</p>
<p>建立自己的日志记录文件</p>
<p>> chattr +a /var/log/admin.log  –只能增加，不能删除和移动，改名等。</p>
<p>>vi /etc/logrotate.d/admin</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#This configuration is from zhangyf 2014/2/12</span><br><span class="line">/var/log/admin.log &#123;</span><br><span class="line">	monthly          &lt;==每个月进行一次</span><br><span class="line">	size=10M         &lt;==档案容量大于 10M 则开始处置</span><br><span class="line">	rotate 5         &lt;==保留五个！</span><br><span class="line">	compress         &lt;==进行压缩工作！</span><br><span class="line">	sharedscripts</span><br><span class="line">	prerotate</span><br><span class="line">	         /usr/bin/chattr -a /var/log/admin.log</span><br><span class="line">	endscript</span><br><span class="line">	sharedscripts</span><br><span class="line">	postrotate</span><br><span class="line">	        /usr/bin/killall -HUP syslogd</span><br><span class="line">	       /usr/bin/chattr +a /var/log/admin.log</span><br><span class="line">	endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>账号管理和ACL权限和PAM</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E5%92%8CACL%E6%9D%83%E9%99%90%E5%92%8CPAM/</url>
    <content><![CDATA[<p>使用者标识符： UID （User ID ） GID （Group ID ）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UID取值范围如下</span><br><span class="line">0：           * *系统管理员**</span><br><span class="line"></span><br><span class="line">1~99：      由 distributions 自行建立的**系统账号**；100~499：   若用户有**系统账号**需求时，可以使用的账号 UID。500~65535：**可登入账号**，给一般使用者用的。</span><br><span class="line">用户验证步骤：</span><br><span class="line">1.在/etc/passwd中寻找输入的用户名，如果存在则读取对应的UID，GID（在/etc/group中），该账号家目录和shell设定一并读出。</span><br><span class="line">2.在 /etc/shadow中根据用户UID查找密码是否和输入密码一致。</span><br><span class="line">/etc/group    群组用户文件</span><br><span class="line">/etc/gshadow 群组密码文件</span><br><span class="line"></span><br><span class="line">有效群组(effective group)与初始群组(initial group)</span><br></pre></td></tr></table></figure></p>
<p>>usermod -G users dmtsai     &lt;==先设定好次要群组<br>>grep  dmtsai  /etc/passwd  /etc/group  /etc/gshadow<br>/etc/passwd:dmtsai:x:503:504::/home/dmtsai:/bin/bash<br>/etc/group:users:x:100:dmtsai,daemon  &lt;==次要群组的设定<br>/etc/group:dmtsai:x:504:daemon      &lt;==因为是初始群组，所以第四字段不需要填入账号<br>/etc/gshadow:users:::dmtsai,daemon   &lt;==次要群组的设定<br>/etc/gshadow:dmtsai:!::daemon<br><code>`</code><br>dmtsai中GID为504，在/etc/group中查找第三字段（GID）为504的群组为dmtsai，故dmtsai为初始群组，在users的第四字段中有dmtsai用户，故users群组为dmtsai用户的次要群组。dmtsai群组为dmtasi，users。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/30d3c14e-b22f-4efc-ac80-7aede2518684.png" alt="img"></p>
<p>><strong>groups</strong></p>
<p>dmtsai users  第一个为有效群组，建立文件时该文件群组为第一个。</p>
<p>><strong>newgrp</strong> users  更改有效群组</p>
<p>users  dmtsai </p>
<p>-—————————————————————————————————————————-</p>
<p><strong>useradd</strong> [-u UID] [-g 初始群组] [-G 次要群组] [-mM]  [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名</p>
<blockquote>
<p>-M  ：强制！不要建立用户家目录！(系统账号默认值)</p>
<p>-m  ：强制！要建立用户家目录！(一般账号默认值)</p>
<p>-r   ：建立一个系统的账号，这个账号的 UID 会有限制 (参考 /etc/login.defs)</p>
</blockquote>
<p>>useradd zyf</p>
<p>结果为：</p>
<p>\1. 在 /etc/passwd 里面建立一行与账号相关的数据，包括建立 UID/GID/家目录等；</p>
<p>\2. 在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码；</p>
<p>\3. 在 /etc/group 里面加入一个和账号名称一模一样的组名；</p>
<p>\4. 在 /home 底下建立一个与账号同名的目录作为用户家目录，且权限为 700</p>
<p>>useradd -r vbird3  建立系统账号，不会建立家目录</p>
<p>useradd -D 默认值</p>
<p>/etc/login.defs  账号权限默认值</p>
<p>/etc/skel/*  家目录默认值</p>
<p><strong>passwd</strong><br>passwd [–sdtin] username </p>
<p>  –stdin ：可以透过来自前一个管线的数据，作为密码输入，对 shell script 有帮组</p>
<p>>passwd aaa</p>
<p>>echo “abc543CC” | passwd –stdin aaa  利用管线修改密码</p>
<p>>passwd -S aaa  –显示账号属性</p>
<p>aaa PS 2015-01-29 0 99999 7 -1 (Password set, SHA512 crypt.)&gt;passwd -l aaa  –将aaa加锁aaa LK 2009-02-26 0 60 7 10 (Password locked.)&gt;passwd -u aaa  –将aaa解锁</p>
<p><strong>chage  –更改用户属性</strong></p>
<p>chage -l aaa  –显示aaa用户详细属性</p>
<p>>echo “agetest” | passwd –stdin agetest<br>>chage -d 0 agetest<br>agetest第一次登陆时用’agetest’可以登陆，登陆后提示必须改密码。</p>
<p><strong>usermod –更改用户属性</strong></p>
<p><strong>userdel</strong><br>userdel [-r] user  加-r删除家目录<br><strong>id</strong> [username]  –显示UID/GID等信息，不加username显示自己的信息</p>
<p><strong>groupadd</strong></p>
<p><strong>&gt;</strong>groupadd group1  –添加群组</p>
<p><strong>groupmod</strong><br>groupmod [-g gid] [-n group_name] 群组名<br>> groupmod -g 201 -n mygroup group1</p>
<p><strong>groupdel</strong> [groupname]</p>
<p>>groupdel group1</p>
<p><strong>ACL（Acess Control List）</strong></p>
<p><strong>setfacl</strong></p>
<p>setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名</p>
<p>​    -m ：设定后续的 acl 参数给档案使用，不可于 -x 合用； </p>
<p>​     -x ： 删除后续的 acl 参数，不可与 -m 合用； </p>
<p>​     -b ：移除所有的 ACL 训定参数；</p>
<p>​     -k ：移除预设的 ACL 参数，关于所谓的『预设』参数与后续范例中介绍； </p>
<p>​     -R ：递归设定 acl ，亦即包括次目录都会被设定起来； </p>
<p>​     -d ：设定『预设 acl 参数』的意思！只对目录有效，在该目录新建的数据会引用此默认值</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/7d6c9dee-a090-45e8-bf92-cdecda17d652.png" alt="img"></p>
<p><strong>getfacl</strong></p>
<p>getfcal filename</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/0a59a4c6-d790-4de4-a469-024230fb4c04.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/a190becb-be14-4be8-a11b-8470d94b5779.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/账号管理和ACL权限和PAM/c0326181-900d-4634-b63b-53a95a48e60e.png" alt="img"></p>
<p><strong>切换账号</strong></p>
<p><strong>su</strong></p>
<p>>su   切换到root时，env环境变量还是原来用户的变量。su  name 一般账户</p>
<p>>su -  切换到root时，env环境变量也变为root的。     su -  name或 su -l name  一般账户</p>
<p>>su - -c ‘head -n 3 /etc/passwd’ 仅想要执行一次root的指令，完成后变回原来的用户环境。</p>
<p><strong>root切换成一般使用者时不用输入用户密码</strong></p>
<p><strong>sudo</strong></p>
<p>root身份 不需输密码</p>
<p>sudo -c aaa touch /tmp/myfiles  以aaa的身份去执行命令,新建的文件owner为aaa</p>
<p>sudo -c aaa sh -c “mkdir ~aaa/www;cd ~aaa/www;echo ‘This is index.html file&gt;index.html’”</p>
<p>一般用户身份 需输入该用户密码</p>
<p>sudo cat /etc/passwd </p>
<p>sudo执行步骤：</p>
<p>\1. 当用户执行 sudo 时，系统于 /etc/sudoers 档案中搜寻该使用者是否有执行 sudo 的权限；</p>
<p>\2. 若使用者具有可执行 sudo 的权限后，便让使用者『输入用户自己的密码』来确认；</p>
<p>\3. 若密码输入成功，便开始进行sudo 后续接的指令。</p>
<p>\4. 若欲切换得身份不执行者身份相同，那也不需要输入密码(root 执行 sudo 时，不需要输入密码)。</p>
<p><strong>visudo 与/etc/sudoers</strong></p>
<p>>visudo  只能通过输入visudo命令来编辑sudoers</p>
<p>使用者账号  登入者的来源主机名=(可切换的身份)  可下达的指令</p>
<p>root                    ALL=(ALL)          ALL  &lt;==这是默认值</p>
<p>\1. aaa  ALL=(ALL)  ALL             –让aaa可以执行root命令</p>
<p>\2. %groupname  ALL=(ALL)  ALL     –让groupname里面的用户可以执行root命令</p>
<p>\3. myuser1  ALL=(root)   !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root    –可以执行『 passwd 任意字符』，但是『 passwd 』和『 passwd root 』这两个指令例外！ 如此一来 myuser1 就无法改变 root 的密码了！</p>
<p>\4. 用别名设定 </p>
<p>  User_Alias ADMPW = pro1, pro2, pro3, myuser1, myuser2</p>
<p>  Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</p>
<p>  ADMPW  ALL=(root)   ADMPWCOM</p>
<p><strong>PAM(Pluggable Authentication Modules, 嵌入式模块)</strong></p>
<p><strong>PAM 可以说是一套应用程序编程接口 (Application Programming Interface, API)，他提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 (成功或失败)。由于 PAM 仅是一套验证的机制，又可以提供给其他程序所呼叫引用，因此不论你使用什么程序，都可以使用 PAM 来进行验证，如此一来，就能够让账号密码或者是其他方式的验证具有一致的结果。)</strong></p>
<p>验证类别（Type）</p>
<p>auth 认证（authentication） 判断用户是否合法</p>
<p>account 账号（authenorization）授权</p>
<p>session 管理使用者在这次登入 (或使用这个指令) 期间，PAM 所给予的环境设定。 </p>
<p>password  提供验证的修订工作</p>
<p>控制旗标（control flag）</p>
<p>required  不论成功失败都向下执行。</p>
<p>requisite  成功时向下执行，失败时停止。</p>
<p>sufficient  失败时向下执行，成功时停止。</p>
<p>optional  用在显示讯息，不在验证方面。</p>
<p>常用模块</p>
<p>pam_securetty.so</p>
<p>pam_nologin.so</p>
<p>pam_selinux.so</p>
<p>pam_console.so</p>
<p>pam_loginuid.so</p>
<p>pam_env.so</p>
<p>pam_unix.so</p>
<p>pam_cracklib.so</p>
<p>pam_limits.so</p>
<p>passwd的PAM验证流程：</p>
<p>\1.  用户开始执行 /usr/bin/passwd 这支程序，并输入密码；</p>
<p>\2.  passwd 呼叫 PAM 模块进行验证；</p>
<p>\3.  PAM 模块会到 /etc/pam.d/ 找寻与程序 (passwd) 同名的配置文件；</p>
<p>\4.  依据 /etc/pam.d/passwd 内的设定，引用相关的 PAM 模块逐步进行验证分析；</p>
<p>\5.  将验证结果 (成功、失败以及其他讨息) 回传给 passwd 这支程序；</p>
<p>\6.  passwd 这支程序会根据 PAM 回传的结果决定下一个动作 (重新输入新密码或者通过验证！)</p>
<p> /etc/pam.d/*：每个程序个别的 PAM 配置文件；</p>
<p>  /lib/security/*：PAM 模块档案的实际放置目录； </p>
<p>  /etc/security/*：其他 PAM 环境的配置文件；</p>
<p>  /usr/share/doc/pam-*/：详绅的 PAM 说明文件。</p>
<p>查询登录信息</p>
<p>><strong>w</strong></p>
<p>><strong>who</strong></p>
<p>><strong>lastlog</strong> 读取 /var/log/lastlog内容</p>
<p>><strong>last</strong> </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络防火墙SSH</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99SSH/</url>
    <content><![CDATA[<p>观察主记路由 route</p>
<p>>route [-n]   n ： 将主机名以 IP 的方式显示</p>
<p>>ifconfig eth0 观察本机的网卡卡号</p>
<p>取得本机的 ARP 表格内的 IP/MAC 对应数据</p>
<p>>arp [-n]     n ： 将主机名以 IP 的方式显示</p>
<p>   /etc/services这个档案则是记录架构在 TCP/IP 上面的总总协议，包括 http, ftp, ssh, telnet 等等服务所定义的 port number ，都是这个档案所规划出来的。如果你想要自定义一个新的协议与 port 的对应，就得要改这个档案了；   /etc/protocols这个档案则是在定义出 IP 封包协议的相关数据，包括 ICMP/TCP/UDP 这方面的封包协议的定义等。<br>ifup eth0 (ifdown eth0)启动或者是关闭某张网络接口。可以透过这个简单的 script 来处理喔！ 这两个 script 会主动到 /etc/sysconfig/network-scripts/ 目录下，  读取适当的配置文件来处理啊！ (例如 ifcfg-eth0)。</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/9073b2b7-9c21-4541-a505-1bf85f949743.png" alt="img"></p>
<h2 id="固定IP设置"><a href="#固定IP设置" class="headerlink" title="固定IP设置"></a>固定IP设置</h2><p>\1.   IP/Netmask/Gateway 的设定、启动与观察</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/572e274c-a40c-44a6-8705-a9f8daf2dedd.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/71031518-480c-40fb-b966-5216c40056fc.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/ea13b29f-b3cc-40b1-b632-1b5ec8b88ed4.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/e229784f-e336-48a6-9992-f4799d6f2def.png" alt="img"></p>
<p>\2.   DNS 服务器的 IP 设定与观察</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/1b25a14d-cffd-4142-9002-4f94f209c596.jpg" alt="img"></p>
<p>\3.   主机名的修改、启动与观察（修改完毕之后要顺利启动的话，得要重新启动才可以）</p>
<h2 id><a href="#" class="headerlink" title></a><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/1520c456-79db-458c-87cc-33178ab29bec.jpg" alt="img"></h2><h2 id="DHCP设置"><a href="#DHCP设置" class="headerlink" title="DHCP设置"></a>DHCP设置</h2><p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/5f15a44b-2f4e-4c5d-804b-a6920f72bcf0.jpg" alt="img"></p>
<p><strong>宽带直连</strong></p>
<p><strong>ADSL拨接上网</strong></p>
<p>  安装rp-pppoe</p>
<p>  执行pppoe-setup设置账号密码</p>
<p><strong>WLAN无线网络</strong></p>
<p>1.察看模块与相对应的网卡代号</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/4ccfb7a6-499f-432d-adeb-b1ea97c116b3.jpg" alt="img"></p>
<p>2.利用 iwlist 侦测 AP</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/6a629a0d-cc0c-4d19-9b51-16b704768584.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/b6ce3708-6215-407f-933a-32a4655a12ec.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/aaffeded-8298-41ed-9786-a580316567c8.png" alt="img"></p>
<p>3.设定网络卡配置文件 (ifcfg-ethn)</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/a7eb64e1-2beb-40b8-a412-13c9df45bcb1.png" alt="img"></p>
<p>4.启动与观察无线网卡</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/3355020d-73ff-4b72-be32-9d0f555a0d0e.png" alt="img"></p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p><strong>&gt;ifconfig {interface} {up|down} &lt;== 观察与启动接口</strong></p>
<p><strong>&gt;ifconfig interface {options}    &lt;== 设定与修改接口</strong></p>
<p>选项与参数：</p>
<p>interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等</p>
<p>options  ：可以接的参数，包括如下：</p>
<blockquote>
<p>up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)</p>
<p>mtu  ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)</p>
<p>netmask  ：就是子屏蔽网络；</p>
<p>broadcast：就是广播地址啊！</p>
</blockquote>
<p>>ifconfig   观察所有的网络接口</p>
<p>>ifconfig eth0 192.168.100.100  netmask 255.255.255.128  mtu 800  设定eth0网络卡参数</p>
<p>>ifconfig eth0:0 192.168.50.50   为eth0设定第二个IP</p>
<p>>ifconfig eth0:0 down          关掉 eth0:0 这个界面。那如果想用默认值启动 eth1：『ifconfig eth1 up』即可达成</p>
<h3 id="ifup-ifdown"><a href="#ifup-ifdown" class="headerlink" title="ifup, ifdown"></a>ifup, ifdown</h3><p><strong>&gt;ifup|ifdown {interface}</strong></p>
<p>两支程序其实是 script 而已，他会直接到/etc/sysconfig/network-scripts 目录下搜寻对应的ifcfg-ethX 配置文件。</p>
<p>例如 ifup eth0 时，他会找出 ifcfg-eth0 这个档案的内容，然后来加以设定。</p>
<p>注意：如果以 ifconfig eth0 …. 来设定或者是修改了网络接口后， 那就无法再以ifdown eth0 的方式来关闭了！</p>
<p>因为 ifdown 会分析比对目前的网络参数与ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。</p>
<p><strong>因此，使用 ifconfig 修改完毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔！</strong></p>
<h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p><strong>route [-nee]</strong></p>
<p>-n  ：不要使用通讯协议或主机名，直接使用 IP 或 port number；-ee ：使用更详细的信息来显示<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/1f01ede4-5026-41dd-824d-daaf66bdda51.png" alt="img"><br>Flags：总共有多个旗标，代表的意义如下：o   U (route is up)：该路由是启动的；o   H (target is a host)：目标是一部主机 (IP) 而非网域；o   G (use gateway)：需要透过外部的主机 (gateway) 来转递封包； o   R (reinstate route for dynamic routing)：使用动态路由时，恢复路由信息的旗标；o   D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由o   M (modified from routing daemon or redirect)：路由已经被修改了；o   ! (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！</p>
<p>Metric 距离、跳数。暂无用。</p>
<p>Ref  不用管，恒为0。</p>
<p>Use   该路由被使用的次数，可以粗略估计通向指定网络地址的网络流量。</p>
<p><strong>route add [-net|-host] [网域或主机] netmask [mask] [gw|dev]</strong></p>
<p><strong>route del  [-net|-host] [网域或主机] netmask [mask] [gw|dev]</strong></p>
<p>>route  del  -net 169.254.0.0   netmask 255.255.0.0   dev eth0  删除路由</p>
<p>>route add  -net 192.168.100.0 netmask 255.255.255.0 dev eth0 增加路由</p>
<p>>route add default gw 192.168.1.250  设置默认路由</p>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p><strong>ip [-s] link show &lt;== 单纯的查阅该装置相关的信息，**</strong>-s ：显示出该装置的统计数据(statistics)，例如总接受封包数等<strong>**ip link set [device] [动作与参数]</strong>     set ：可以开始设定项目， device 指的是 eth0, eth1 等等界面代号；</p>
<blockquote>
<p>up|down  ：启动 (up) 或关闭 (down) 某个接口，其他参数使用默认的以太网络；</p>
<p>address  ：如果这个装置可以更改 MAC 的话，用这个参数修改！</p>
<p>name  ：给予这个装置一个特殊的名字；</p>
<p>mtu  ：就是最大传输单元啊！</p>
</blockquote>
<p>>ip link set eth0 up|down</p>
<p>更改网卡名称 mac地址</p>
<p>> ip link set eth0 down &lt;==关闭界面</p>
<p>> ip link set eth0 name vbird &lt;==重新设定</p>
<p>> ip link show &lt;==观察一下</p>
<p>> ip link set vbird name eth0 &lt;==界面改回来</p>
<p>> ip link set eth0 address aa:aa:aa:aa:aa:aa</p>
<p><strong>ip address show &lt;==就是查阅 IP 参数啊！</strong></p>
<p><strong>ip address [add|del] [IP 参数] [dev 装置名] [相关参数]</strong></p>
<p>相关参数：</p>
<blockquote>
<p>broadcast：设定广播地址，如果设定值是 + 表示『让系统自动计算』<br>label  ：亦即是这个装置的别名，例如 eth0:0 就是了！<br>scope  ：这个界面的领域，通常是这几个大类：<br> global ：允许来自所有来源的联机；预设为此。<br>site  ：仅支持 IPv6 ，仅允许本主机的联机；<br>link  ：仅允许本装置自我联机；<br>host  ：仅允许本主机内部的联机；</p>
</blockquote>
<p>>ip  address  add  192.168.50.50/24  broadcast +  dev eth0  label eth0:vbird</p>
<p>>ip  address  del  192.168.50.50/24  dev eth0</p>
<p><strong>ip route show &lt;==单纯的显示出路由的设定而已</strong></p>
<p><strong>ip route [add|del] [IP 或网域] [via gateway] [dev 装置]</strong></p>
<p>>ip route add 192.168.5.0/24  dev  eth0</p>
<p>>ip route add 192.168.10.0/24  via  192.168.5.100  dev  eth0</p>
<p>>ip route add default  via  192.168.1.254  dev  eth0</p>
<p>>ip route del  192.168.10.0/24</p>
<h3 id="dhclient"><a href="#dhclient" class="headerlink" title="dhclient"></a>dhclient</h3><p>>dhclient eth0  可以立刻叫我们的网络卡以 dhcp 协议去尝试取得 IP</p>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p><strong>ping [参数] IP</strong></p>
<p>-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；-n  ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此数值；-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；-W 数值：等待响应对方主机的秒数。-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：</p>
<blockquote>
<p>do  ：代表传送一个 DF (Don’t Fragment) 旗标，让封包不能重新拆包与打包；</p>
<p>dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包</p>
</blockquote>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/430a2387-882e-4aa9-acef-8d0d5683466e.png" alt="img"></p>
<p>如果你的主机与待侦测主机并不在同一个网域内，  那么 TTL 预设使用255 ，如果是同一个网域内，那么 TTL 预设则使用 64 。</p>
<p>找出MTU</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/38db0d85-bb97-4035-a1a1-249c51a29d7d.png" alt="img"></p>
<p>#!/bin/bash</p>
<p>for siteip in $(seq 1 254)</p>
<p>do</p>
<blockquote>
<p>site=”192.168.1.${siteip}”</p>
<p>ping -c1 -W1 ${site} &amp;&gt; /dev/null</p>
<p>if [ “$?” == “0” ]; then </p>
<p>  echo “$site is UP”</p>
<p>else</p>
<p>  echo “$site is DOWN”</p>
<p>fi</p>
</blockquote>
<p>done</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>traceroute [选项与参数] IP选项与参数：-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！-U ：使用 UDP 的 port <a href="tel:33434" target="_blank" rel="noopener">33434</a> 来进行侦测，这是预设的侦测协议；-I ：使用 ICMP 的方式来进行侦测； -T ：使用 TCP 来进行侦测，一般使用 port 80 测试-w ：若对方主机在几秒钟内没有回声就宣告不治…预设是 5 秒-p 埠号：若不想使用 UDP 与 TCP 的预设埠号来侦测，可在此改变埠号。-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了<br>-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个ppp，你可以使用 -i 来选择是 ppp0 还是 ppp1 啦！&gt;traceroute -n  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p>>traceroute -w 1 -n -T  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p><strong>host [-a] hostname [server]</strong> -a ：列出该主机详细的各项主机名设定数据<br>[server] ：可以使用非为 /etc/resolv.conf 的 DNS 服务器 IP 来查询。&gt;host <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 查询百度的服务器主机IP<strong>dig</strong>dig <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  查询百度的服务器主机IPiwlist  iwconfig无线设置命令,在设置无线网络时用过。telnet <strong>telnet [host|IP [port]]</strong><br>>telnet localhost 110<br>wgettcpdump封包撷取器<strong>tcpdump [-AennqX] [-i 接口] [-w 储存档名] [-c 次数] [-r 档案] [所欲撷取的封包数据格式]</strong>选项与参数：-A ：封包的内容以 ASCII 显示，通常用来捉取 WWW 的网页封包资料。-e ：使用资料连接层 (OSI 第二层) 的 MAC 封包数据来显示；-nn：直接以 IP 及 port number 显示，而非主机名与服务名称-q ：仅列出较为简短的封包信息，每一行的内容比较精简-X ：可以列出十六进制 (hex) 以及 ASCII 的封包内容，对于监听封包内容很有用-i  ：后面接要『监听』的网络接口，例如 eth0, lo, ppp0 等等的界面；-w ：如果你要将监听所得的封包数据储存下来，用这个参数就对了！后面接档名-r  ：从后面接的档案将封包数据读出来。那个『档案』是已经存在的档案，并且这个『档案』是由 -w 所制作出来的。-c  ：监听的封包数，如果没有这个参数， tcpdump 会持续不断的监听，直到使用者输入 [ctrl]-c 为止。</p>
<p>所欲撷取的封包数据格式：我们可以专门针对某些通讯协议或者是 IP 来源进行封包撷取， 那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有：</p>
<blockquote>
<p>‘host foo’, ‘host 127.0.0.1’ ：针对单部主机来进行封包撷取</p>
<p>‘net 192.168’ ：针对某个网域来进行封包的撷取；</p>
<p>‘src host 127.0.0.1’ ‘dst net 192.168’：同时加上来源(src)或目标(dst)限制</p>
<p>‘tcp port 21’：还可以针对通讯协议侦测，如 tcp, udp, arp, ether 等</p>
<p>还可以利用 and 与 or 来进行封包数据的整合显示呢！</p>
</blockquote>
<p>>tcpdump -i eth0 -nn</p>
<p>>tcpdump -i eth0 -nn  port 21</p>
<p>>tcpdump -i lo -nn -X  ‘port 21’</p>
<p>>tcpdump -i eth0 -nn ‘port 22 and src host 192.168.14.100’</p>
<h3 id="nc，netcat-接口监听"><a href="#nc，netcat-接口监听" class="headerlink" title="nc，netcat 接口监听"></a>nc，netcat 接口监听</h3><p><strong>nc [-lu] [IP|host] [port]</strong></p>
<p>-l ：作为监听之用，亦即开启一个 port 来监听用户的联机；-u ：不使用 TCP 而是使用 UDP 作为联机的封包状态 <img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/65ea43e2-e5ba-4e63-8cfc-78202b5b8c7a.png" alt="img"><br>server:<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/f1788bb8-dc26-4596-8817-744d3b358d83.png" alt="img"></p>
<p>client:<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/ef0bdf06-470b-4a92-a961-75b60c9381f4.png" alt="img">在客户端我们可以打入一些字，你会发现在服务器端会同时出现你输入的字眼吶！</p>
<p>端口与服务的启动/关闭及开机时状态设定1.最直接 kill -9 rpcbind  但是是强制关闭，会引起不确定因素。2.stand alone 方式服务<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/e2ae4e66-62c8-47cc-a373-5e9c24eb8102.png" alt="img"><br> rpc.statd 的启动脚本在：『rpm  -qc $(rpm  -qf $(which rpc.statd) ) | grep init』这样找，结果是在 /etc/rc.d/init.d/nfslock3.super daemon 方式服务要启动 telnet 首先必须要已经安装了 telnet 的服务器才行，先以 rpm 查询看看是否有安装 telnet-server『rpm -qa | grep telnet-server』<br>       如果没有安装的话，用『yum install telnet-server』安装；</p>
<ul>
<li>由于是 super daemon 控管，所以请编辑 /etc/xinetd.d/telnet 这个档案，将其中的『disable = yes』改成『disable = no』</li>
</ul>
<p>​     之后以『/etc/init.d/xinetd restart』重新启动 super daemon 吧！</p>
<ul>
<li>利用 netstat -tnlp 察看是否有启动 port 23 </li>
</ul>
<p><strong>将服务关闭，并设为开机不启动</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/941af9ae-ee2b-493b-9b37-65527f0cc782.png" alt="img"></p>
<hr>
<h3 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a><strong>防火墙</strong>：</h3><p>​      <strong>TCP Wrappers (程序控管) 通过**</strong>/etc/hosts.{allow|deny} 的设定方式，进行权限设定</p>
<p>​      <strong>Proxy (代理服务器）</strong></p>
<p>​      <strong>Netfilter (封包过滤机制)</strong> <strong>Netfilter 提供**</strong>了 iptables 这个软件来作为防火墙封包过滤的指令。</p>
<p>Linux 的 iptables 至少就有三个表格，包括管理本机进出的 filter 、管理后端主机 (防火墙内部的其他计算机) 的 nat 、管理特殊旗标使用的 mangle (较少使用 ) 常用的是本机的 filter 表格， 这也是默认表格啦<br>  filter (过滤器) ：主要跟进入 Linux 本机的封包有关，这个是预设的table 喔！</p>
<p>​     o  INPUT：主要与想要进入我们 Linux 本机的封包有关；</p>
<p>​     o  OUTPUT：主要与我们 Linux 本机所要送出的封包有关；</p>
<p>​    o  FORWARD：这个咚咚与 Linux 本机比较没有关系， 他可以『转递封包』到后端的计算机中，与下列 nat table 相关性较高。</p>
<p>  nat (地址转换) ：是 Network Address Translation 的缩写， 这个表格主要在进行来源与目的之 IP 或 port 的转换，与 Linux 本机较无关，主要与Linux 主机后的局域网络内计算机较有相关。</p>
<p>​     o  PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)</p>
<p>​    o  POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)</p>
<p>​     o  OUTPUT：与发送出去的封包有关</p>
<p>  mangle (破坏者) ：这个表格主要是与特殊的封包的路由旗标有关， 早期仅有 PREROUTING 及 OUTPUT 链，不过从 kernel 2.4.18 之后加入了 INPUT及FORWARD 链。 由于这个表格与特殊旗标相关性较高，所以像咱们这种单纯的环境当中，较少使用 mangle 这个表格。</p>
<p><strong>1.规则的观察与清除</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/7177f2fe-ee52-4c54-9b07-028616a45238.jpg" alt="9b983a51-8bdc-496e-b62d-357f05d50001.jpg"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/b8450685-cf84-4c07-b851-190d7684e4fe.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/05343c60-1e87-4f6b-9d04-f6ba42b39e76.jpg" alt="img"><br><strong>2.定义预设政策 (policy)</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/438112eb-7307-4ed4-a670-9ce84a8e00d7.jpg" alt="img"></p>
<p><strong>3.封包的基础比对：IP, 网域及接口装置</strong></p>
<p>iptables [-AI 链名] [-io 网络接口] [-p 协议] [-s 来源 IP/网域] [-d 目标 IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</p>
<p>选项与参数：</p>
<p>-AI 链名：针对某的链进行规则的 “插入” 或 “累加”</p>
<p>  -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，使用 -A 就可以加上第五条规则！</p>
<p>  -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。例如原本有四条规则，使用 -I 则该规则变成第一条，</p>
<p>​      而原本四条变成 2~5 号链 ：有INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。</p>
<p>-io 网络接口：设定封包进出的接口规范</p>
<p>  -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；</p>
<p>  -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；</p>
<p>  -p 协定：设定此规则适用于哪种封包格式，主要的封包格式有： tcp, udp, icmp 及 all 。</p>
<p>-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：</p>
<blockquote>
<p>IP  ：192.168.0.100</p>
<p>网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。</p>
<p>若规范为『不许』时，则加上 ! 即可，例如：</p>
<p>-s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；</p>
</blockquote>
<p>-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。</p>
<p>-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/702693c5-4944-4947-9f62-d46c5301caff.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/32d6e73a-09cd-44b5-846d-6fd9f251857e.png" alt="img"></p>
<p><strong>4.TCP, UDP 的规则比对：针对埠口设定
</strong></p>
<p>iptables [-AI 链] [-io 网络接口] [-p tcp,udp] [-s 来源 IP/网域] [–sport 埠口范围] [-d 目标 IP/网域] [–dport 埠口范围] -j [ACCEPT|DROP|REJECT] </p>
<p>选项与参数：–sport 埠口范围：限制来源的端口口号码，端口口号码可以是连续的，例如1024:65535–dport 埠口范围：限制目标的端口口号码。因为仅有 tcp 与 udp 封包具有埠口，因此你想要使用 –dport, –sport 时，得要加上 -p tcp 或 -p udp 的参数才会成功喔<img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/bdc40c07-dbb5-49af-b3b0-6d1971f3c00d.png" alt="img"><br>只要来自 192.168.1.0/24 的 1024:65535 埠口的封包，且想要联机到本机的 ssh port 就予以抵挡：&gt;iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24  –sport 1024:65534 –dport ssh -j DROP</p>
<p>将来自任何地方来源 port 1:1023 的主动联机到本机端的 1:1023 联机丢弃</p>
<p>>iptables -A INPUT -i eth0 -p tcp –sport 1:1023 –dport 1:1023 –syn -j DROP </p>
<p><strong>5.iptables 外挂模块：mac 与 state</strong><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/77bcb250-b0fa-4961-9af2-420e559b741a.png" alt="img"></p>
<p>范例：只要已建立或相关封包就予以通过，只要是不合法封包就丢弃</p>
<p>> iptables -A INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT</p>
<p>> iptables -A INPUT -m state –state INVALID -j DROP</p>
<p>范例：针对局域网络内的 aa:bb:cc:dd:ee:ff 主机开放其联机</p>
<p>> iptables  -A INPUT  -m mac  –mac-source aa:bb:cc:dd:ee:ff -j ACCEPT</p>
<p>选项与参数：</p>
<p>–mac-source ：就是来源主机的 MAC 啦！</p>
<p><strong>6.ICMP 封包规则的比对：针对是否响应 ping 来设计</strong><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/6f057fe4-1127-4e5d-be61-a733e5101b2d.jpg" alt="img"></p>
<p><strong>7.简单的客户端防火墙设计与防火墙规则储存</strong><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/cb1dc68f-7931-4923-b7eb-6afb5df50a32.jpg" alt="img"></p>
<hr>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a><strong>SSH</strong></h3><p>SSH 是 Secure  SHell protocol 的简写 (安全的壳程序协议)，它可以透过数据封包加密技术，将等待传输的封包加密后再传输到网络上。取代了明码传输的telnet技术。<br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/3b4426d0-ad39-42ca-8dc7-8cf835a0a022.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/4becbb44-d79b-4b96-85c6-73ac4afb4c16.jpg" alt="img"></p>
<p>>ssh <a href="mailto:student@127.0.0.1" target="_blank" rel="noopener">student@127.0.0.1</a> find / &amp;&gt; ~/find1.log  执行后需要等待</p>
<p>>ssh -f <a href="mailto:student@127.0.0.1" target="_blank" rel="noopener">student@127.0.0.1</a> find / &amp;&gt; ~/find1.log  加上 -f 的参数可以将指令后台执行而立马断开联机</p>
<p>>ssh -o StrictHostKeyChecking=no root@localhost</p>
<p>>ssh -f root@some_IP shutdown -h now  不用等待关机后退出，直接断开连接。</p>
<h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p>模拟 FTP 的文件传输方式，使用 ssh 的通道 (port 22)，只是模拟成 FTP 与复制的动作而已。<br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/5a8f0d34-770e-4b00-a675-e34efb54e82d.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/8668cca1-18ca-4d8f-9c83-be542b0d34a7.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/e23af27d-6fc3-47e9-9f40-e9c3da21cdcc.png" alt="img"><br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/000c8821-76fd-4457-8ee8-785a47548f0a.jpg" alt="img"></p>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>档案异地直接复制，通常使用 sftp 是因为可能不知道服务器上面有什么档名的档案存在，如果已经知道服务器上的档案档名了，  那么最简单的文件传输则是透过 scp 这个指令喔！最简单的 scp 用法如下：<br><img src="/2015/Linux/鸟哥的Linux私房菜/网络防火墙SSH/3f8cd937-351d-4890-8abe-6dde583910ab.png" alt="img"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解压缩</title>
    <url>/2014/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>*.tar.gz    tar 程序打包的档案，其中并且经过 gzip的压缩</p>
<p>*.tar.bz2   tar 程序打包的档案，其中并且经过 bzip2 的压缩</p>
<p>gzip -v man.config 压缩 man.config 生成 man.config.gz,源文件没有了。</p>
<p>gzip -d man.config.gz 解压缩 man.config.gz </p>
<p>gzip -9 -c man.config &gt; man.config.gz  -9等级，1-9,1最快，9最慢 -c重定向</p>
<p>-—–<br>bzip2 -z  -k man.config   -z 压缩 -k 保留原文件</p>
<p>bzip2 -d man.config.bz2  -d解压缩</p>
<p>bzip2 -9 -c man.config &gt; man.config.bz2<br>-——</p>
<p>j代表bzip2软件 z代表gzip软件  c 创建 t 查询 x 解压</p>
<p>-p  ：保留备份数据癿原本权限不属性，常用于备份(-c)重要癿配置文件</p>
<p>-P (大写) ：保留绝对路径，亦即允讲备份数据中吨有根目录存在之意，一般不用；</p>
<p>–exclude=FILE 压缩式不包含FILE</p>
<p>bzip2</p>
<p>压缩：tar -jcv -f aa.tar.bz2  /usr</p>
<p>查询：tar -jtv -f aa.tar.bz2</p>
<p>解压缩：tar -jxv -f aa.tar.bz2 -C  /tmp</p>
<p><strong>gzip</strong></p>
<p><strong>压缩：tar -zcv -f  /root/aa.tar.gz  /etc    将/etc中文件压缩成/root下的aa.tar.gz</strong></p>
<p><strong>查询：tar -ztv -f aa.tar.gz</strong></p>
<p><strong>解压缩：tar -zxv -f aa.tar.gz  -C /tmp    将 aa.tar.gz解压到/tmp中</strong></p>
<p>打包</p>
<p>tar -cv -f /backup  /home /root /etc  将/home /root /etc打包到/backup  </p>
<p>tar -cvf - /etc|tar -xvf -              打包/etc复制到当前目录</p>
<p>dd if=”input_file” of=”out_file” bs=”block_size” count=”number” </p>
<p>bs默认为512 bytes（一个sector的大小）</p>
<p>dd  -if=/dev/zero  -of=/boot/testing.img  bs=1M  count=10</p>
<p>dd if=/etc/passwd of=/tmp/passwd.back 将 /etc/passwd 备份到 /tmp/passwd.back 当中</p>
<p>dump 可备份文件系统或单一目录，在备份目录时不能用level和-u更新时间</p>
<p>dd 可备份完整分区或磁盘，因为 dd 可读取磁盘的 sector 表面数据</p>
<p>cpio 为相当优秀的备份指令，不过必项要搭配类似 find 指令来读入欲备份的文件名数据，方可进行备份动作。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>BASH和SHELL编程</title>
    <url>/2015/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/BASH%E5%92%8CSHELL%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>查询/etc/shells 获取本系统支持的shell：</p>
<p>/bin/sh  ——&gt;/bin/bash（Linux预设的shell）</p>
<p>/bin/csh ——&gt;/bin/tcsh（整合C Shell ，提供更多的功能）</p>
<p>/bin/ksh ——&gt;/bin/zsh（基于 ksh发展出来的，功能更强大的 shell）</p>
<p><strong>type</strong></p>
<p>type [-ta] 指令名称  （查询指令是外部指令还是内建在bash中的指令，只查询指令，找不到不显示，<strong>相当于which查询</strong>）</p>
<p>   -t  显示指令类别，file外部指令 alias 别名 builtin 内建指令</p>
<p>   -a  会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含alias</p>
<p>>type ls</p>
<p>>type  -t  ls</p>
<p>>type  -a ls</p>
<p><strong>env</strong> 显示环境变量内容</p>
<p><strong>set</strong> 显示bash内置变量</p>
<p>PS1（命令提示字符的设定） [root@www ~]#</p>
<p>man bash 查询各个版本的默认设置，set也显示出来。</p>
<p>PS1 的相关说明，以理解底下的一些符号意义。</p>
<blockquote>
<p>o  \d ：可显示出『星期 月 日』的日期格式，如：”Mon Feb 2”</p>
<p>o  \H ：完整的主机名。举例来说，鸟哥的练习机为『<a href="http://www.vbird.tsai』" target="_blank" rel="noopener">www.vbird.tsai』</a></p>
<p>o  \h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略</p>
<p>o  \t ：显示时间，为 24 小时格式的『HH:MM:SS』</p>
<p>o  \T ：显示时间，为 12 小时格式的『HH:MM:SS』</p>
<p>o  \A ：显示时间，为 24 小时格式的『HH:MM』</p>
<p>o  \@ ：显示时间，为 12 小时格式的『am/pm』样式</p>
<p>o  \u ：目前使用者的账号名称，如『root』； </p>
<p>o  \v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示</p>
<p>o  \w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；</p>
<p>o  \W ：利用 basename 凼数取得工作目录名称，所以仅会列出最后一个目录名。</p>
<p>o  # ：下达的的第几个指令。</p>
<p>o  \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～</p>
</blockquote>
<p>PS1=’[\u@\h \W]\$ ‘</p>
<p>PS1=’[\u@\h \w \A ##]\$ ‘</p>
<p> echo $$  显示PID号码</p>
<p> echo $?  显示上个指令的回传值</p>
<p><strong>export</strong> 变量名称（将自定义变量变为环境变量，子程序也可使用，不加变量名称则全部转换）</p>
<p>>read -p “Please keyin your name:” -t 30 named</p>
<p>>declare -i sum=100+300+50  整数</p>
<p>>declare -a arr  数组</p>
<p>>declare -x sum 转为环境变量</p>
<p>>declare -r  sum 转为只读变量</p>
<p>>var[1]=”small min”</p>
<p>>var[2]=”big min”</p>
<p>>echo “${var[1]},${var[2],$var[3]}”</p>
<p><strong>ulimit</strong></p>
<p>ulimit -a         显示全部限制</p>
<p>ulimit -f 10240    用户只能建立的最大文件为10240kb</p>
<p><strong>PATH删除和替换</strong></p>
<p>echo ${path#/*fforever/bin:}  删除/到fforever/bin:符合条件的最短字符</p>
<p>echo ${path##/*:}           删除/到 : 符合条件的最长字符</p>
<p>echo ${path%:*bin}         从后面开始删除 : 到bin符合条件的最短字符</p>
<p>echo ${path%%:*bin}        从后面开始删除 : 到bin符合条件的最长字符</p>
<p>echo ${path/sbin/SBIN}      将两个/之间的sbin替换为SBIN，最短替</p>
<p>echo ${path//sbin/SBIN}     将三个/之间的sbin替换为SBIN，最长替代</p>
<p><strong>变量测试和内容替换</strong></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/7e18cee8-4f63-46d8-b35b-a61f396487c3.png" alt="img"></p>
<p><strong>alias</strong></p>
<p>alias 显示全部别名</p>
<p>alias lm=’ls -al|more’</p>
<p>alias rm=’rm -i’</p>
<p>unalias lm</p>
<p><strong>history</strong></p>
<p>>history [n]</p>
<p>>history [c]  清除</p>
<p>>history [arw]  -a将新增指令加到histfiles中</p>
<p>​              -r将histfiles指令加到history内存中</p>
<p>​              -w将内存中指令写入histfiles中</p>
<p>>!66        执行第66条指令</p>
<p>>!!         执行上一个指令</p>
<p>>!al        执行以al开头的指令</p>
<p><strong>指令运作的顺序可以这样看：</strong></p>
<p>\1.  手动输入以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</p>
<p>\2.  由 alias 找到该指令来执行；</p>
<p>\3.  由 bash 内建的 (builtin) 指令来执行；</p>
<p>\4.  透过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。</p>
<p>/etc/issue /etc/issue.net(网络登录)  切换到tty命令窗口时的提示信息</p>
<p>man issue或man mingetty查询配置变量</p>
<blockquote>
<p>\d 本地端时间的日期；</p>
<p>\l 显示第几个终端机接口；</p>
<p>\m 显示硬件的等级 (i386/i486/i586/i686…)；</p>
<p>\n 显示主机的网络名称；</p>
<p>\o 显示 domain name；</p>
<p>\r 操作系统的版本 (相当亍 uname -r)</p>
<p>\t 显示本地端时间的时间；</p>
<p>\s 操作系统的名称；</p>
<p>\v 操作系统的版本。</p>
</blockquote>
<p><strong>/etc/motd  登陆后的提示信息</strong></p>
<p><strong>login shell 加载配置</strong></p>
<p>1./etc/profile 整体设定</p>
<p>2.~/.bash_profile &gt;~/.bash_login &gt; ~/.profile  有优先级高的，则加载他之后不再加载后面得。</p>
<p><strong>non-login shell加载配置</strong></p>
<p>~/.bashrc</p>
<p>>source ~/.bashrc  &lt;==底下这两个指令是一样的！</p>
<p>> . ~/.bashrc</p>
<p><strong>数据流重导向</strong></p>
<p>\1.  标准输入  (stdin) ：    代码为 0 ，使用 &lt; 或 &lt;&lt;  </p>
<p>\2.  标准输出  (stdout)：   代码为 1 ，使用 &gt; 或 &gt;&gt; </p>
<p>\3.  标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;  </p>
<p>其中一个符号位<strong>覆盖</strong>，两个符号位<strong>累加</strong></p>
<p>>ls -al / &gt; ~/rootfile</p>
<p>>find /home -name .bashrc  &gt;list_right  2&gt;list_error</p>
<p>>find /home -name .bashrc  2&gt; /dev/null  忽略错误信息</p>
<p>>find /home -name .bashrc  &gt; list  2&gt;&amp;1   正确与错误数据都输入到list </p>
<p>>find /home -name .bashrc  &amp;&gt; list       正确与错误数据都输入到list </p>
<p>>cat &gt; catfile &lt; ~/.bashrc  将.bashrc的内容输入到catfile</p>
<p>>cat &gt; catfile &lt;&lt; “eof”     输入catfile，输入eof时结束</p>
<table>
<thead>
<tr>
<th>cmd1 ; cmd2</th>
<th>不考虑指令相关性的连续指令下达</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd1 &amp;&amp; cmd2</td>
<td>1. 若 cmd1 执行完毕且正确执行($?=0)，则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错误 ($?≠0)，则 cmd2 不执行。</td>
</tr>
<tr>
<td>cmd1 \</td>
<td>\</td>
<td>cmd2</td>
<td>1. 若 cmd1 执行完毕且正确执行($?=0)，则 cmd2 不执行。 2. 若 cmd1 执行完毕且为错误 ($?≠0)，则开始执行 cmd2</td>
</tr>
</tbody>
</table>
<p>指令不执行时，前面指令的执行状态传到后面的指令</p>
<p>cmd1 || amd2 &amp;&amp; cmd3</p>
<p>1成功，2不执行，1成功状态传到3,3执行</p>
<p>1失败，2执行，2成功，3执行</p>
<p>1失败，2执行，2失败，3不执行</p>
<p>> ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</p>
<p>cmd1 &amp;&amp; amd2 || cmd3</p>
<p>1成功，2执行，2成功，3不执行</p>
<p>1成功，2执行，2失败，3执行</p>
<p>1失败，2不执行，1失败状态传到3,3执行</p>
<p>> ls /tmp/vbirding &amp;&amp; echo “exist” || echo “not exist”</p>
<p><strong>撷取指令</strong></p>
<p><strong>cut（对一行中的字段进行分割，</strong>cut 在处理多空格相连的数据时，不大准确<strong>）</strong></p>
<p>>echo $PATH | cut -d ‘:’ -f 3，5    将path变量用“：”分割，取得第3段和第5段</p>
<p>>export | cut  -c  12-             取得第12个字符后的字符串</p>
<p><strong>grep(整篇文章中取得带关键词的那一行)</strong></p>
<p>grep [-cinv] ‘搜寻字符串’ filename</p>
<blockquote>
<p>-c ：计算找到 ‘搜寻字符串’ 的次数</p>
<p>-i ：忽略大小写的不同，所以大小写规为相同</p>
<p>-n ：顺便输出行号</p>
<p>-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容得那一行！</p>
<p>-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；</p>
<p>-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；</p>
<p>–color=auto 可将正确的那个撷取数据列出颜色</p>
</blockquote>
<p>>last|grep ‘root’</p>
<p>> last | grep ‘root’ |cut -d ‘ ‘ -f 1</p>
<p>>dmesg | grep -n -A3 -B2 –color=auto ‘eth’</p>
<p><strong>sort  [-fbMnrtuk] [file or stdin]</strong></p>
<p>​     -f  ：忽略大小写的差异，例如 A 不 a 规为编码相同；</p>
<blockquote>
<p>-b  ：忽略最前面的空格符部分；</p>
<p>-M  ：以月份的名字杢排序，例如 JAN, DEC 等等的排序方法；</p>
<p>-n  ：使用『纯数字』进行排序(默认是以文字型态来排序的)； </p>
<p>-r  ：反向排序；</p>
<p>-u  ：就是 uniq ，相同的中，仅出现一行代表；</p>
<p>-t  ：分隔符，预设是用 [tab] 键来分隔；</p>
<p>-k  ：以那个区间 (field) 来进行排序的意思</p>
</blockquote>
<p>>cat /etc/passwd|sort -t ‘ ‘ -k 3 -n</p>
<p><strong>uniq</strong></p>
<blockquote>
<p>-i  ：忽略大小写字符的不同；<br>-c  ：进行计数</p>
</blockquote>
<p>>last | cut -d ‘ ‘ -f 1 | sort | uniq  都有谁登陆</p>
<p>>last | cut -d ‘ ‘ -f 1 | sort | uniq -c 每个人的登陆次数</p>
<p><strong>wc</strong></p>
<blockquote>
<p>-l  ：仅列出行；<br>-w  ：仅列出多少字(英文单字)；<br>-m  ：多少字符；</p>
</blockquote>
<p>>last | grep [a-zA-Z] | grep -v ‘wtmp’ | wc -l</p>
<p><strong>tee ：双向重导向（将数据保存到文件，同时也在屏幕显示）</strong></p>
<p>  -a 累加</p>
<p>>ls -l /home | tee ~/homefile | more</p>
<p><strong>xargs</strong></p>
<p> 找出 /sbin 底下具有特殊权限的档名，并使用 ls -l 列出详细属性</p>
<p>由于ls不支持管线命令所以</p>
<p>find /sbin -perm +7000 | ls -l  不正确</p>
<p>find /sbin -perm +7000 | xargs ls -l  正确</p>
<p><strong>减号 - 的用途</strong>，前面stdout作为后面的stdin，则前后可用 - 代替</p>
<p>>tar -cvf - /home | tar -xvf -</p>
<p> cp, ls 不支持正则表达式，只能用通配符</p>
<p> vim grep sed awk 支持正则表达式</p>
<p><strong>正则表达式</strong></p>
<p>利用中括号 [] 来搜寻集合字符</p>
<p>>grep -n ‘t[ae]st’ regular_express.txt</p>
<p>>grep -n ‘oo’ regular_express.txt</p>
<p>>grep -n ‘[^g]oo’ regular_express.txt</p>
<p>>grep -n ‘[^a-z]oo’ regular_express.txt  = grep -n ‘[^[:lower:]]oo’ regular_express.txt</p>
<p>> grep -n ‘[0-9]’ regular_express.txt  =  grep -n ‘[[:digit:]]’ regular_express.txt</p>
<p>行首与行尾字符 ^ $</p>
<p>>grep -n ‘^the’ regular_express.txt   –the只出现在行首</p>
<p>>grep -n ‘^[a-z]’ regular_express.txt  =  grep -n ‘^[[:lower:]]’ regular_express.txt  –行首只是小写字母</p>
<p>>grep -n ‘^[^a-zA-Z]’ regular_express.txt  =  grep -n ‘^[^[:alpha:]]’ regular_express.txt  –开头不是字母</p>
<p>>ls -l /etc | grep ‘^l’ | wc -l  –找到链接文件并计数</p>
<p><strong>那个 ^ 符号，在字符集合符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！</strong></p>
<p>>grep -n ‘.$’ regular_express.txt  –行尾结束为小数点’.’</p>
<p>>grep -n ‘^$’ regular_express.txt  –空白行 </p>
<p>>grep -v ‘^$’ /etc/syslog.conf | grep -v ‘^#’  非空白行非以#开头的行</p>
<p>任意一个字符 . 不重复字符 *</p>
<p>. (小数点)：代表『一定有一个任意字符』的意思；</p>
<p>* (星星号)：代表『重复前一个RE字符 0 到无穷多次』的意思，为组合形态， 重复前一个RE字符为0次则为空字符。</p>
<p>>grep -n ‘g..d’ regular_express.txt  –共有四个字符， 起头是 g 而结束是 d  等于通配符中 g??d</p>
<p>>grep -n ‘ooo<em>‘ aaa.txt   –至少两个o以上的字符串，前两个o固定，肯定有，后面“o</em>”为正则表达式，表示0个或任意个o</p>
<p>>grep -n ‘goo*g’ regular_express.txt  – 包含 gog, goog, gooog….的字符</p>
<p>>grep -n ‘g.<em>g’ regular_express.txt  –.</em> 就代表零个或多个任意字符 ，以g开头，以g结尾的字符</p>
<p>>grep -n ‘[0-9][0-9]*’ regular_express.txt  =  grep -n ‘[0-9]’ regular_express.txt –包含数字的行</p>
<p>限定连续 RE 字符范围 {}，\转义</p>
<p>>grep -n ‘o{2}‘  regular_express.txt  –两个 o 的字符串</p>
<p>>grep -n ‘go{2,5}g’ regular_express.txt  –g后接2到5个o</p>
<p>>grep -n ‘go{2,}g’ regular_express.txt = grep -n ‘gooo*g’ regular_express.txt  –g后接两个以上o</p>
<p>正则表达式：<em>代表重复前面字符0到任意次，.代表任意一个字符    ls | grep -n ‘^a.</em>‘      grep支持正则表达式    </p>
<p>通配符：    <em>代表任意字符，？代表任意一个字符              ls -l a</em>  以a开头的文件   ls不支持正则表达式，用通配符</p>
<p><strong>sed  通常处理段落中的行</strong></p>
<p>   -n  安静模式</p>
<p>   -i  直接修改文件，不在屏幕输出</p>
<p>  -e  编辑模式 sed后面两个以上动作时，要加-e,其余可省略</p>
<p>>nl /etc/passwd | sed ‘2,5d’ 删除2-5行</p>
<p>>nl /etc/passwd | sed ‘2a drink tea’ 第二行后添加drink tea</p>
<p>>nl /etc/passwd | sed ‘2i drink tea’ 第二行前添加drink tea</p>
<p>>nl /etc/passwd | sed ‘2,5c  NO 2-5 number’  将2-5行替换成NO 2-5 number</p>
<p>>nl /etc/passwd | sed -n ‘5,7p’ 显示5-7行数据</p>
<p><strong>sed ‘s/要被取代的字符串/新的字符串/g’</strong></p>
<p>>/sbin/ifconfig eth0 | grep ‘inet addr’ |sed ‘s/^.<em>addr://g’ |sed ‘s/Bcast.</em>$//g’  <strong><del>inet addr:</del>192.168.1.100~~ Bcast:192.168.1.255 Mask:255.255.255.0~~</strong></p>
<p>>sed -i ‘s/.$/!/g’ regular_express.txt  直接使用sed对文件修改</p>
<p>>sed -i ‘$a # This is a test’ regular_express.txt  最后一行加入『# This is a test』</p>
<p><strong>awk 处理一行中的字段</strong></p>
<p>awk ‘条件类型 1{动作 1} 条件类型 2{动作 2} …’ filename</p>
<p>>last -n 5 | awk ‘{print $1 “\t” $3}’  –输出第一列第三列，中间[tab]隔开。</p>
<p><strong>$0整行 $1第一列  $2 第二列。。。</strong></p>
<p><strong>NF  每一行拥有的字段总数</strong></p>
<p><strong>NR  目前 awk 所处理的是『第几行』数据</strong></p>
<p><strong>FS  目前的分隔字符，默认是空格键</strong></p>
<p>>last -n 5| awk ‘{print $1 “\t lines: “ NR “\t columes: “ NF}’</p>
<p>>cat /etc/passwd | awk ‘BEGIN {FS=”:”} $3&lt;10 {print $1 “\t” $3}’</p>
<p><strong>diff</strong> 比对文本文件中的行，目录</p>
<p><strong>cmp</strong> 比对字节，二进制文件</p>
<p>获得IP</p>
<p>>ifconfig eth0 | grep ‘inet addr’ | sed ‘s/^.*inet addr://g’ | cut -d ‘’ -f 1</p>
<p>shell scripts执行方式：</p>
<p>以子bash执行：</p>
<p>​       直接指令下达： shell.sh 档案必须要具备可读不可执行 (rx) 的权限，然后： </p>
<blockquote>
<p>绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；<br>相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来执行<br>变量『PATH』功能：将 shell.sh 放在 PATH 指定的目录内例如： ~/bin/，输入文件名shell.sh为当成指令，会自动到PATH内寻找</p>
</blockquote>
<blockquote>
<p>  以 bash 程序来执行：透过『 bash shell.sh 』或『 sh shell.sh 』来执行，  sh为bash的链接文件。</p>
</blockquote>
<p>在父bash中执行：</p>
<p>​     使用 source 来执行指令 source sh02.sh，shell script中局部变量在父bash中也可调用。</p>
<p>script debug</p>
<p>>sh [-nvx] scripts.sh</p>
<blockquote>
<p>-n ：不要执行 script，仅查询语法的问题；<br>-v ：再执行 sccript 前，先将 scripts 的内容输出到屏幕上；<br>-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！</p>
</blockquote>
<hr>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/b5e93964-02d8-431f-83dd-68b1d9c184a6.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/c4c5e72f-6355-43a0-8ab9-688c43ba7a0d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/8850c093-6fd4-4f24-8c4f-32271eb112f9.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/6eb7bc33-740d-4830-95b3-1fac455a4fdb.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/1395e434-47a7-463c-a2c5-88819a45e5de.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/ab5f29c1-f564-4edb-94ee-179c70993ce8.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/5f976daf-a252-41a7-a8db-99ebcaae47be.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/2cb27e66-ee79-4e69-b8a2-22eccac5191d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/c4278aa1-3607-4c2c-8b06-0c8f93f7796d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/c64dc72f-5d79-415d-a59c-7dd9d00c945d.jpg" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/77f497b8-1ea0-4d22-a8e3-ee683bcf98ea.png" alt="img"></p>
<p><img src="/2015/Linux/鸟哥的Linux私房菜/BASH和SHELL编程/8a62e109-e5db-4572-bb85-572d1b8dc570.png" alt="img"></p>
<p><strong>分割区块</strong></p>
<p>1.新建 </p>
<p>  sp   split  new   上下</p>
<p>  vsp  vsplit  vnew  左右</p>
<p>  close only qall wall wqall</p>
<p>2.切换选框</p>
<p>  ctrl w w   ctrl w跳脱所有按键，在按w键选择</p>
<p>​          t</p>
<p>  crtl w  h j k  l</p>
<p>​          b</p>
<p>3.移动选框  调整位置</p>
<p>  crtl w  HJKL   </p>
<p>  2竖——&gt;2横  ctrl w  J/K    </p>
<p>  2横——&gt;2竖  ctrl w  H/L</p>
<p>4.调整大小</p>
<p>  nsplit     n行的框  </p>
<p>  n ctrl w +  增加n行</p>
<p>  n ctrl w -  减少n行</p>
<p>5.：all 为每个打开一个窗口</p>
<p><strong>DOS 与 Linux 的断行字符转换</strong><br>DOS  ^M$  CRLR</p>
<p>Linux  $     LR</p>
<p>>dos2unix [-kn] file [newfile]</p>
<p>>unix2dos [-kn] file [newfile]</p>
<blockquote>
<p>-k ：保留该档案原本的 mtime 时间格式 (不更新档案上次内容经过修订的时间)<br>-n ：保留原本的旧档，将转换后的内容输出到新档案，如： dos2unix -n old new</p>
</blockquote>
<p>>unix2dos -k man.config</p>
<p>>dos2unix -k -n man.config man.config.linux</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>鸟哥的Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>WOL-远程唤醒-FRP</title>
    <url>/2021/network/WOL/WOL-%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92-FRP/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>VPS（具有公网IP），配置了fprs服务。</li>
<li>路由器可安装frpc插件,我是用的华硕ac86u</li>
<li>申请了域名 ，例如aaa.com，并配置DDNS域名解析：  <strong>aaa.com-&gt; vps IP</strong></li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>路由器没有公网IP，需要vps转发数据。唤醒端在外网通过域名请求vps 9号端口，vps将开机命令包通过udp协议转发给路由器所在局域网的 192.168.50.255（广播地址，此广播地址根据192.169.50.1路由器IP算出来的掩码），遍历mac地址相同的机器，发送到该机器的9号端口，进行开机。</p>
<h2 id="Windows系统唤醒"><a href="#Windows系统唤醒" class="headerlink" title="Windows系统唤醒"></a>Windows系统唤醒</h2><h3 id="被唤醒端配置"><a href="#被唤醒端配置" class="headerlink" title="被唤醒端配置"></a>被唤醒端配置</h3><ol>
<li><p>设置技嘉主板BIOS的Erp选项为disable，启动远程开机的功能。其他主板配置不同，参阅百度或者说明手册。</p>
</li>
<li><p>设置windows系统支持远程开机启动<br>设置网卡，选择当前使用的网卡，右键网卡属性，在“网络”tab页点击配置。</p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/image-20210406091402158.png" alt="image-20210406091402158" style="zoom: 67%;"></p>
<p>在 <strong>高级</strong> 菜单中的属性找到 <strong>唤醒魔包</strong> (Wake on Magic Packet) 设置为 <strong>启用</strong></p>
</li>
</ol>
<p>   <img src="/2021/network/WOL/WOL-远程唤醒-FRP/clip_image002.jpg" alt="IMG_258" style="zoom:50%;"></p>
<p>   在 <strong>电源管理</strong> 中 勾选 <strong>允许此设备唤醒计算机</strong></p>
<p>   <img src="/2021/network/WOL/WOL-远程唤醒-FRP/clip_image004.jpg" alt="IMG_259" style="zoom:50%;"></p>
<h3 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h3><ol>
<li>用vps进行开机udp命令包转发，需要在路由器中安装frpc插件，设置frpc内网穿透配置；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wol]</span><br><span class="line">type = udp  #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255  #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9 #一般采用这个端口进行wol</span><br><span class="line">remote_port = 9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将mac地址和IP地址进行绑定</li>
</ol>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/clip_image002b.jpg" alt="IMG_260"></p>
<h3 id="唤醒端配置"><a href="#唤醒端配置" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h3><p><strong>远程唤醒</strong>Android端下载WOL软件，可以通过手机唤醒</p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_09-42-52.png" alt="Snipaste_2021-04-06_09-42-52"></p>
<p><strong>局域网唤醒</strong></p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_09-45-52.png" alt="Snipaste_2021-04-06_09-45-52"></p>
<h2 id="NAS系统唤醒"><a href="#NAS系统唤醒" class="headerlink" title="NAS系统唤醒"></a>NAS系统唤醒</h2><h3 id="被唤醒端配置-1"><a href="#被唤醒端配置-1" class="headerlink" title="被唤醒端配置"></a>被唤醒端配置</h3><ol>
<li><p>改为设置主板华擎J4105的BIOS和NAS系统，NAS开机进入BIOS后，</p>
<p>选择Advanced -&gt; Chipset Configuration</p>
<p>Onboard LAN 设置为enable，启动网卡<br>Enable or disable the onboard network interface controller.</p>
<p>PCIE1 Link Speed<br>Select the link speed for PCIE1.</p>
<p>Deep S5 (设置系统的休眠级别，可能有关系，改小试试)<br>Configure deep sleep mode for power saving when the computer is shut down.</p>
<p>选择Advanced -&gt; ACPI Configuration</p>
<p>PCIE Device Power On 设置为 enable<br>Allow the system to be waked up by a PCIE device and enable wake on LAN.</p>
<p><strong>Boot From Onboard LAN设置为enable</strong><br><strong>Allow the system to be waked up by the onboard LAN.</strong></p>
</li>
<li><p>NAS系统暂未发现设置项，可能不需要设置</p>
</li>
</ol>
<h3 id="路由器端配置"><a href="#路由器端配置" class="headerlink" title="路由器端配置"></a>路由器端配置</h3><ol>
<li>用vps进行开机udp命令包转发，需要在路由器中安装frpc插件，设置frpc内网穿透配置；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wol]</span><br><span class="line">type = udp  #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255  #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9 #一般采用这个端口进行wol</span><br><span class="line">remote_port = 9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>将NAS的mac地址和IP地址进行绑定<br><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-05-49.png" alt="Snipaste_2021-04-06_10-05-49"></p>
<h3 id="唤醒端配置-1"><a href="#唤醒端配置-1" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h3></li>
</ol>
<p><strong>远程唤醒</strong></p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-07-15.png" alt="Snipaste_2021-04-06_10-07-15"></p>
<p><strong>局域网唤醒</strong></p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-07-37.png" alt="Snipaste_2021-04-06_10-07-37"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>WOL</category>
      </categories>
      <tags>
        <tag>WOL</tag>
        <tag>内网穿透</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>WOL-远程唤醒-ARP绑定</title>
    <url>/2021/network/WOL/WOL-%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92-ARP%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>如果路由器具有公网IP，可以不需要VPS转发WOL数据包，直接在外网连接路由器发送WOL数据包，进行远程唤醒。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li><p>域名设置DDNS  <strong>aaa.com -&gt; 路由器公网IP</strong></p>
</li>
<li><p>windows系统设置了允许WOL的配置，可参考以前文章。</p>
</li>
<li><p>路由器设置了端口转发，如下：</p>
<p>外部9000端口转发到192.168.50.100的9号端口；外部9001端口转发到192.168.50.123的9号端口</p>
</li>
</ol>
<p><img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/dkzf.png" alt="dkzf"></p>
<ol start="4">
<li>路由器设置IP和mac地址绑定，<strong>内网wol可以不设置地址绑定, 外网wol必须设置地址绑定</strong>，如下：</li>
</ol>
<p><img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/bd.png" alt="bd"></p>
<p>数据流转：<br>   外网WOL：唤醒端在外网9000号端口发起请求-&gt;路由器端口映射-&gt;192.168.50.100:9 -&gt;查询绑定的mac地址的机器，然后启动。<strong>和frp远程访问不同（frpc配置广播地址，不需要设置端口转发）</strong></p>
<p>   内网WOL：使用广播地址192.168.50.255 和mac地址进行广播，找到mac地址相同的进行启动。frp原理和此相同。</p>
<p>遇到问题是，不能每次都唤醒，所以需要ARP绑定。</p>
<h2 id="何为-ARP-绑定"><a href="#何为-ARP-绑定" class="headerlink" title="何为 ARP 绑定"></a>何为 ARP 绑定</h2><p>华硕路由器居然连 ARP 绑定功能都没有。这里要区别一下，在客户端列表中开启 <code>MAC地址与IP绑定</code> 其实仅仅是 DHCP 绑定，它可以保证每次给相同设备总是分配同一个 IP 地址，但<strong>前提是设备必须请求IP！</strong></p>
<p>我们知道路由器内部会维护一个 ARP 表，记录 IP 与 MAC 的关系，每当设备请求 IP 时便会被记录，其超时时间因具体设置而不同。因此当设备长时间不在线（比如关机）时吗，ARP 记录就会失效，从而无法再通过 IP 给此设备发送数据。</p>
<p>有一个典型需求：PC需要 WOL 网络唤醒。因此我们要进行 <strong>ARP 绑定</strong>，与 DHCP 绑定不同，ARP 绑定相当于把 IP 对应关系写死在表里，无论设备是否在线。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>ssh 或 telnet 登录路由器，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -s [IP] [MAC]</span><br></pre></td></tr></table></figure>
<p>就搞定了。</p>
<p>但是这样每次重启都会失效，我们需要通过自启脚本来手动添加 ARP 项，因此官方固件是不行的，先刷梅林，使用putty连接到路由器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /jffs/scripts/ <span class="comment"># 进入脚本目录</span></span><br><span class="line">vi services-start <span class="comment"># 打开编辑器（你也可以用其他编辑器）</span></span><br></pre></td></tr></table></figure>
<p>将文件内容改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">arp -s [IP] [MAC]</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p>保存，最后给予执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+rx /jffs/scripts/*</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证ARP绑定无误也非常简单，上面步骤做完以后，重启一下路由器，putty连接路由器，直接输入<code>arp</code> 查看 ARP 表，对应项目如果标识有 <code>[PERM]</code> 就是已经绑定了。</p>
<p><img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_12-57-38.png" alt="Snipaste_2021-04-06_12-57-38"></p>
<p>应该可以通过域名从互联网开机了。</p>
<h2 id="唤醒端配置"><a href="#唤醒端配置" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h2><p>手机下载WOL软件，PC和NAS唤醒配置如下：</p>
<p> <img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_11-37-08.png" alt="Snipaste_2021-04-06_11-37-08"><br> <img src="/2021/network/WOL/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_11-36-52.png" alt="Snipaste_2021-04-06_11-36-52"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>WOL</category>
      </categories>
      <tags>
        <tag>WOL</tag>
        <tag>ARP</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖DSM使用端口大全</title>
    <url>/2021/network/NAS/%E7%BE%A4%E6%99%96DSM%E4%BD%BF%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>设置工具</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Synology Assistant</td>
<td>9999、9998、9997</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>备份</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Data Replicator、Data Replicator II、Data Replicator III</td>
<td>9999、9998、9997、137、138、139、445</td>
<td>TCP</td>
</tr>
<tr>
<td>网络备份</td>
<td>873（数据）、3260（iSCSI LUN）</td>
<td>TCP</td>
</tr>
<tr>
<td>加密的网络备份（远程 Time Backup）</td>
<td>22</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>下载</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>eMule</td>
<td>4662（TCP）、4672（UDP）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>BT</td>
<td>6890 ~ 6999（用于 DSM 版本早于 v2.0.1-3.0401 的机型）；  16881（用于 DSM 版本 v2.0.1 以上的机型）</td>
<td>TCP/UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>网页应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DSM</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Download Station</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>Photo Station、Web Station</td>
<td>80（可添加另外的端口）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Mail Station</td>
<td>80（HTTP）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Audio Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）、5353（Bonjour 服务）、6001-6010（AirPlay 控制/定时）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>File Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）</td>
<td>TCP</td>
</tr>
<tr>
<td>Surveillance Station</td>
<td>9900（HTTP）、9901（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>媒体服务器</td>
<td>1900（UPnP）、50001（内容浏览）、50002（内容串流）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Video Station</td>
<td>5000（HTTP）、5001（HTTPS）、9025-9040、 5002、5004、65001（使用 HDHomeRun 网络调谐器的情况下）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>邮件服务器</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP 含 SSL/TLS</td>
<td>993</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3 含 SSL/TLS</td>
<td>995</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>文件传输</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>FTP、FTP 含 SSL、FTP 含 TLS</td>
<td>21（命令）、20（主动模式的数据连接）、55536-55663（被动模式的数据连接）</td>
<td>TCP</td>
</tr>
<tr>
<td>AFP</td>
<td>548</td>
<td>TCP</td>
</tr>
<tr>
<td>CIFS</td>
<td>smbd：139（netbios-ssn）、445（microsoft-ds）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Nmbd：137、138</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>NFS</td>
<td>111、892、2049</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>WebDAV、CalDAV</td>
<td>5005、5006（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>iSCSI</td>
<td>3260</td>
<td>TCP</td>
</tr>
<tr>
<td>TFTP</td>
<td>69</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>套件</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Cloud Station</td>
<td>6690</td>
<td>TCP</td>
</tr>
<tr>
<td>VPN Server（OpenVPN）</td>
<td>1194</td>
<td>UDP</td>
</tr>
<tr>
<td>VPN Server（PPTP）</td>
<td>1723</td>
<td>TCP</td>
</tr>
<tr>
<td>Syslog Server</td>
<td>514（可添加另外的端口）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>iTunes Server</td>
<td>3689</td>
<td>TCP</td>
</tr>
<tr>
<td>Directory Server</td>
<td>389（LDAP）、636（LDAP 含 SSL）</td>
<td>TCP</td>
</tr>
<tr>
<td>DHCP Server</td>
<td>67、68</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>行动应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DS photo+</td>
<td>80、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS audio</td>
<td>5000、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cam</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS file</td>
<td>Android/iOS 设备：5005、5006（HTTPS） Windows Phone：5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS finder</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS video</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS download</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cloud</td>
<td>6690</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>打印机、UPS 和外围设备</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>LPR</td>
<td>515</td>
<td>UDP</td>
</tr>
<tr>
<td>网络打印机（IPP）/CUPS</td>
<td>631</td>
<td>TCP</td>
</tr>
<tr>
<td>Bonjour</td>
<td>5353</td>
<td>UDP</td>
</tr>
<tr>
<td>网络 MFP</td>
<td>3240-3259</td>
<td>TCP</td>
</tr>
<tr>
<td>UPS</td>
<td>3493</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>系统</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SSH/SFTP</td>
<td>22</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
<td>TCP</td>
</tr>
<tr>
<td>资源监视器/SNMP</td>
<td>161</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>MySQL</td>
<td>3306</td>
<td>TCP</td>
</tr>
<tr>
<td>LDAP</td>
<td>389、636（SLAPD）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖Photo_Station_Video_Station索引无视频缩略图</title>
    <url>/2021/network/NAS/%E7%BE%A4%E6%99%96Photo-Station-Video-Station%E7%B4%A2%E5%BC%95%E6%97%A0%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="群晖（Synology）Photo-Station索引无视频缩略图"><a href="#群晖（Synology）Photo-Station索引无视频缩略图" class="headerlink" title="群晖（Synology）Photo Station索引无视频缩略图"></a>群晖（Synology）Photo Station索引无视频缩略图</h2><h2 id="一、个人环境"><a href="#一、个人环境" class="headerlink" title="一、个人环境"></a>一、个人环境</h2><p>黑群晖DSM6.1.4</p>
<h2 id="二、解决方式"><a href="#二、解决方式" class="headerlink" title="二、解决方式"></a>二、解决方式</h2><p>目前群晖DSM自带的ffmpeg版本是 2.7.1 ，通过社区第三方安装 4.2.4 版本的ffmpeg，即可实现Photo Station索引生成视频缩略图</p>
<h2 id="三、解决步骤"><a href="#三、解决步骤" class="headerlink" title="三、解决步骤"></a>三、解决步骤</h2><h3 id="1、开启SSH登录功能"><a href="#1、开启SSH登录功能" class="headerlink" title="1、开启SSH登录功能"></a>1、开启SSH登录功能</h3><p> <img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424093136937-1495485162.jpg" alt="img"></p>
<h3 id="2、ssh方式登录群辉"><a href="#2、ssh方式登录群辉" class="headerlink" title="2、ssh方式登录群辉"></a>2、ssh方式登录群辉</h3><p>ssh客户端比较多，常见的有Putty、SecureCRT（付费），以Putty为例介绍</p>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424094227293-616185227.jpg" alt="img"></p>
<p>填入“群辉IP地址”和“端口号”，单击“open”</p>
<p>使用管理员账户和密码登录</p>
<h3 id="3、备份历史版本ffmpeg"><a href="#3、备份历史版本ffmpeg" class="headerlink" title="3、备份历史版本ffmpeg"></a>3、备份历史版本ffmpeg</h3><p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv /usr/bin/ffmpeg /usr/bin/ffmpeg_bak</span><br></pre></td></tr></table></figure>
<h3 id="4、安装新版本ffmpeg"><a href="#4、安装新版本ffmpeg" class="headerlink" title="4、安装新版本ffmpeg"></a>4、安装新版本ffmpeg</h3><ul>
<li>打开套件中心 – 右上角设置 – 常规 – 勾选任何发行者</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424095118933-317675568.jpg" alt="img"></p>
<ul>
<li>设置菜单 – 套件来源 – 新增</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424094953347-1914197471.jpg" alt="img"></p>
<p>名称：随便起名</p>
<p>位置：<a href="http://packages.synocommunity.com" target="_blank" rel="noopener">http://packages.synocommunity.com</a></p>
<ul>
<li>安装新版本ffmpeg</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424100424865-1954461477.jpg" alt="img"></p>
<ul>
<li>拷贝</li>
</ul>
<p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -r /usr/<span class="built_in">local</span>/ffmpeg/bin/ffmpeg /usr/bin/ffmpeg</span><br></pre></td></tr></table></figure>
<ul>
<li>重写索引</li>
</ul>
<p>控制面板 – 索引服务 – 索引文件夹，勾选照片+影片，保存，然后点击旁边的“重建索引”按钮</p>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/image-20210703205125971.png" alt></p>
<p>索引需要较长时间，等待其结束</p>
<h2 id="群晖（Synology）video-Station索引无视频缩略图"><a href="#群晖（Synology）video-Station索引无视频缩略图" class="headerlink" title="群晖（Synology）video Station索引无视频缩略图"></a>群晖（Synology）video Station索引无视频缩略图</h2><h2 id="一、个人环境-1"><a href="#一、个人环境-1" class="headerlink" title="一、个人环境"></a>一、个人环境</h2><p>黑群晖DSM6.1.4</p>
<h2 id="二、解决方式-1"><a href="#二、解决方式-1" class="headerlink" title="二、解决方式"></a>二、解决方式</h2><p>1、参考上文，下载新版本ffmpeg</p>
<p>2、编写python脚本，调用ffmpeg截取视频图像</p>
<h2 id="三、解决步骤-1"><a href="#三、解决步骤-1" class="headerlink" title="三、解决步骤"></a>三、解决步骤</h2><p>目前群晖DSM自带的ffmpeg版本是 2.7.1 ，通过社区第三方安装 4.2.4 版本的ffmpeg，Photo Station索引后，可以生成视频缩略图；但Video Station索引后，仍然无法生成视频缩略图。</p>
<p>个人的解决方式为编写python转换脚本</p>
<h3 id="1、下载安装新版ffmpeg"><a href="#1、下载安装新版ffmpeg" class="headerlink" title="1、下载安装新版ffmpeg"></a>1、下载安装新版ffmpeg</h3><h3 id="2、编写python转换脚本"><a href="#2、编写python转换脚本" class="headerlink" title="2、编写python转换脚本"></a>2、编写python转换脚本</h3><p>创建脚本文件photo_thumb.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_type</span><span class="params">(filename,video_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检查是否为视频文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array = map(filename.endswith,video_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span> <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_capture_delay_time</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取截取图片在视频中位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    file_size = os.path.getsize(file_path)</span><br><span class="line">    <span class="keyword">if</span> file_size &lt;= <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>:                                <span class="comment"># 视频大小 &lt;= 1MB，截取视频第1S图片</span></span><br><span class="line">        delay_time = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> file_size &lt;= <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>:                              <span class="comment"># 1MB &lt; 视频大小 &lt;= 4MB，截取视频第5S图片</span></span><br><span class="line">        delay_time = <span class="number">5</span></span><br><span class="line">    <span class="keyword">elif</span> file_size &lt;= <span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>:                             <span class="comment"># 4MB &lt; 视频大小 &lt;= 50MB，截取视频第10S图片</span></span><br><span class="line">        delay_time = <span class="number">10</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        delay_time = <span class="number">20</span>                                             <span class="comment"># 50MB &lt; 视频大小，截取视频第20S图片</span></span><br><span class="line">    <span class="keyword">return</span> delay_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_file_existed</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检查文件是否存在</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_pre</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文件名前缀，如my_video.mp4，返回my_video</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    video_name_list = os.path.splitext(file_name)</span><br><span class="line">    <span class="keyword">if</span> len(video_name_list) == <span class="number">2</span>:</span><br><span class="line">        video_name_pre = video_name_list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        video_name_pre = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> video_name_pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_thumb</span><span class="params">(file_path,video_types)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    遍历文件夹，调用ffmpeg截取视频图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> dir_path,dir_names,file_names <span class="keyword">in</span> os.walk(file_path):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> file_names:</span><br><span class="line">            <span class="comment"># print("*"*20)</span></span><br><span class="line">            <span class="comment"># print(name)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check_type(name,video_types):                    <span class="comment"># 不是视频文件，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                print(<span class="string">"not video,continue next"</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            video_full_path = os.path.join(dir_path, name)</span><br><span class="line">            video_name_pre = get_file_pre(name)</span><br><span class="line">            <span class="keyword">if</span> video_name_pre:                                      <span class="comment"># 如果缩略图已经存在，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                pic_name = <span class="string">'%s%s'</span> % (video_name_pre,<span class="string">'.jpg'</span>)</span><br><span class="line">                picture_full_path = os.path.join(dir_path,pic_name)</span><br><span class="line">                ret = check_file_existed(picture_full_path)</span><br><span class="line">                <span class="keyword">if</span> ret:</span><br><span class="line">                    print(<span class="string">"%s existed,continue next"</span> % picture_full_path)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                delay_time = get_capture_delay_time(video_full_path)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> delay_time:                                  <span class="comment"># 获取文件大小失败，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                shell = <span class="string">'ffmpeg -i "%s" -y -ss %s -frames:v 1 "%s"'</span> % \</span><br><span class="line">                        (video_full_path, delay_time,picture_full_path)</span><br><span class="line">                <span class="comment"># print("#"*20)</span></span><br><span class="line">                print(shell)</span><br><span class="line">                os.system(shell)</span><br><span class="line">                print(<span class="string">"%s capture success"</span> % picture_full_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 当前路径中执行脚本</span></span><br><span class="line">    file_path = sys.path[<span class="number">0</span>]</span><br><span class="line">    video_types = [<span class="string">'.mp4'</span>,<span class="string">'.avi'</span>,<span class="string">'.wmv'</span>,<span class="string">'.mkv'</span>,<span class="string">'.flv'</span>]</span><br><span class="line">    make_thumb(file_path,video_types)</span><br></pre></td></tr></table></figure>
<p> 也可参考如下链接，直接下载</p>
<p>链接：<a href="https://pan.baidu.com/s/1iHW_3GvutSz6d_KPeyxvlA" target="_blank" rel="noopener">https://pan.baidu.com/s/1iHW_3GvutSz6d_KPeyxvlA</a> 提取码：3uok</p>
<h3 id="3、上传至群辉共享文件夹"><a href="#3、上传至群辉共享文件夹" class="headerlink" title="3、上传至群辉共享文件夹"></a>3、上传至群辉共享文件夹</h3><ul>
<li>打开File Station，上传脚本文件photo_thumb.py至需要转换的文件夹，如video</li>
</ul>
<p><img src="/2021/network/NAS/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424104410603-2139857840.jpg" alt="img"></p>
<ul>
<li>脚本执行时，会自动遍历子文件夹，所以只需在最外层文件夹执行即可</li>
</ul>
<h3 id="4、运行脚本"><a href="#4、运行脚本" class="headerlink" title="4、运行脚本"></a>4、运行脚本</h3><p>ssh登录群辉</p>
<p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">cd</span> volume1/video/</span><br><span class="line">sudo python3 photo_thumb.py</span><br></pre></td></tr></table></figure>
<p>注：如上脚本采用python3执行，python2未实验</p>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器端口转发访问NAS</title>
    <url>/2021/network/NAS/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E8%AE%BF%E9%97%AENAS/</url>
    <content><![CDATA[<p>如果<strong>路由器具有公网IP</strong>，则访问家里的NAS时，不需要通过VPS进行转发，直接在路由器中设置端口转发即可。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>路由器具有公网IP</li>
<li>申请一个域名例如aaa.com，并设置了解析 aaa.com -&gt; 路由器公网IP</li>
</ol>
<h2 id="设置IP与MAC地址绑定"><a href="#设置IP与MAC地址绑定" class="headerlink" title="设置IP与MAC地址绑定"></a>设置IP与MAC地址绑定</h2><p>以华硕AC86U为例，开启IP与MAC地址绑定为：</p>
<p><img src="/2021/network/NAS/路由器端口转发访问NAS/Snipaste_2021-04-06_22-15-14.png" alt="Snipaste_2021-04-06_22-15-14"></p>
<h2 id="设置端口转发"><a href="#设置端口转发" class="headerlink" title="设置端口转发"></a>设置端口转发</h2><p>以华硕AC86U为例，开启端口转发的设置为：</p>
<p><img src="/2021/network/NAS/路由器端口转发访问NAS/Snipaste_2021-04-06_21-50-25.png" alt="Snipaste_2021-04-06_21-50-25"></p>
<h2 id="设置DDNS"><a href="#设置DDNS" class="headerlink" title="设置DDNS"></a>设置DDNS</h2><p>路由器的外网动态IP是不断变化的，所以域名解析设置也需要同步更新，使用DDNS服务，可以在路由器公网IP变化时，自动同步域名解析的配置，我们就可以只记住一个域名就可以访问NAS的服务。</p>
<p>以华硕ac86u为例，在软件中心安装<strong>Aliddns</strong>插件，设置如下图：</p>
<p><img src="/2021/network/NAS/路由器端口转发访问NAS/Snipaste_2021-04-06_21-57-55.png" alt="Snipaste_2021-04-06_21-57-55"></p>
<h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>DS file、DS finder、DS audio 官方使用5000端口 ， DS photo官方使用80端口</p>
<p>运营商封锁了aaa.com域名的80、443端口，所以不能访问aaa.com的80和443端口，不需要在端口转发中设置这两个端口的配置。</p>
<p>web端访问管理界面 <a href="http://aaa.com:5000/" target="_blank" rel="noopener">http://aaa.com:5000</a> 端口号不能省略</p>
<p>移动端APP填入以下地址：</p>
<p>ds file aaa.com:5000                :5000能省略，省略的话，APP可能默认使用5000端口<br>ds audio aaa.com:5000           :5000能省略，省略的话，APP可能默认使用5000端口<br>ds photo aaa.com:8008           :8008不能省略，省略的话，APP可能默认使用80端口<br>android drive aaa.com:5000   :5000能省略，省略的话，APP可能默认使用5000端口</p>
<p>windows drive   aaa.com:6690   不能省略端口</p>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
        <tag>NAS</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>FRP内网穿透</title>
    <url>/2021/network/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/FRP%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>NAS没有公网IP是一件很不方便的事情，尤其是在国内的网络环境，学校和小区内的用户通常都没有公网IP。为了解决这个问题，则需要内网穿透，而内网穿透的方法主要有两种：</p>
<p>1.不借助第三方中转，直接建立点对点的连接，创建虚拟局域网。主要有tinc 、Zerotier(先尝试穿透，穿透不了则进行中转)。</p>
<p>2.借助第三方进行数据中转。主要有ngrok、frp。</p>
<p><strong>由于手机4G网络(5G都为IPv6公网IP)和运行商的大内网内的机器（指没有公网IP的机器）所在的网络都为双端NAT网络</strong>，所以第一种方案内网穿透很困难，成功率很低。</p>
<p>而ngrok的使用和配置比frp稍复杂，所以我采用frp进行内网穿透。</p>
<p><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a> 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。github地址：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>VPS有公网IP的服务器，</p>
</li>
<li><p>内网机器这里是群晖NAS，也可以是能安装frpc插件路由器</p>
</li>
<li><p>PUTTY 和WinSCP</p>
</li>
<li><p>阿里云域名,假设你的域名为 aaa.com</p>
</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol>
<li><p><strong>在域名服务商的控制台里设置DNS域名解析  aaa.com解析到NAS IP</strong></p>
</li>
<li><p>到 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a> 下载对应平台的安装包，我是用frp_0.21.0_linux_amd64.tar.gz</p>
</li>
<li><p>如果在windows上，解压后用WinSCP上传到VPS和NAS上/root下。</p>
</li>
<li><p>修改VPS和NAS中frp_0.21.0_linux_amd64文件夹属性改为0777</p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/Snipaste_2021-04-02_11-37-20.png" alt="Snipaste_2021-04-02_11-37-20" style="zoom:67%;"></p>
</li>
</ol>
<h2 id="VPS-NAS组合"><a href="#VPS-NAS组合" class="headerlink" title="VPS+NAS组合"></a>VPS+NAS组合</h2><h3 id="VPS配置"><a href="#VPS配置" class="headerlink" title="VPS配置"></a>VPS配置</h3><p>修改VPS上的frps.ini配置文件，服务端只用frps和frps.ini两个文件，其余都可删掉。</p>
<p>frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"></span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure>
<p>使用putty连接上VPS，切换到 /root/frp_0.21.0_linux_amd64目录下<br>前端开启，关闭窗口时服务同时关闭，仅用于观看输出，不建议使用此命令 <code>./frps -c ./frps.ini</code><br>执行命令 后台开启 <code>nohup ./frps -c ./frps.ini &amp;</code></p>
<h3 id="NAS配置"><a href="#NAS配置" class="headerlink" title="NAS配置"></a>NAS配置</h3><p>修改NAS上的frpc.ini配置文件，客户端只用frpc和frpc.ini两个文件，其余可删掉<br>frpc.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 144.168.60.183</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">log_file = /root/frp_0.21.0_linux_amd64/frpc.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br><span class="line"></span><br><span class="line">[nas]</span><br><span class="line">type = http</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /</span><br><span class="line"></span><br><span class="line">[photo]</span><br><span class="line">type = http</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /photo</span><br><span class="line"></span><br><span class="line">[windowsDrive]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 6690</span><br><span class="line">remote_port = 6690  #TCP类型不需要设置locations或者custom_domains</span><br></pre></td></tr></table></figure>
<p>NAS中配置开机启动脚本：</p>
<ol>
<li>新建 frpcExec.sh到/root,内容为：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">nohup /root/frp_0.21.0_linux_amd64/frpc   -c   /root/frp_0.21.0_linux_amd64/frpc.ini  &gt;  /root/frp_0.21.0_linux_amd64/mynohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>在NAS中新建用户触发脚本任务<code>/root/frpcExec.sh</code></p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/Snipaste_2021-04-02_13-48-45.png" alt="Snipaste_2021-04-02_13-48-45"></p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/Snipaste_2021-04-02_13-48-54.png" alt="Snipaste_2021-04-02_13-48-54"></p>
</li>
</ol>
<h2 id="VPS-路由器组合"><a href="#VPS-路由器组合" class="headerlink" title="VPS+路由器组合"></a>VPS+路由器组合</h2><h3 id="VPS配置-1"><a href="#VPS配置-1" class="headerlink" title="VPS配置"></a>VPS配置</h3><p>修改VPS上的frps.ini配置文件，服务端只用frps和frps.ini两个文件，其余都可删掉。</p>
<p>frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"></span><br><span class="line">#由于路由器不能使用locations，所以使用二级域名，要在此配置</span><br><span class="line">subdomain_host = aaa.com</span><br><span class="line"></span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure>
<p> 使用putty连接上VPS，切换到 /root/frp_0.21.0_linux_amd64目录下，下面的步骤选一个执行</p>
<ul>
<li><p>执行命令 后台开启 <code>nohup ./frps -c ./frps.ini &amp;</code></p>
</li>
<li><p>Centos6中或者将其写入开机启动 vim /etc/rc.local   加入此行<br><code>nohup  /root/frp_0.21.0_linux_amd64/frps -c  /root/frp_0.21.0_linux_amd64/frps.ini  &gt;  /root/frp_0.21.0_linux_amd64/frps.log 2&gt;&amp;1 &amp;</code></p>
</li>
</ul>
<ul>
<li><p>Centos7使用systemd，可以新建服务，开机自动启动</p>
<p>新建文件  <code>vi /etc/systemd/system/frp.service</code> </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/frp_0.21.0_linux_amd64/frps -c /root/frp_0.21.0_linux_amd64/frps.ini </span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -9 $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload # 添加或修改配置文件后，需要重新加载</span><br><span class="line">systemctl enable frp.service # 开机自启</span><br><span class="line">systemctl start  frp.service # 启动测试</span><br><span class="line">systemctl status frp.service # 查看启动状态</span><br><span class="line">systemctl disable frp.service # 关闭开机启动</span><br><span class="line">systemctl stop frp.service # 停止服务</span><br><span class="line">systemctl restart frp.service # 重启服务</span><br></pre></td></tr></table></figure>
<h3 id="路由器AC86U"><a href="#路由器AC86U" class="headerlink" title="路由器AC86U"></a>路由器AC86U</h3><ol>
<li><p>到koolshare论坛下载带有软件中心的固件刷机，下载Frpc插件。或者你用软路由系统的软件中心下载Frpc插件。</p>
<p><img src="/2021/network/内网穿透/FRP内网穿透/image-20210402141322236.png" alt="image-20210402141322236"></p>
</li>
<li><p>在自定义配置中填入一下配置  </p>
<p>路由器的IP为192.168.50.1 </p>
<p>掩码为192.168.50.255</p>
<p>NAS的IP 192.168.50.123</p>
<p>电脑的IP 192.168.50.100</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = VPS IP地址</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log_file = /tmp/upload//frpc.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br><span class="line"></span><br><span class="line">#路由器ssh，需要在路由器中开启ssh模式，一般不需要对外网开放，访问VPS的6000端口，转发到路由器的22端口</span><br><span class="line">[routerSSH]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">#nas的ssh功能，一般不需要对外网开放，访问VPS的6001端口，转发到NAS(192.168.50.123)的22端口</span><br><span class="line">[nasSSH]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6001</span><br><span class="line"></span><br><span class="line">#nas的web端 访问http://aaa.com,转发到NAS(192.168.50.123)的5000端口</span><br><span class="line">[nas]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /</span><br><span class="line"></span><br><span class="line">#transmission的web端 访问http://aaa.com/trans,转发到NAS(192.168.50.123)的9091端口</span><br><span class="line">[transmission]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 9091</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /trans</span><br><span class="line"></span><br><span class="line">[aria2]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 6080</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /aria</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[photo]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /photo</span><br><span class="line"></span><br><span class="line">[windowsDrive]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 6690</span><br><span class="line">remote_port = 6690</span><br><span class="line"></span><br><span class="line">#路由器使用二级域名，通过http://router.aaa.com访问</span><br><span class="line">#使用远程管理路由器也可以进行局域网唤醒</span><br><span class="line">#需要添加二级域名解析 router.aaa.com解析到NAS IP</span><br><span class="line">[router]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.1</span><br><span class="line">local_port = 80</span><br><span class="line">subdomain = router</span><br><span class="line"></span><br><span class="line">#远程唤醒</span><br><span class="line">[wol]</span><br><span class="line">type = udp    #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255    #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9</span><br><span class="line">remote_port = 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#局域网唤醒后，使用远程桌面进行访问，走frps主机流量访问192.168.50.100(电脑固定IP)的3389端口</span><br><span class="line">[remote desktop]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.100</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 3389</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>DS file、DS finder、DS audio 官方使用5000端口 ， DS photo官方使用80端口</p>
<p>web端访问管理界面 <a href="http://aaa.com" target="_blank" rel="noopener">http://aaa.com</a> </p>
<p>web端访问路由器 <a href="http://router.aaa.com" target="_blank" rel="noopener">http://router.aaa.com</a></p>
<p>移动端APP填入以下地址：</p>
<p>ds file                                 aaa.com:80/               :80不能省略，省略的话，APP可能默认使用5000端口<br>ds audio                            aaa.com:80/               :80不能省略，省略的话，APP可能默认使用5000端口<br>ds photo                           aaa.com:80/photo<br>android drive                   aaa.com:80/</p>
<p>windows drive                 aaa.com:6690           不能省略端口</p>
]]></content>
      <categories>
        <category>network</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>frp</tag>
        <tag>NAS</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT号段</title>
    <url>/2021/network/%E7%90%86%E8%AE%BA/NAT%E5%8F%B7%E6%AE%B5/</url>
    <content><![CDATA[<p>我们现在常使用的IP地址是IPv4地址，由32位二进制数组成，每隔8位二进制数字用小数点分隔，可得四组二进制数，将每组二进制数转为十进制数，就是我们平常看到的IP地址。Internet上的每一台主机或者路由器都至少有一个IP地址。IP地址的长度是32位，总数为2的32次方，大约43亿个。</p>
<p>NAT（Network Address Translation），中文名唤作网络地址转换，诞生于IP地址匮乏的时代。</p>
<p>NAT的基本思想是ISP（Internet服务提供商）为每个家庭或者公司分配一个IP地址，这个IP地址用作Internet流量的传输，也就是大家常说的<strong>外网</strong>IP地址或者<strong>公网</strong>IP地址。在客户网络的内部，每台计算机有唯一一个IP地址，即<strong>内网</strong>IP地址，这些地址主要用于路由内部流量。当一个数据包离开客户网络发送至其他ISP时，需要进行<strong>地址转换</strong>，把唯一的内网IP地址转换成外网的IP地址。</p>
<p>这种地址转化使用IP地址的三个范围，这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的IP地址不允许出现在Internet（外网）上，这三个保留的地址范围是：</p>
<p>10.0.0.0~10.255.255.255/8</p>
<p><strong>100.64.0.0 ~100.127.255.255/10</strong>  <strong>用于在电信级NAT环境中服务提供商与其用户通信</strong> </p>
<p>172.16.0.0~172.31.255.255/12</p>
<p>192.168.0.0~192.168.255.255/16</p>
<p>他们分别可以容纳16777216、1048576、65536台主机。一般家里用无线路由器，就用到了网络地址转换技术，我们连上wifi后分配的IP地址一般是以172或192为开头。学校或者大企业里面的网络可能会用到10开头的地址范围。</p>
<p>NAT将内网外网划分好之后，是如何使内网的设备访问外网的呢？</p>
<p>如下图，当计算机<strong>A</strong>在内网（假设IP为10.0.0.1）想去访问一个Internet上的网站<strong>S</strong>（假设IP地址为54.223.189.245）时，<strong>A</strong>的数据包需要先经过一个<strong>NAT盒子</strong>(NAT box)，这个盒子先将<strong>A</strong>的IP源地址转换成外网的真实IP地址（假设IP为121.0.0.2），然后将转换后的数据包发送至Internet。</p>
<p><img src="/2021/network/理论/NAT号段/clip_image001.png" alt="clip_image001"></p>
<p>于是问题来了，当网站<strong>S</strong>收到这个数据包后，会处理请求，并发送响应的数据包，然而这个数据包的目标地址是121.0.0.2（外网IP），数据包如何返回内网中的<strong>A</strong>呢？</p>
<p>这里要先介绍一下<strong>源端口</strong>（Source Port）和<strong>目标端口</strong>（Destination Port）的概念。当一个进程希望与另一个进程建立TCP连接时，它把自己绑定到一个本机尚未被占用的TCP端口上，这个端口称为<strong>源端口</strong>，该TCP连接中所有入境的数据包都要被发送至这个端口。同时进程还需要提供一个<strong>目标端口</strong>，指明数据包到达远程主机后送至哪一个端口处理。每一个出境的TCP数据包都包括一个源端口和目标端口。</p>
<p>举例来说，如下图，网站服务器<strong>S</strong>（IP地址为54.223.189.245）的HTTP服务运行在80端口上，公网上的计算机<strong>D</strong>（IP地址为121.141.56.23）想去访问网站<strong>S</strong>，于是把自己绑定到本机的33121端口上，并发送请求的数据包，这个数据包中就包含了计算机<strong>D</strong>的源端口33121和目标端口80。网站<strong>S</strong>收到请求后，发送响应的数据包，这个数据包中包含了服务器<strong>S</strong>的源端口80和目标端口3312。</p>
<p> <img src="/2021/network/理论/NAT号段/20161103125031128.png" alt="20161103125031128"></p>
<p>上面的例子是外网中的一台计算机访问一个网站。在内网中计算机发送的数据包同样存在着源端口和目标端口。NAT盒子做的事情就是对出入境数据包的端口进行修改。</p>
<p>回到最初举的例子，假设内网计算机<strong>A</strong>（IP地址为10.0.0.1）发送的请求包的源端口是45421，目标端口是80，请求访问网站服务器<strong>S</strong>（IP地址为54.223.189.245）。</p>
<p>当这个出境数据包经过NAT盒子时，其源地址被修改成公网的真实IP（121.0.0.2），源端口被修改一个索引值（假设为50002），这个索引值指向NAT盒子的地址转化表中的某一项，这一表项保存了计算机<strong>A</strong>的内网源地址和源端口。最后NAT盒子将重新生成的数据包发送出去。</p>
<p>当网站S响应的入境数据包到达NAT盒子时，数据包经过处理，目的地址由公网IP（121.0.0.2）还原为计算机A的内网IP（10.0.0.1），目标端口由索引值（50002）还原为计算机A的源端口（45421）。还原后数据包可以正常的在内网路由。</p>
<p>这个过程基本如下图所示。</p>
<p><img src="/2021/network/理论/NAT号段/clip_image003.png" alt="clip_image003"></p>
<p>如此一来，NAT解决了数据包在内网公网之间的地址和端口的转换问题，暂时缓解了IP地址的短缺，但是它却有着不少的缺点。</p>
<p>NAT违背了IP的结构模型（每个IP地址唯一标识世界上的一台机器），采用NAT后可能有无数台主机使用10.0.0.1这个IP地址。NAT还打破了Internet的端-端的连接模型。内网中的主机可以通过NAT与一台公网上的服务建立连接，但是反过来却不行，公网上的主机无法与某一内网中的主机建立连接。举个简单的例子来说，你在内网某台计算机上搭建了一个网站，在外网是无法访问的。而且使用NAT后，Internet变得如电路交换网络一样脆弱。NAT盒子为每个经过它的连接维护必要的信息（即映射关系），若NAT盒子崩溃，并且所有映射表被摧毁，所有TCP连接将被摧毁。</p>
<p>目前的IP地址匮乏，归根结底是IPv4设计者的锅，NAT只是权宜之策。既然NAT这么复杂，有人要问了，在IPv6普及后，NAT是否就会被取缔了呢？答案是不会的。因为NAT已被广泛使用，尤其是家庭和小型企业的网络，即使IPv6普及了，NAT在短时间内也很难被取代。</p>
<p> <strong>IPv4保留地址</strong><br><img src="/2021/network/理论/NAT号段/Snipaste_2021-04-01_15-28-01.png" alt="Snipaste_2021-04-01_15-28-01"></p>
<p><strong>IPv6保留地址</strong><br><img src="/2021/network/理论/NAT号段/Snipaste_2021-04-01_15-28-14.png" alt="Snipaste_2021-04-01_15-28-14"></p>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">保留的IP地址</a></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT类型和穿透性</title>
    <url>/2021/network/%E7%90%86%E8%AE%BA/NAT%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A9%BF%E9%80%8F%E6%80%A7/</url>
    <content><![CDATA[<h2 id="网络地址映射"><a href="#网络地址映射" class="headerlink" title="网络地址映射"></a>网络地址映射</h2><p>在有中心化服务器的网络中，客户端，服务器，网关构成网络拓扑图。如下图1所示：由于后续出现的名词概念很多，先约法三章，在这里统一一下称呼：所有的终端机器成为客户端，不同客户端使用大写字母区分（A,B,C,…）；客户端上面运行的应用程序统一称为客户程序，不同的应用程序使用不数字区分（1,2,3,…）。作为服务器的物理机称为服务器，而服务器上运行的程序称为服务程序，后文中每一个拓扑组件都只有一个IP地址。为客户端提供公网IP服务的组件称为网关。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image002.jpg" alt="img" style="zoom:67%;"></p>
<p>图1 中心化服务器的网络拓扑图</p>
<p>从网关映射到客户端中的网络结构，这里需要引入一个NAT的概念。什么NAT呢？中文名叫网络地址转换，习惯称为网络地址映射。为什么需要网络地址映射呢？：需要说到IPV4网络地址已经用完，全部使用IPV6又会造成很多只支持IPV4的终端设备无法正常使用，所以网络地址映射应运而生，忍辱负重。才会有我们现在所谓的网络穿透的出现。到底怎么映射的？如图2网络地址映射所示。客户程序使用192.168.0.234:7890发送数据，通过网关的网络地址映射在公网被转换为112.93.116.102:6834，被互联网上的大家所认知。此时在公网上使用客户程序的ip与端口被112.93.116.102:6834代替。在这里大家应该明白了NAT是何许物种了。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image004.jpg" alt="img" style="zoom: 67%;"><br>​图2 网络地址映射</p>
<p>为了保持新手福音，业界良心的态度。什么是穿透？因为NAT是客户程序发起的，网络为了保持通讯新建的一个临时牌照，随时可能被收回，而且重新发起后的牌照不一样。从而外界及时知道了这个临时牌照也没有用。所以需要通过穿透在网关上面打个洞，来为外界进行服务。那NAT与穿透有什么关系呢？正因为有了NAT才需要穿透，如果是IPV6每个客户端一个IP地址，那就不需要直接可以找到客户端了。</p>
<h2 id="NAT种类"><a href="#NAT种类" class="headerlink" title="NAT种类"></a>NAT种类</h2><p>  由于网关的安全性要求不一致，就出现四种不同的NAT方式。分别进行阐述：</p>
<p>第一种<strong>完全锥形NAT</strong>，英文名叫<strong>Full Cone NAT</strong>。如图3完全锥形NAT所示，客户程序(192.168.0.234:7890)与服务器A(13.44.178.98:9800)通信，通过网关的地址转换产生的临时牌照的公网地址（112.93.116.102:6834），服务器B（157.78.13.156:23456）发送数据到公网地址（112.93.116.102:6834），如果客户程序(192.168.0.234:7890)能够收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为完全锥形NAT；</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image006.png" alt="img" style="zoom:67%;"><br>​图3 完全锥形NAT</p>
<p>第二种<strong>限制锥形NAT</strong>，英文名叫<strong>RestrictedCone NAT</strong>。在图3 完全锥形NAT中，如果客户程序(192.168.0.234:7890)不能收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为限制型锥形NAT。</p>
<p>第三种<strong>端口限制锥形NAT</strong>，英文名叫<strong>Port RestrictedCone NAT</strong>。客户程序(192.168.0.234:7890)发送数据给服务程序（13.44.178.98:9800）,网关通过网络地址转换产生的地址（112.93.116.102:6834）,同样的服务器内的另一个服务程序（13.44.178.178:9801）发送数据给网关（112.93.116.102:6834）地址，如果客户程序(192.168.0.234:7890)能够收到，则为限制锥形NAT，如果客户程序(192.168.0.234:7890)不能收到，则为端口限制锥形NAT。</p>
<p>  对于所有的锥型NAT，客户程序（192.168.0.234:7890）对外发送的数据时，网关地址转换的地址都是一样的为（112.93.116.102:6834）,那为什么在图4 限制型锥形NAT中，客户程序不能收到服务程序B（13.44.178.98:9801）的数据呢？因为在网关中没有发生过客户程序（192.168.0.234:7890）给服务程序B（13.44.178.98:9801），故服务程序（13.44.178.98:9801）直接发送给网关（112.93.116.102:6834），则被网关所丢弃。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image008.jpg" alt="img" style="zoom:67%;"></p>
<p>图4 限制型锥形NAT</p>
<p>第四种<strong>对称NAT</strong>，英文，名叫<strong>Symmetric NAT</strong>。如图5对称NAT所示，客户程序（192.168.0.234:7890）发送数据给两个不同服务器（13.44.178.98:9800）和（157.78.13.156:23456）时，网关会进行不同的网络地址映射产生（112.93.116.102:6834）和（112.93.116.102:6835）。这是对于整个NAT网络发送数据出去的过程，而接收数据与端口限制锥形NAT一致。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/clip_image010.png" alt="img" style="zoom:67%;"><br>             图5 对称NAT</p>
<h2 id="不同NAT组合的穿透性"><a href="#不同NAT组合的穿透性" class="headerlink" title="不同NAT组合的穿透性"></a><strong>不同NAT组合的穿透性</strong></h2><p>这里说的穿透指在没有经过第三方数据中转的情况下，两者直接建立点对点的连接，可直接进行数据交换，相当于两者在一个虚拟的局域网中。</p>
<p><img src="/2021/network/理论/NAT类型和穿透性/image-20210401162435764.png" alt="image-20210401162435764"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层模型与TCP IP五层模型</title>
    <url>/2021/network/%E7%90%86%E8%AE%BA/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、OSI参考模型"><a href="#一、OSI参考模型" class="headerlink" title="一、OSI参考模型"></a>一、OSI参考模型</h2><p>​    今天我们先学习一下以太网最基本也是重要的知识——OSI参考模型。</p>
<p> 1、OSI的来源</p>
<p>​    OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。</p>
<p>​    ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p>
<p> 2、OSI七层模型的划分</p>
<p>​    OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。如下图。</p>
<p>​    每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p>  <img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234824085-667046040.png" alt="img"></p>
<p> 3、各层功能定义</p>
<p>​    这里我们只对OSI各层进行功能上的大概阐述，不详细深究，因为每一层实际都是一个复杂的层。后面我也会根据个人方向展开部分层的深入学习。这里我们就大概了解一下。我们从最顶层——应用层 开始介绍。整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</p>
<p><1>  应用层</1></p>
<p>​    OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>​    实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</p>
<p><2>  表示层</2></p>
<p>​    表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>​    由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>
<p><3>  会话层</3></p>
<p>​    会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。   </p>
<p>​    会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p>
<p><4>  传输层</4></p>
<p>​    传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<p>​    传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>
<p><5>  网络层</5></p>
<p>​    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>​    网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>
<p><6>  数据链路层 </6></p>
<p>​    将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>   数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p>
<p>​    MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<p>​    这个没找到合适的例子</p>
<p><7> 物理层   </7></p>
<p>​    实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p>​     快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p>
<p>4、通信特点：对等通信   </p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234824866-481636745.png" alt="img"></p>
<h2 id="二、TCP-IP五层模型"><a href="#二、TCP-IP五层模型" class="headerlink" title="二、TCP/IP五层模型"></a>二、TCP/IP五层模型</h2><p>  TCP/IP五层协议和OSI的七层协议对应关系如下。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234825491-384470376.png" alt="img"></p>
<p>  在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234826351-1957282396.png" alt="img"></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同.下图列出了每层主要的协议。其中每层中具体的协议，我会在后面的逐一学习。</p>
<p><img src="/2021/network/理论/OSI七层模型与TCP-IP五层模型/705728-20160424234827195-1493107425.png" alt="img"></p>
<p>参考文献：</p>
<p>  1.百度百科：OSI参考模型</p>
<p>  2.<a href="http://blog.csdn.net/wdkirchhoff/article/details/43915825" target="_blank" rel="noopener">http://blog.csdn.net/wdkirchhoff/article/details/43915825</a></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>远程桌面</title>
    <url>/2021/network/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="远程访问-Android"><a href="#远程访问-Android" class="headerlink" title="远程访问 Android"></a>远程访问 Android</h2><p>小米通话：小米手机之间远程软件，米聊已停服。</p>
<h2 id="远程访问-Windows"><a href="#远程访问-Windows" class="headerlink" title="远程访问 Windows"></a>远程访问 Windows</h2><p>远程软件主要有： </p>
<p><strong>向日葵</strong> 免费，多用时收费</p>
<p><strong>teamviewer</strong> 少用时免费，多用时可能检测为商业用途</p>
<p><strong>Anydesk</strong> 同是德国软件，teamviewer 公司里面的人再创业出品</p>
<p><strong>VNC Server</strong>(被控端) + <strong>VNC Viewer</strong>(控制端) </p>
<p><strong>microsoft remote desktop</strong> 和 <strong>远程桌面</strong>(system32\mstsc.exe) 微软官方出品 <strong>需要局域网环境或内网穿透</strong></p>
<h3 id="windows端设置"><a href="#windows端设置" class="headerlink" title="windows端设置"></a>windows端设置</h3><p>本文介绍在使用<strong>microsoft remote desktop</strong> 或  <strong>远程桌面</strong>(system32\mstsc.exe) 时windows需要设置的配置。</p>
<ol>
<li><p>先确定被遥控的电脑的系统必须是Professional或Enterprise以上版本，<strong>家庭版不支持远程桌面</strong>。</p>
</li>
<li><p>确保自己的系统登录是带有密码的，<strong>采用outlook网络账号登录</strong>，而不是本地账户登录。</p>
</li>
<li><p><strong>打开控制面板 -&gt;系统 -&gt;点击远程设置，在“远程设置”tab页中</strong> 点击允许远程连接到此计算机，并且勾上仅允许运行使用网络级别身份验证的远程桌面的计算机连接（建议）。</p>
<p><img src="/2021/network/远程桌面/远程桌面/1.png" alt="1"></p>
<ol start="4">
<li>点击选择用户，可以看到网络账户，例如：<a href="mailto:aaa@outlook.com" target="_blank" rel="noopener">aaa@outlook.com</a>已经有访问权。</li>
</ol>
</li>
</ol>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_13-25-44.png" alt="Snipaste_2021-04-06_13-25-44"></p>
<ol start="5">
<li>接下来是最重要的一步，依次打开控制面板 -&gt;Windows Defender 防火墙→允许应用或功能通过Windows Defender防火墙，点击更改设置，找到远程桌面（一般为最下方），将后面的两个框都勾上，点击确定保存。</li>
</ol>
<p><img src="/2021/network/远程桌面/远程桌面/22.png" alt="22"></p>
<h3 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问"></a>局域网访问</h3><ol>
<li><p>查看自己的内网IP地址，按Win+R，输入cmd，跳出对话框，输入ipconfig，在跳出的一筐数字中找到一栏，IPv4地址，记录下后面的地址。</p>
</li>
<li><p>打开Microsoft Remote Desktop，PC和Android端都有该软件。或  远程桌面(system32\mstsc.exe) PC端<br>PC name 填入主机的局域网IP，User name 填入网络outlook账号和密码，入下图所示，后面3389为默认端口，可省略。</p>
</li>
</ol>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_19-01-00.png" alt="Snipaste_2021-04-06_19-01-00"></p>
<h3 id="广域网访问"><a href="#广域网访问" class="headerlink" title="广域网访问"></a>广域网访问</h3><h4 id="路由器设置-frp内网穿透"><a href="#路由器设置-frp内网穿透" class="headerlink" title="路由器设置-frp内网穿透"></a>路由器设置-frp内网穿透</h4><p><strong>路由器没有公网IP</strong>，在外网访问家里的电脑，需要在路由器中对frpc进行配置，在VPS进行frps设置（自己的局域网可以利用路由器24小时开机的特性，进行frpc配置，公司网络没这个条件）</p>
<p>唤醒端应用请求vps 3389端口，vps转发到路由器所在的局域网中IP为192.168.50.100的主机的3389端口进行远程桌面。</p>
<p>WOL唤醒后才能远程访问，使用远程桌面进行访问，走vps主机流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote desktop]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.100</span><br><span class="line">local_port = 3389 #通常本地采用3389进行远程访问</span><br><span class="line">remote_port = 3389</span><br></pre></td></tr></table></figure>
<h4 id="路由器设置-端口转发"><a href="#路由器设置-端口转发" class="headerlink" title="路由器设置-端口转发"></a>路由器设置-端口转发</h4><p><strong>路由器有公网IP</strong>，在外网访问家里的电脑，不需要在路由器设置frpc，只需要设置端口转发，如下图：</p>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_19-14-42.png" alt="Snipaste_2021-04-06_19-14-42"></p>
<p>唤醒程序直接根据路由器IP，请求路由器IP的3389 端口，不需要经过VPS转发，速度更快。</p>
<h4 id="唤醒端设置"><a href="#唤醒端设置" class="headerlink" title="唤醒端设置"></a>唤醒端设置</h4><p>打开Microsoft Remote Desktop，PC name 填入域名:3389   User name 填入网络outlook账号和密码</p>
<p><img src="/2021/network/远程桌面/远程桌面/Snipaste_2021-04-06_19-01-19.png" alt="Snipaste_2021-04-06_19-01-19"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>远程桌面</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>端口转发</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位</title>
    <url>/2019/%E5%89%8D%E7%AB%AF/HTML%20CSS/CSS%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;定位&lt;/title&gt;</span><br><span class="line">  &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-id">#left</span>,<span class="selector-id">#center</span>,<span class="selector-id">#right</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">33.3%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  相对定位</span></span><br><span class="line"><span class="comment">  1.相对于自己原来的显示位置进行显示</span></span><br><span class="line"><span class="comment">  2.原来的空间不会被其他元素占用</span></span><br><span class="line"><span class="comment">  3.如果一个元素，只是开启了相对定位，没有偏移量， 那么这个元素一般是用来作为参照的，&lt;div style="position: relative"&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   绝对定位</span></span><br><span class="line"><span class="comment">   1.相对于离他最近的，并且使用了定位的父元素，如果没有找到，以body为参照</span></span><br><span class="line"><span class="comment">   2.原来的显示空间会被其他元素占用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#fix</span>&#123;</span><br><span class="line">  <span class="comment">/*以整个屏幕为基准*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;div style="position: relative"&gt;</span><br><span class="line">  &lt;div id="left"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div id="center"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div id="right"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id="fix"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/前端/HTML CSS/CSS定位/Snipaste_2019-02-06_15-08-02.png" alt="Snipaste_2021-07-06_15-08-02"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>AC86U创建虚拟内存U盘读写速度不够</title>
    <url>/2021/network/%E8%B7%AF%E7%94%B1%E5%99%A8/AC86U%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98U%E7%9B%98%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%A4%9F/</url>
    <content><![CDATA[<h4 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h4><p><code>AC86U</code> 升级固件后挂载虚拟内存总是提示读写速度不够，新固件的读取速度要求 <code>20M/s</code>，写入速度要求 <code>30M/s</code><br><img src="/2021/network/路由器/AC86U创建虚拟内存U盘读写速度不够/20210106091033.png" alt="img"></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>修改参数限制</p>
<p><code>ssh</code> 登录到路由器，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改写入速度限制，30替换为10</span><br><span class="line">sed -i &apos;s/^W_LIMIT=30/W_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br><span class="line"></span><br><span class="line"># 修改读取速度限制，20替换为10</span><br><span class="line">sed -i &apos;s/^R_LIMIT=20/R_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br></pre></td></tr></table></figure>
<p>以上参数可以根据自己的实际情况进行调整</p>
<p>完成后重新进入管理界面挂载虚拟内存即可</p>
]]></content>
      <categories>
        <category>network</category>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>padding陷阱</title>
    <url>/2018/%E5%89%8D%E7%AB%AF/HTML%20CSS/padding%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>我们都知道padding是为块级元素设置内边距</p>
<p>但是在使用过程中，我们却会遇到一些问题。padding的标准盒模型和怪异盒模型</p>
<h4 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a><strong>标准盒模型</strong></h4><p>我们先摆出HTML和CSS代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.shoebox</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            padding: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.shoes</span>&#123;</span></span><br><span class="line">            width: 80px;</span><br><span class="line">            height: 80px;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoebox"</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoes"</span>&gt;</span>              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>一个demo，我的一双大小是 80*80  的鞋子,为此我给了这个鞋子做了一个 100*100 的盒子，我想要让这个鞋子有10px的内边距，所以我设了一个 padding: 10px; </p>
<p>我们想象中的场景效果可能是这样的：<img src="/2018/前端/HTML CSS/padding陷阱/Snipaste_2018-06-27_15-46-29.png" alt="Snipaste_2021-07-06_15-46-29">  但是现实真的好残酷。。他却是这样的：</p>
<p><img src="/2018/前端/HTML CSS/padding陷阱/Snipaste_2018-06-27_15-46-14.png" alt="Snipaste_2021-07-06_15-46-14"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27154932074.png" alt="image-20210706154932074"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27155011508.png" alt="image-20210706155011508"></p>
<p>这时候我们会很奇怪，明明我们设置的shoebox的高和宽是100*100怎么变成了110*110了呢，这多出来的10px是怎么回事。</p>
<p>这是padding元素膨胀造成的结果。在标准盒模型中，设置padding会自动挤压空间，而不会利用给出来的空间，不会占用宽内位置，不通过width影响，会自己挤出空间来，就好像，我的鞋子是80*80的，我不需要100*100的盒子，你给我一个80*80的盒子就好了，我靠我自己来把他挤成100*100，这时很显然的解决的办法就出来了，我们的盒子的宽度只要设置成80*80然后设置padding：10px；来让鞋子把周围额空间挤成100*100。</p>
<p>这就是padding的标准盒模型，先做好鞋子，再去做盒子</p>
<h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a><strong>怪异盒模型</strong></h4><p>怪异盒模型与标准盒模型的区别就是，怪异盒模型是先做好盒子，再来做鞋子，我把盒子的大小固定住，你鞋子怎么挤也没有用。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.shoebox</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            padding: 10px;</span><br><span class="line">            box-sizing: border-box;//怪异盒模型</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.shoes</span>&#123;</span></span><br><span class="line">            width: 80px;</span><br><span class="line">            height: 80px;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoebox"</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"shoes"</span>&gt;</span>              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这时我们只要在我们的代码中加一条box-sizing：boeder-box，就可以把我的盒子给固定住，这时你鞋子想要用padding来撑大盒子的空间已经没用了，因为鞋子已经被固定死了。<br><img src="/2018/前端/HTML CSS/padding陷阱/Snipaste_2018-06-27_15-46-29.png" alt="Snipaste_2021-07-06_15-46-29"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27155148568.png" alt="image-20210706155148568"><br><img src="/2018/前端/HTML CSS/padding陷阱/image-2018-06-27155011508.png" alt="image-20210706155011508"></p>
<p>最后在<strong>总结</strong>一点padding的知识：</p>
<ol>
<li><p>当我们给width设置一个固定的值或者给width设置100%时，设置padding都会把盒子给挤开，挤大了</p>
</li>
<li><p>若想要不使用怪异盒模型又不会把盒子挤大，请把width设置为auto，width默认的值是auto。自动占满整个屏幕</p>
</li>
<li><p>标准盒模型在pc端比较常用，因为pc端的屏幕大，有优势可以撑</p>
</li>
<li><p>怪异盒模型在手机端比较常用。手机屏幕是有限大小的，有时我们往往需要使用怪异盒模型把他固定住。</p>
</li>
<li><p>怪异盒模型的盒子大小还要加上border的大小。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>雷鸟电视在线安装软件</title>
    <url>/2021/network/%E7%94%B5%E8%A7%86/%E9%9B%B7%E9%B8%9F%E7%94%B5%E8%A7%86%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新买的雷鸟R625C电视往往默认是无法安装第三方应用的，即使用U盘安装了第三方应用，应用也没有升级权限。另外，也无法通过沙发管家等应用市场来安装应用。接下来说说如何使用adb工具打开雷鸟电视的第三方应用安装权限。</p>
<h2 id="ADB安装"><a href="#ADB安装" class="headerlink" title="ADB安装"></a>ADB安装</h2><p>ADB的全称为Android Debug Bridge，通过ADB工具，我们可以直接操作管理android模拟器或者真实的android设备（如安卓手机、机顶盒）。它主要有以下几种作用：<br>（1）运行设备的shell(命令行)<br>（2）管理模拟器或设备的端口映射<br>（3）计算机和android设备之间上传/下载文件<br>（4）将本地apk软件安装至android模拟器或android设备</p>
<h3 id="下载Android-Platform-Tools"><a href="#下载Android-Platform-Tools" class="headerlink" title="下载Android Platform Tools"></a>下载Android Platform Tools</h3><p>到Android开发官网下载Android Platform Tools并解压，解压后可以看到文件夹platform-tools，里面包含adb调试工具。<br> <img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111636482.png" alt="image-20210331111636482"></p>
<h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><p>打开“我的电脑-&gt;属性-&gt;系统高级设置-&gt;环境变量”，在Path变量中添加platform-tools文件夹的路径：</p>
<p><img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111701288.png" alt="image-20210331111701288"></p>
<h3 id="运行ADB"><a href="#运行ADB" class="headerlink" title="运行ADB"></a>运行ADB</h3><p>打开命令行窗口，输入adb，能打印出adb的版本号和用法，即为安装成功。</p>
<p> <img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111724426.png" alt="image-20210331111724426"></p>
<h2 id="打开电视的adb调试开关"><a href="#打开电视的adb调试开关" class="headerlink" title="打开电视的adb调试开关"></a>打开电视的adb调试开关</h2><p>进入设置-&gt;系统-&gt;系统信息，遥控器依次按下“上”、“下”、“左”、“右”，即可看到页面中跳出adb开关，将ADB设为开启状态即可：</p>
<p><img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331111929404.png" alt="image-20210331111929404"></p>
<h2 id="abd工具打开电视权限"><a href="#abd工具打开电视权限" class="headerlink" title="abd工具打开电视权限"></a>abd工具打开电视权限</h2><ol>
<li><p>首先将电脑和雷鸟电视连接到同一网络下。</p>
</li>
<li><p>查看雷鸟电视的ip地址，我的这台电视的ip为192.168.0.129</p>
</li>
<li><p>根据上一步获得的ip地址，在windows命令行执行<code>adb connect 192.168.0.129:5555</code>连接到雷鸟电视：</p>
</li>
<li><p>执行adb shell进入shell模式，然后执行以下两条命令就可以成功打开第三方应用安装权限：<br><code>setprop persist.tcl.debug.installapk 1</code><br><code>setprop persist.tcl.installapk.enable 1</code></p>
<p><img src="/2021/network/电视/雷鸟电视在线安装软件/image-20210331112424137.png" alt="image-20210331112424137"></p>
</li>
<li><p>然后再尝试用电视安装或升级第三方应用，第三方应用已经可以正常安装和升级，用当贝极速版或者沙发管家下载就可以了。</p>
</li>
<li><p>如果需要直接通过adb工具安装应用，先按照步骤1~3连接到电视，再执行<code>adb install</code>命令安装应用即可：<br><code>adb install XXX.apk</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>network</category>
        <category>电视</category>
      </categories>
      <tags>
        <tag>电视</tag>
      </tags>
  </entry>
  <entry>
    <title>toFixed四舍五入问题</title>
    <url>/2021/%E5%89%8D%E7%AB%AF/Vue.js/toFixed%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近做的项目涉及到金额的计算，有一种方式就是进行四舍五入的规则进行小数点后面的尾数处理，以前一直以为toFixed方法就是四舍五入的，知道一个用户反馈了金额计算的bug我才如梦初醒，才仔细深究了下toFixed这个方法，唉，还是我不够严谨啊，前车之鉴，大家勿走我的老路！</p>
<p>toFixed还不同的浏览器实现，在IE10及以上里面是正常的四舍五入，但是别的浏览器里面就不一样了，它不是正常的四舍五入（等下重点说），比如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1.335</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.toFixed(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// IE         1.34</span></span><br><span class="line"><span class="comment">//chorme   1.33</span></span><br></pre></td></tr></table></figure>
<p> 其他的浏览器我没去一一测试，所以如果大家用了其他浏览器的还是需要去实际测试一下，我这里就说说javascript的toFixed()方法的四舍五入原理：</p>
<p>toFixed它是一个四舍六入五成双的诡异的方法(也叫银行家算法)，”四舍六入五成双”含义：对于位数很多的近似数，当有效位数确定后，其后面多余的数字应该舍去，只保留有效数字最末一位，这种修约（舍入）规则是“四舍六入五成双”，也即“4舍6入5凑偶”这里“四”是指≤4 时舍去，”六”是指≥6时进上，”五”指的是根据5后面的数字来定，当5后有数时，舍5入1；当5后无有效数字时，需要分两种情况来讲：①5前为奇数，舍5入1；②5前为偶数，舍5不进。（0是偶数）</p>
<p>但是，经过我的测试发现，在chorme下面（最新版），并没有完全遵守这个规则，尤其是5的后面没有数字的时候，不是这么判断的，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1.335</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.33"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.345</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.34"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.355</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.35"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.365</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.36"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.375</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.38"</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1.385</span></span><br><span class="line">b.toFixed(<span class="number">2</span>)</span><br><span class="line"><span class="string">"1.39"</span></span><br></pre></td></tr></table></figure>
<p>可以发现在chorme下没有完全去遵循这个规律，或许它有自己的算法，但是毕竟它没有遵循通用的银行家算法，所以tofixed这个方法在涉及到金钱计算的业务中还是少用，<br>最好别用，否则可能会出大问题！</p>
<p>总结：众所周知，遵循IEEE754数值格式的语言的浮点计算会出现精度损耗的通病，ES也并非独此一家，因此尽量不要进行某个特定浮点数值的测试，如：0.1+0.2；<br>解决方案：重写Number.prototype.toFixed()方法:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.toFixed=<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123; </span><br><span class="line">             <span class="keyword">var</span> s=<span class="keyword">this</span>+<span class="string">""</span>; </span><br><span class="line">             <span class="keyword">if</span>(!d)d=<span class="number">0</span>; </span><br><span class="line">             <span class="keyword">if</span>(s.indexOf(<span class="string">"."</span>)==<span class="number">-1</span>)s+=<span class="string">"."</span>; </span><br><span class="line">             s+=<span class="keyword">new</span> <span class="built_in">Array</span>(d+<span class="number">1</span>).join(<span class="string">"0"</span>); </span><br><span class="line">             <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^(-|\\+)?(\\d+(\\.\\d&#123;0,"</span>+(d+<span class="number">1</span>)+<span class="string">"&#125;)?)\\d*$"</span>).test(s))&#123;</span><br><span class="line">                <span class="keyword">var</span> s=<span class="string">"0"</span>+<span class="built_in">RegExp</span>.$<span class="number">2</span>,pm=<span class="built_in">RegExp</span>.$<span class="number">1</span>,a=<span class="built_in">RegExp</span>.$<span class="number">3.</span>length,b=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(a==d+<span class="number">2</span>)&#123;</span><br><span class="line">                    a=s.match(<span class="regexp">/\d/g</span>); </span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(a[a.length<span class="number">-1</span>])&gt;<span class="number">4</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">var</span> i=a.length<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                            a[i]=<span class="built_in">parseInt</span>(a[i])+<span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span>(a[i]==<span class="number">10</span>)&#123;</span><br><span class="line">                                a[i]=<span class="number">0</span>;</span><br><span class="line">                                b=i!=<span class="number">1</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    s=a.join(<span class="string">""</span>).replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(\\d+)(\\d&#123;"</span>+d+<span class="string">"&#125;)\\d$"</span>),<span class="string">"$1.$2"</span>);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">if</span>(b)s=s.substr(<span class="number">1</span>); </span><br><span class="line">                <span class="keyword">return</span> (pm+s).replace(<span class="regexp">/\.$/</span>,<span class="string">""</span>);</span><br><span class="line">           &#125;<span class="keyword">return</span> <span class="keyword">this</span>+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.335--&gt;"</span>+ <span class="number">1.335</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.335--&gt;"</span>+ <span class="number">1.335</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.345--&gt;"</span>+ <span class="number">1.345</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.345--&gt;"</span>+ <span class="number">1.345</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.355--&gt;"</span>+ <span class="number">1.355</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.355--&gt;"</span>+ <span class="number">1.355</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"1.365--&gt;"</span>+ <span class="number">1.365</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.365--&gt;"</span>+ <span class="number">1.365</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.375--&gt;"</span>+ <span class="number">1.375</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.375--&gt;"</span>+ <span class="number">1.375</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.385--&gt;"</span>+ <span class="number">1.385</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"-1.385--&gt;"</span>+ <span class="number">1.385</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.045--&gt;"</span>+ <span class="number">1.045</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0455--&gt;"</span>+ <span class="number">1.0455</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0453--&gt;"</span>+ <span class="number">1.0453</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0450--&gt;"</span>+ <span class="number">1.0450</span>.toFixed(<span class="number">2</span>));</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"1.0452--&gt;"</span>+ <span class="number">1.0450</span>.toFixed(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动</title>
    <url>/2018/%E5%89%8D%E7%AB%AF/HTML%20CSS/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>float<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#left</span>&#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: aqua;</span><br><span class="line">      width: 50%;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#right</span>&#123;</span></span><br><span class="line">      height: 120px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      width: 50%;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#content2</span>&#123;</span></span><br><span class="line">      height: 150px;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.clearFix</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line">      content: '清除浮动';</span><br><span class="line">      display: block;</span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#cle</span>&#123;</span></span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 行内元素 不占一行 宽度取决于包裹的元素宽度</span></span><br><span class="line"><span class="comment">     块状元素占一行</span></span><br><span class="line"><span class="comment">浮动后块状元素变成行内元素，如果不设置宽度时，宽度大小取决于其包裹的元素的大小--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content1"</span>  <span class="attr">class</span>=<span class="string">"clearFix"</span>  &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;div id="cle"&gt;&lt;/div&gt;--&gt;</span> <span class="comment">&lt;!--此清除float方法不好，添加了一个dom元素，采用class="clearFix"即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content2"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>清除浮动前：</p>
<p><img src="/2018/前端/HTML CSS/清除浮动/Snipaste11.png" alt="Snipaste11"></p>
<p>清除浮动后：</p>
<p><img src="/2018/前端/HTML CSS/清除浮动/Snipaste1.png" alt="Snipaste1"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>HTML CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>js做四则运算精度丢失问题及解决方法</title>
    <url>/2021/%E5%89%8D%E7%AB%AF/Vue.js/js%E5%81%9A%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E6%97%B6%EF%BC%8C%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>之前项目上出现过这样一个bug,就是明明两个数都是一样的但是就是莫名其妙的报出两个数不相等,导致流程无法继续下去<br>然后我把所有数据导出来,进行一对一比对,只是一个很耗时的过程,最终让我找到<br>因为js计算过后会出现计算精度丢失的问题 找到问题所在就好说了,然后就开始解决这个让我为难了好长时间的问题<br>废话不多说直接上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相加精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==a||<span class="literal">null</span>==a||<span class="string">""</span>==a||<span class="built_in">isNaN</span>(a))&#123;a=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==b||<span class="literal">null</span>==b||<span class="string">""</span>==b||<span class="built_in">isNaN</span>(b))&#123;b=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = a.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        d = b.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(c, d));</span><br><span class="line">    <span class="keyword">return</span>  (floatMul(a, e) + floatMul(b, e)) / e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相减精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatSub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==a||<span class="literal">null</span>==a||<span class="string">""</span>==a||<span class="built_in">isNaN</span>(a))&#123;a=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span>==b||<span class="literal">null</span>==b||<span class="string">""</span>==b||<span class="built_in">isNaN</span>(b))&#123;b=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = a.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        d = b.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;</span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(c, d));</span><br><span class="line">    <span class="keyword">return</span> (floatMul(a, e) - floatMul(b, e)) / e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相乘精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatMul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">0</span>,</span><br><span class="line">        d = a.toString(),</span><br><span class="line">        e = b.toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c += d.split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c += e.split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (f) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(d.replace(<span class="string">"."</span>, <span class="string">""</span>)) * <span class="built_in">Number</span>(e.replace(<span class="string">"."</span>, <span class="string">""</span>)) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决两个数相除精度丢失问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floatDiv</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e = <span class="number">0</span>,</span><br><span class="line">        f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        e = a.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (g) &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f = b.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (g) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> c = <span class="built_in">Number</span>(a.toString().replace(<span class="string">"."</span>, <span class="string">""</span>)), d = <span class="built_in">Number</span>(b.toString().replace(<span class="string">"."</span>, <span class="string">""</span>)), floatMul(c / d, <span class="built_in">Math</span>.pow(<span class="number">10</span>, f - e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就解决js精度丢失<br>原理也很简单 就是很好的运用了我们小学所学的算术的小数相乘/相加/相减/相除后小数位的变化规律来进行精度的换算</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底明白VUE修饰符sync</title>
    <url>/2021/%E5%89%8D%E7%AB%AF/Vue.js/%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDVUE%E4%BF%AE%E9%A5%B0%E7%AC%A6sync/</url>
    <content><![CDATA[<blockquote>
<p>对于VUE的初学者来讲，肯定会感觉prop的写法很麻烦，很讨厌！你肯定想如果prop也可以实现双向绑定那怎是一个爽字了得！不过现实是残酷的，如果子组件可以任意修改父组件的内容，那势必会带来数据的混乱，从而造成维护的困扰！毕竟父组件也是有尊严的！</p>
</blockquote>
<p>官方推荐使用一种update:my-prop-name 的模式来替代事件触发，目的是为了优雅而不粗鲁的实现父子组件间的双向绑定！先来完成一个小功能：通过父组件按钮将子组件显示出来，如图：</p>
<p><img src="/2021/前端/Vue.js/彻底明白VUE修饰符sync/webp" alt="img"></p>
<p>父组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span> </span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"@/components/child"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                isShow:<span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=<span class="literal">true</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件child代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来加个需求，在子组当中增加一个按钮，通过该按钮来将自已隐藏起来！需要借助父子之间的传值了！如图：</p>
<p><img src="/2021/前端/Vue.js/彻底明白VUE修饰符sync/webp1" alt="img"></p>
<p>父组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> @<span class="attr">upIsShow</span>=<span class="string">"changeIsShow"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"@/components/child"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                isShow:<span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=<span class="literal">true</span>;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeIsShow(bol)&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=bol;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我隐身"</span> @<span class="attr">click</span>=<span class="string">"upIsShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods:&#123;</span><br><span class="line">            upIsShow()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">"upIsShow"</span>,<span class="literal">false</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我要将父组件中的事@upIsShow修改为@update:isShow不违法吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"changeIsShow"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>子组件的emit自然也要做对应调整：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">upIsShow()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"update:isShow"</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，一切正常！真好！</p>
<p>那么如果现在我将父组件的changeIsShow直接写成匿名函数，也能运行吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"function(bol)&#123;isShow=bol&#125;"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>再次运行，一切还是那么美好，真好！</p>
<p>现在我将那匿名函数改成箭头函数，不过分吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"bol=&gt;isShow=bol"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>再运行一次，完美，真好！</p>
<p>最后我将上面那行代码做最后一次修改：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child :isShow.<span class="keyword">sync</span>=<span class="string">"isShow"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>至此终于涉及到了sync了。以上代码 :isShow.sync=”isShow”其实是 @update:isShow=”bol=&gt;isShow=bol”语法糖。是其一种简写形式。附上完整代码。<br>父组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">:isShow.sync</span>=<span class="string">"isShow"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"@/components/child"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                isShow:<span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=<span class="literal">true</span>;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeIsShow(bol)&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.isShow=bol;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我隐身"</span> @<span class="attr">click</span>=<span class="string">"upIsShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">        methods:&#123;</span><br><span class="line">            upIsShow()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">"update:isShow"</span>,<span class="literal">false</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后：sync只是给大家伙提供了一种与父组件沟通的思路而已！所以在后面日子里，你如果只是单纯的在子组件当中修改父组件的某个数据时，建议使用sync，简单，快捷，有档次！真好！</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
</search>
